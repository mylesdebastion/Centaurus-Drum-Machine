# Story 15.4: Module Routing System

**Epic:** Epic 15 - Chord Progression & Melody Arranger Module
**Status:** ðŸ“ READY FOR DEVELOPMENT
**Priority:** ðŸ”´ CRITICAL
**Complexity:** High
**Time Estimate:** 6-8 hours
**Prerequisites:** Story 15.3 (Melody Arranger Component)

---

## User Story

As a **music producer**,
I want **to route chord and melody events from ChordMelodyArranger to other loaded Studio modules**,
So that **I can send musical data to synthesizers, visualizers, or external MIDI hardware without module coupling**.

---

## Story Context

**Existing System Integration:**
- Integrates with: ChordMelodyArranger (Story 15.2-15.3), Studio module system (Epic 14), GlobalMusicContext (Epic 4)
- Technology: TypeScript, Event bus pattern (pub/sub), React Context API
- Follows pattern: Singleton service layer (similar to audioEngine, midiInputManager)
- Touch points:
  - `src/services/moduleRoutingService.ts` (new service)
  - `src/components/Studio/modules/ChordMelodyArranger/ChordMelodyArranger.tsx` (integrate routing UI)
  - `src/components/Studio/modules/ChordMelodyArranger/OutputSelector.tsx` (new component)
  - `src/components/Studio/Studio.tsx` (module lifecycle management)
  - `src/components/Studio/moduleRegistry.ts` (module capabilities metadata)

**Why This Story:**
Story 15.3 created melody sequencer that generates note events. This story enables those events to be routed to other loaded modules (e.g., send melody to Guitar-Fretboard for visualization, send chords to PianoRoll, send to MIDI output hardware). The routing system must:
- Decouple source modules (ChordMelodyArranger) from target modules (any module)
- Provide UI for selecting output destinations
- Support multiple simultaneous targets (broadcast to multiple modules)
- Follow event bus pattern for scalability

**Key Architectural Decision:**
Use **ModuleRoutingService** singleton with event bus pattern (not direct component coupling). This enables future modules to also emit/receive events without code changes.

---

## Acceptance Criteria

### Functional Requirements

1. **Create ModuleRoutingService Class**
   - File: `src/services/moduleRoutingService.ts`
   - Singleton pattern (single instance shared across app)
   - Methods:
     ```typescript
     export interface ModuleCapabilities {
       canReceiveNotes?: boolean;       // Can receive MIDI note events
       canReceiveChords?: boolean;      // Can receive chord progression events
       canReceiveTempo?: boolean;       // Can receive tempo changes
       canEmitNotes?: boolean;          // Can emit MIDI note events
       canEmitChords?: boolean;         // Can emit chord progression events
     }

     export interface LoadedModule {
       instanceId: string;              // Unique ID (e.g., "piano-roll-1")
       moduleId: string;                // Module type (e.g., "piano-roll")
       name: string;                    // Display name (e.g., "Piano Roll 1")
       capabilities: ModuleCapabilities;
     }

     export interface NoteEvent {
       type: 'note-on' | 'note-off';
       pitch: number;                   // MIDI note number (0-127)
       velocity: number;                // 0-127
       timestamp: number;               // Performance.now()
       sourceInstanceId: string;        // Who sent this event
     }

     export interface ChordEvent {
       type: 'chord-change';
       chordName: string;               // "Cmaj7", "Am", etc.
       notes: number[];                 // MIDI note numbers
       timestamp: number;
       sourceInstanceId: string;
     }

     class ModuleRoutingService {
       // Register a module when it loads
       registerModule(module: LoadedModule): void;

       // Unregister when module unloads
       unregisterModule(instanceId: string): void;

       // Get all loaded modules that can receive events
       getAvailableTargets(
         sourceInstanceId: string,
         capability: keyof ModuleCapabilities
       ): LoadedModule[];

       // Route a note event to specific targets
       routeNoteEvent(
         event: NoteEvent,
         targetInstanceIds: string[]
       ): void;

       // Route a chord event to specific targets
       routeChordEvent(
         event: ChordEvent,
         targetInstanceIds: string[]
       ): void;

       // Subscribe to events (for receiving modules)
       subscribeToNoteEvents(
         instanceId: string,
         callback: (event: NoteEvent) => void
       ): () => void; // Returns unsubscribe function

       subscribeToChordEvents(
         instanceId: string,
         callback: (event: ChordEvent) => void
       ): () => void;
     }
     ```

2. **OutputSelector Component Created**
   - File: `src/components/Studio/modules/ChordMelodyArranger/OutputSelector.tsx`
   - Props interface:
     ```typescript
     export interface OutputSelectorProps {
       sourceInstanceId: string;
       selectedTargets: string[];       // Array of target instanceIds
       onTargetsChange: (targets: string[]) => void;
     }
     ```
   - UI features:
     - Dropdown or modal showing available target modules
     - Checkboxes to select multiple targets (multi-select)
     - Module icons displayed (from moduleRegistry)
     - Group by module type (Instruments, Visualizers, Hardware)
     - Empty state message: "No modules loaded. Add modules to Studio to route output."

3. **Module Capability Metadata**
   - Update `src/components/Studio/moduleRegistry.ts`
   - Add capabilities field to ModuleDefinition:
     ```typescript
     export interface ModuleDefinition {
       id: string;
       name: string;
       description: string;
       component: ComponentType<any>;
       icon: ComponentType<{ className?: string }>;
       color: string;
       category: 'instrument' | 'sequencer' | 'visualizer';
       capabilities: ModuleCapabilities; // NEW
     }

     // Example:
     {
       id: 'piano-roll',
       name: 'Piano Roll',
       capabilities: {
         canReceiveNotes: true,
         canReceiveChords: true,
         canEmitNotes: false,
       }
     }
     ```

4. **ChordMelodyArranger Integration**
   - Add OutputSelector to ChordMelodyArranger UI
   - Position in header or settings panel
   - Store selected targets in component state
   - Emit note/chord events when playback active:
     ```typescript
     // ChordMelodyArranger.tsx
     const [outputTargets, setOutputTargets] = useState<string[]>([]);
     const routingService = ModuleRoutingService.getInstance();

     const handleMelodyNote = (note: MelodyNote) => {
       if (outputTargets.length === 0) return;

       const event: NoteEvent = {
         type: 'note-on',
         pitch: note.pitch,
         velocity: note.velocity,
         timestamp: performance.now(),
         sourceInstanceId: instanceId, // From ModuleComponentProps
       };

       routingService.routeNoteEvent(event, outputTargets);

       // Schedule note-off event
       setTimeout(() => {
         routingService.routeNoteEvent({
           ...event,
           type: 'note-off',
         }, outputTargets);
       }, note.duration * 1000); // Convert beats to ms
     };

     const handleChordChange = (chord: Chord) => {
       if (outputTargets.length === 0) return;

       const event: ChordEvent = {
         type: 'chord-change',
         chordName: chord.name,
         notes: chord.notes.map(n => n.fret + n.string * 5), // Convert to MIDI
         timestamp: performance.now(),
         sourceInstanceId: instanceId,
       };

       routingService.routeChordEvent(event, outputTargets);
     };
     ```

5. **Studio Lifecycle Integration**
   - Update `src/components/Studio/Studio.tsx`
   - Register/unregister modules with ModuleRoutingService
   - Pass instanceId to loaded modules via ModuleComponentProps
   - Example:
     ```typescript
     // Studio.tsx
     const [loadedModules, setLoadedModules] = useState<LoadedModuleInstance[]>([]);
     const routingService = ModuleRoutingService.getInstance();

     const loadModule = (moduleId: string) => {
       const moduleDef = moduleRegistry.find(m => m.id === moduleId);
       const instanceId = `${moduleId}-${Date.now()}`; // Unique ID

       const instance: LoadedModuleInstance = {
         instanceId,
         moduleId,
         name: `${moduleDef.name} ${loadedModules.length + 1}`,
         capabilities: moduleDef.capabilities,
       };

       // Register with routing service
       routingService.registerModule(instance);

       setLoadedModules(prev => [...prev, instance]);
     };

     const unloadModule = (instanceId: string) => {
       routingService.unregisterModule(instanceId);
       setLoadedModules(prev => prev.filter(m => m.instanceId !== instanceId));
     };
     ```

### Integration Requirements

6. **Event Bus Pattern**
   - ModuleRoutingService maintains internal event listeners map
   - Publish-subscribe pattern (1 publisher â†’ N subscribers)
   - No direct module-to-module coupling
   - Example internal structure:
     ```typescript
     class ModuleRoutingService {
       private modules: Map<string, LoadedModule> = new Map();
       private noteListeners: Map<string, (event: NoteEvent) => void> = new Map();
       private chordListeners: Map<string, (event: ChordEvent) => void> = new Map();

       routeNoteEvent(event: NoteEvent, targetInstanceIds: string[]): void {
         targetInstanceIds.forEach(targetId => {
           const listener = this.noteListeners.get(targetId);
           if (listener) {
             listener(event);
           } else {
             console.warn(`No listener registered for module: ${targetId}`);
           }
         });
       }
     }
     ```

7. **Module Unload Cleanup**
   - Automatically remove module from routing service when unloaded
   - Clear event listeners to prevent memory leaks
   - Update dependent modules (remove unloaded module from their output targets)

8. **Error Handling**
   - Invalid targetInstanceId â†’ Log warning, skip routing
   - Unregistered source module â†’ Log warning, allow routing (no crash)
   - Listener throws error â†’ Catch and log, continue routing to other targets
   - Example:
     ```typescript
     routeNoteEvent(event: NoteEvent, targetInstanceIds: string[]): void {
       targetInstanceIds.forEach(targetId => {
         try {
           const listener = this.noteListeners.get(targetId);
           if (listener) {
             listener(event);
           } else {
             console.warn(`No listener for module: ${targetId}`);
           }
         } catch (error) {
           console.error(`Error routing to ${targetId}:`, error);
         }
       });
     }
     ```

### Quality Requirements

9. **Performance**
   - Event routing latency: <5ms (total time from emit to all listeners called)
   - Support up to 100 events/second (typical melody sequencer load)
   - Memory: Stable (no leaks when modules load/unload repeatedly)

10. **Developer Experience**
    - JSDoc comments for all public methods
    - TypeScript strict mode compliance
    - Clear error messages (e.g., "Module 'piano-roll-1' not found in registry")

11. **User Experience**
    - OutputSelector UI intuitive (checkboxes, clear labels)
    - Real-time feedback (selected targets highlighted)
    - Graceful degradation (no output targets selected â†’ play audio locally only)

---

## Technical Notes

### Integration Approach

**ModuleRoutingService Implementation:**
```typescript
// src/services/moduleRoutingService.ts
export interface ModuleCapabilities {
  canReceiveNotes?: boolean;
  canReceiveChords?: boolean;
  canReceiveTempo?: boolean;
  canEmitNotes?: boolean;
  canEmitChords?: boolean;
}

export interface LoadedModule {
  instanceId: string;
  moduleId: string;
  name: string;
  capabilities: ModuleCapabilities;
}

export interface NoteEvent {
  type: 'note-on' | 'note-off';
  pitch: number;
  velocity: number;
  timestamp: number;
  sourceInstanceId: string;
}

export interface ChordEvent {
  type: 'chord-change';
  chordName: string;
  notes: number[];
  timestamp: number;
  sourceInstanceId: string;
}

export class ModuleRoutingService {
  private static instance: ModuleRoutingService;
  private modules: Map<string, LoadedModule> = new Map();
  private noteListeners: Map<string, (event: NoteEvent) => void> = new Map();
  private chordListeners: Map<string, (event: ChordEvent) => void> = new Map();

  private constructor() {}

  static getInstance(): ModuleRoutingService {
    if (!ModuleRoutingService.instance) {
      ModuleRoutingService.instance = new ModuleRoutingService();
    }
    return ModuleRoutingService.instance;
  }

  /**
   * Register a module when it loads
   */
  registerModule(module: LoadedModule): void {
    this.modules.set(module.instanceId, module);
    console.log(`Module registered: ${module.name} (${module.instanceId})`);
  }

  /**
   * Unregister a module when it unloads
   */
  unregisterModule(instanceId: string): void {
    this.modules.delete(instanceId);
    this.noteListeners.delete(instanceId);
    this.chordListeners.delete(instanceId);
    console.log(`Module unregistered: ${instanceId}`);
  }

  /**
   * Get all loaded modules that can receive specific event type
   */
  getAvailableTargets(
    sourceInstanceId: string,
    capability: keyof ModuleCapabilities
  ): LoadedModule[] {
    const targets: LoadedModule[] = [];

    this.modules.forEach((module, instanceId) => {
      // Don't include source module as target
      if (instanceId === sourceInstanceId) return;

      // Check if module has required capability
      if (module.capabilities[capability]) {
        targets.push(module);
      }
    });

    return targets;
  }

  /**
   * Route a note event to specific target modules
   */
  routeNoteEvent(event: NoteEvent, targetInstanceIds: string[]): void {
    targetInstanceIds.forEach(targetId => {
      try {
        const listener = this.noteListeners.get(targetId);
        if (listener) {
          listener(event);
        } else {
          console.warn(`No note listener registered for module: ${targetId}`);
        }
      } catch (error) {
        console.error(`Error routing note event to ${targetId}:`, error);
      }
    });
  }

  /**
   * Route a chord event to specific target modules
   */
  routeChordEvent(event: ChordEvent, targetInstanceIds: string[]): void {
    targetInstanceIds.forEach(targetId => {
      try {
        const listener = this.chordListeners.get(targetId);
        if (listener) {
          listener(event);
        } else {
          console.warn(`No chord listener registered for module: ${targetId}`);
        }
      } catch (error) {
        console.error(`Error routing chord event to ${targetId}:`, error);
      }
    });
  }

  /**
   * Subscribe to note events (for receiving modules)
   * @returns Unsubscribe function
   */
  subscribeToNoteEvents(
    instanceId: string,
    callback: (event: NoteEvent) => void
  ): () => void {
    this.noteListeners.set(instanceId, callback);

    // Return unsubscribe function
    return () => {
      this.noteListeners.delete(instanceId);
    };
  }

  /**
   * Subscribe to chord events (for receiving modules)
   * @returns Unsubscribe function
   */
  subscribeToChordEvents(
    instanceId: string,
    callback: (event: ChordEvent) => void
  ): () => void {
    this.chordListeners.set(instanceId, callback);

    // Return unsubscribe function
    return () => {
      this.chordListeners.delete(instanceId);
    };
  }

  /**
   * Get all registered modules (for debugging)
   */
  getRegisteredModules(): LoadedModule[] {
    return Array.from(this.modules.values());
  }
}
```

**OutputSelector Component:**
```typescript
// src/components/Studio/modules/ChordMelodyArranger/OutputSelector.tsx
import React, { useState, useEffect, useMemo } from 'react';
import { Music, ChevronDown } from 'lucide-react';
import { ModuleRoutingService } from '@/services/moduleRoutingService';

export interface OutputSelectorProps {
  sourceInstanceId: string;
  selectedTargets: string[];
  onTargetsChange: (targets: string[]) => void;
}

export const OutputSelector: React.FC<OutputSelectorProps> = ({
  sourceInstanceId,
  selectedTargets,
  onTargetsChange
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const routingService = ModuleRoutingService.getInstance();

  // Get available targets (modules that can receive notes/chords)
  const availableTargets = useMemo(() => {
    const noteTargets = routingService.getAvailableTargets(
      sourceInstanceId,
      'canReceiveNotes'
    );
    const chordTargets = routingService.getAvailableTargets(
      sourceInstanceId,
      'canReceiveChords'
    );

    // Combine and deduplicate
    const allTargets = [...noteTargets, ...chordTargets];
    return Array.from(new Map(allTargets.map(t => [t.instanceId, t])).values());
  }, [sourceInstanceId, routingService]);

  const toggleTarget = (instanceId: string) => {
    if (selectedTargets.includes(instanceId)) {
      onTargetsChange(selectedTargets.filter(id => id !== instanceId));
    } else {
      onTargetsChange([...selectedTargets, instanceId]);
    }
  };

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors"
        aria-label="Select output destinations"
      >
        <Music className="w-4 h-4" />
        <span className="text-sm">
          Output ({selectedTargets.length})
        </span>
        <ChevronDown className="w-4 h-4" />
      </button>

      {isOpen && (
        <div className="absolute top-full mt-2 right-0 bg-gray-800 border border-gray-700 rounded-lg shadow-lg p-4 min-w-64 z-10">
          <h4 className="text-sm font-semibold text-white mb-3">
            Route Output To:
          </h4>

          {availableTargets.length === 0 ? (
            <p className="text-sm text-gray-400">
              No modules loaded. Add modules to Studio to route output.
            </p>
          ) : (
            <div className="space-y-2">
              {availableTargets.map(target => (
                <label
                  key={target.instanceId}
                  className="flex items-center gap-3 p-2 hover:bg-gray-700 rounded cursor-pointer"
                >
                  <input
                    type="checkbox"
                    checked={selectedTargets.includes(target.instanceId)}
                    onChange={() => toggleTarget(target.instanceId)}
                    className="w-4 h-4"
                  />
                  <span className="text-sm text-white">{target.name}</span>
                </label>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};
```

**Module Registry Update:**
```typescript
// src/components/Studio/moduleRegistry.ts (update)
import { ModuleCapabilities } from '@/services/moduleRoutingService';

export interface ModuleDefinition {
  id: string;
  name: string;
  description: string;
  component: ComponentType<any>;
  icon: ComponentType<{ className?: string }>;
  color: string;
  category: 'instrument' | 'sequencer' | 'visualizer';
  capabilities: ModuleCapabilities; // NEW
}

// Example module registration
export const moduleRegistry: ModuleDefinition[] = [
  {
    id: 'chord-melody-arranger',
    name: 'Chord & Melody Arranger',
    description: 'Compose chord progressions and melodies',
    component: ChordMelodyArranger,
    icon: Music,
    color: 'primary',
    category: 'sequencer',
    capabilities: {
      canReceiveNotes: false,
      canReceiveChords: false,
      canEmitNotes: true,
      canEmitChords: true,
    },
  },
  {
    id: 'piano-roll',
    name: 'Piano Roll',
    description: 'Visualize MIDI notes',
    component: PianoRoll,
    icon: Piano,
    color: 'blue',
    category: 'visualizer',
    capabilities: {
      canReceiveNotes: true,
      canReceiveChords: true,
      canEmitNotes: false,
    },
  },
  // ... other modules
];
```

### Existing Pattern Reference

**Similar Service Layers:**
- `src/utils/audioEngine.ts` - Singleton Tone.js wrapper
- `src/utils/midiInputManager.ts` - Web MIDI API singleton
- `src/services/chordProgressionService.ts` - Chord data service (Story 15.1)

**Follow Same Patterns:**
- Singleton pattern with `getInstance()`
- Private constructor
- JSDoc comments for public methods
- Error handling with console warnings
- Event listener cleanup on unsubscribe

### Key Constraints

**Must Preserve:**
- Module independence (no direct imports between modules)
- Studio component lifecycle (load/unload modules)
- ModuleComponentProps interface (backward compatibility)

**Must Not:**
- Create circular dependencies (modules importing each other)
- Modify existing module components (non-breaking changes only)
- Add external dependencies (use existing TypeScript, React patterns)

**Performance Requirements:**
- Event routing latency: <5ms
- Support 100 events/second (typical sequencer load)
- Memory stable (no leaks on repeated load/unload)

---

## Definition of Done

- [ ] `src/services/moduleRoutingService.ts` created (~200 lines)
- [ ] ModuleRoutingService implements all required methods
- [ ] `src/components/Studio/modules/ChordMelodyArranger/OutputSelector.tsx` created (~150 lines)
- [ ] OutputSelector component displays available targets
- [ ] Module capability metadata added to moduleRegistry.ts
- [ ] ChordMelodyArranger integrates OutputSelector in UI
- [ ] ChordMelodyArranger emits note/chord events to selected targets
- [ ] Studio.tsx registers/unregisters modules with routing service
- [ ] Event bus pattern working (publish/subscribe)
- [ ] Module unload cleanup (listeners removed, memory leak-free)
- [ ] Error handling implemented (invalid targets, listener errors)
- [ ] Manual browser testing (localhost:5173/studio)
- [ ] Verify event routing works (ChordMelodyArranger â†’ PianoRoll or other module)
- [ ] No console errors in browser DevTools
- [ ] TypeScript compilation passes (no new errors)
- [ ] Performance verified (<5ms routing latency, stable memory)

---

## Testing Strategy

### Manual Testing (Per CLAUDE.md Guidelines)

**Test 1: Module Registration/Unregistration**
```bash
# Start dev server
npm run dev

# Navigate to Studio
http://localhost:5173/studio

# Load ChordMelodyArranger module
# Open browser DevTools Console

# Verify:
ModuleRoutingService.getInstance().getRegisteredModules()
# Should show: [{ instanceId: "chord-melody-arranger-...", ... }]

# Load PianoRoll module
ModuleRoutingService.getInstance().getRegisteredModules()
# Should show 2 modules

# Unload PianoRoll module
ModuleRoutingService.getInstance().getRegisteredModules()
# Should show 1 module (ChordMelodyArranger only)
```

**Test 2: OutputSelector UI**
```typescript
// In ChordMelodyArranger, click "Output (0)" button

// Verify:
// - Dropdown opens showing available target modules
// - If no modules loaded â†’ Empty state message displayed
// - If PianoRoll loaded â†’ Checkbox with "Piano Roll 1" label
// - Clicking checkbox toggles selection
// - "Output (1)" updates count when target selected
// - Dropdown closes on outside click
```

**Test 3: Event Routing**
```typescript
// Load ChordMelodyArranger and PianoRoll modules
// In ChordMelodyArranger:
// 1. Select a chord progression (e.g., "Jazz ii-V-I")
// 2. Add melody notes to sequencer grid
// 3. Click "Output (0)" â†’ Select "Piano Roll 1"
// 4. Click Play button

// Verify:
// - PianoRoll receives note events and displays them visually
// - Timing matches ChordMelodyArranger playback cursor
// - No console errors
// - Audio plays from ChordMelodyArranger (local) and PianoRoll (received)
```

**Test 4: Multi-Target Routing**
```typescript
// Load 3 modules: ChordMelodyArranger, PianoRoll, DrumMachine (if exists)
// In ChordMelodyArranger:
// - Select both PianoRoll and DrumMachine as output targets
// - Play melody

// Verify:
// - Both PianoRoll and DrumMachine receive events
// - No duplicate events
// - No dropped events
// - Performance stable (60fps, no lag)
```

**Test 5: Error Handling**
```typescript
// Manually trigger error scenarios in DevTools Console:

// 1. Route to invalid target
const routingService = ModuleRoutingService.getInstance();
routingService.routeNoteEvent(
  { type: 'note-on', pitch: 60, velocity: 100, timestamp: performance.now(), sourceInstanceId: 'test' },
  ['invalid-module-id']
);
// Verify: Console warning logged, no crash

// 2. Unload module while routing active
// Load ChordMelodyArranger â†’ Select PianoRoll as target â†’ Play
// While playing, unload PianoRoll
// Verify: Console warning logged, playback continues without crash
```

**Test 6: Performance & Memory**
```javascript
// Browser DevTools â†’ Performance tab
// Record 30 seconds of playback with event routing active

// Verify:
// - Event routing latency: <5ms (check flame graph)
// - CPU usage: <40% (event handling overhead)
// - Memory: Stable (no leaks)
// - 60fps maintained during playback

// Memory leak test:
// Load/unload modules 10 times
// Check DevTools Memory tab â†’ Heap snapshot
// Verify: Module instances are garbage collected
```

### Verification Checklist

- âœ… ModuleRoutingService singleton instantiates correctly
- âœ… Module registration/unregistration works
- âœ… getAvailableTargets() filters by capability
- âœ… Event routing delivers events to all selected targets
- âœ… OutputSelector UI displays available modules
- âœ… Multi-target routing works (broadcast to multiple modules)
- âœ… Module unload cleanup (listeners removed)
- âœ… Error handling graceful (invalid targets, listener errors)
- âœ… Performance meets requirements (<5ms latency, 100 events/sec)
- âœ… No memory leaks (repeated load/unload)
- âœ… TypeScript compilation clean
- âœ… No console errors

---

## Risk and Compatibility Check

### Minimal Risk Assessment

**Primary Risk:** Event listener memory leaks (modules not unregistering)
**Mitigation:**
- Implement cleanup in Studio.tsx unloadModule()
- Test repeated load/unload cycles (10+ times)
- Use DevTools Memory profiler to detect leaks
- Return unsubscribe function from subscribeToXEvents() methods
**Rollback:** Remove ModuleRoutingService, revert to direct audio playback only

**Secondary Risk:** Event routing latency exceeds 5ms (too slow for real-time audio)
**Mitigation:**
- Profile with Performance tab (flame graph)
- Optimize Map lookups (O(1) complexity)
- Avoid synchronous operations in listeners
- Batch events if necessary (queue â†’ flush at 60fps)
**Rollback:** Reduce max targets from unlimited to 3 targets max

**Tertiary Risk:** Module coupling via routing service (indirect dependency)
**Mitigation:**
- Document event interfaces clearly (NoteEvent, ChordEvent)
- Use TypeScript strict mode (compile-time type checking)
- Version event interfaces (e.g., NoteEventV1, future NoteEventV2)
- Maintain backward compatibility for event structure
**Rollback:** Revert to single-module playback (no routing)

### Compatibility Verification

- [x] **No breaking changes** - Existing modules work without routing (graceful degradation)
- [x] **No database changes** - Client-side state only
- [x] **UI changes additive** - Adds OutputSelector to ChordMelodyArranger
- [x] **Performance impact** - <5ms latency requirement, test on low-end devices

---

## Scope Validation

- [x] Story can be completed in **6-8 hours** (one development session)
- [x] Integration approach follows existing patterns (singleton service, event bus)
- [x] Clear prerequisites (Story 15.3 complete)
- [x] No external dependencies required

---

## Deliverables

1. **ModuleRoutingService**
   - `src/services/moduleRoutingService.ts` (~200 lines)
   - Singleton class with register/route/subscribe methods

2. **OutputSelector Component**
   - `src/components/Studio/modules/ChordMelodyArranger/OutputSelector.tsx` (~150 lines)
   - Dropdown UI for selecting output destinations

3. **Module Registry Update**
   - `src/components/Studio/moduleRegistry.ts` (~20 lines changed)
   - Add capabilities metadata to all modules

4. **Studio Lifecycle Integration**
   - `src/components/Studio/Studio.tsx` (~40 lines changed)
   - Register/unregister modules with routing service

5. **ChordMelodyArranger Integration**
   - `src/components/Studio/modules/ChordMelodyArranger/ChordMelodyArranger.tsx` (~60 lines changed)
   - Add OutputSelector, emit note/chord events

---

## Next Steps After Story 15.4

Once this story is complete, proceed to:
- **Story 15.5:** GlobalMusicContext Integration (3-4 hours)
  - Key/scale/tempo synchronization
  - Transport state integration
  - Auto-transpose on key changes

---

## References

- **Epic 15:** `docs/epics/epic-15-chord-melody-arranger.md`
- **Story 15.3:** `docs/stories/15.3-melody-arranger-component.md`
- **Module Registry:** `src/components/Studio/moduleRegistry.ts`
- **Studio Component:** `src/components/Studio/Studio.tsx`
- **Service Pattern Example:** `src/utils/audioEngine.ts`

---

**Story Created:** 2025-01-13
**Story Owner:** PO Agent (Sarah)
**Estimated Completion:** 6-8 hours after start

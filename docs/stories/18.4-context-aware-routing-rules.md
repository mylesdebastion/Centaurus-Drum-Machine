# Story 18.4: Context-Aware Routing Rules Engine

**Epic:** Epic 18 - Intelligent WLED Visualization Routing
**Status:** ðŸ“ PLANNING
**Priority:** ðŸŸ¡ MEDIUM
**Complexity:** Medium
**Time Estimate:** 4-5 hours
**Prerequisites:** Story 18.3 (Visualization Routing Matrix)

---

## User Story

As a **user switching between different musical modules**,
I want **the LED routing to automatically adapt based on what I'm doing**,
So that **each module gets the most appropriate LED devices without manual configuration**.

---

## Story Context

### Why This Story

**Context-Aware Intelligence:** Story 18.4 adds rule-based logic to the routing matrix, enabling context-aware behaviors that make the system feel "smart" and responsive to user intent.

**Current State:**
- âœ… Routing matrix matches modules to devices (Story 18.3)
- âœ… Compatibility scoring and priority system working
- âŒ No context-aware rules (e.g., "Guitar gets grid exclusively")
- âŒ No smart fallbacks (e.g., "Piano Roll on 1D strip if no grid available")
- âŒ No exclusive vs overlay detection (e.g., "Drum Machine doesn't overlay on Guitar")

**Desired State (Story 18.4):**
- âœ… `RoutingRule` interface defines pluggable rule system
- âœ… Built-in rules for common scenarios
- âœ… Rule evaluation engine with priority ordering
- âœ… Rules can override default routing decisions
- âœ… Extensible (add new rules without refactoring)

**Example Rule Behavior:**

```typescript
// Rule 1: Active Module Priority
// Scenario: DrumMachine active, Guitar registered but inactive
// Result: DrumMachine gets best device (active module bonus)

// Rule 2: Guitar Grid Exclusive
// Scenario: Guitar active + 6x25 grid available
// Result: Guitar gets grid exclusively (no overlays from other modules)

// Rule 3: Drum Machine Grid Takeover
// Scenario: DrumMachine active + same 6x25 grid
// Result: Grid shows step-sequencer-grid (6 tracks Ã— 25 steps)

// Rule 4: Audio Reactive Overlay
// Scenario: AudioReactive enabled + any modules active
// Result: Audio reactive overlays on ALL devices (additive)

// Rule 5: Piano Roll 1D Fallback
// Scenario: PianoRoll active + no grid, but 88-LED strip available
// Result: Strip shows piano-keys (1D fallback)
```

---

## Acceptance Criteria

### Functional Requirements

1. **RoutingRule Interface**
   - Create `src/types/routing-rules.ts`:
     ```typescript
     interface RoutingRule {
       name: string;
       description: string;
       priority: number; // Higher = evaluated first

       // Check if rule applies
       condition: (context: RoutingContext) => boolean;

       // Modify routing assignments
       action: (
         context: RoutingContext,
         currentAssignments: DeviceAssignment[]
       ) => DeviceAssignment[];
     }

     interface RoutingContext {
       activeModule: ModuleId | null;
       registeredModules: Map<ModuleId, ModuleVisualizationCapability>;
       availableDevices: WLEDDevice[];
       currentAssignments: DeviceAssignment[];
     }
     ```

2. **Built-In Routing Rules**
   - Create rule implementations in `src/services/routing-rules/`:
     - `ActiveModulePriorityRule.ts` - Active module gets best device
     - `GuitarGridExclusiveRule.ts` - Guitar fretboard gets grid exclusively
     - `DrumMachineGridTakeoverRule.ts` - Drum machine uses grid for step sequencer
     - `AudioReactiveOverlayRule.ts` - Audio reactive overlays on all devices
     - `PianoRoll1DFallbackRule.ts` - Piano roll uses 1D strip if no grid
     - `GenericFallbackRule.ts` - Fallback to generic-color-array (lowest priority)

3. **Rule Evaluation Engine**
   - Extend `VisualizationRoutingMatrix` with rule evaluation:
     ```typescript
     class VisualizationRoutingMatrix {
       private rules: RoutingRule[] = [];

       // Register rule
       registerRule(rule: RoutingRule): void;

       // Unregister rule
       unregisterRule(ruleName: string): void;

       // Evaluate all rules and apply modifications
       private applyRules(
         context: RoutingContext,
         assignments: DeviceAssignment[]
       ): DeviceAssignment[];
     }
     ```

4. **Rule Priority System**
   - Rules evaluated in priority order (highest first)
   - Rules can:
     - Modify existing assignments
     - Add new assignments
     - Remove assignments
     - Override compatibility scores
   - Later rules can override earlier rules

5. **Default Rule Set**
   - Auto-register built-in rules on initialization:
     ```typescript
     // Default priority order:
     // 1. ActiveModulePriorityRule (priority: 100)
     // 2. GuitarGridExclusiveRule (priority: 90)
     // 3. DrumMachineGridTakeoverRule (priority: 90)
     // 4. AudioReactiveOverlayRule (priority: 50)
     // 5. PianoRoll1DFallbackRule (priority: 40)
     // 6. GenericFallbackRule (priority: 10)
     ```

6. **Rule Context Access**
   - Rules have read-only access to:
     - Active module ID
     - All registered module capabilities
     - All available devices
     - Current routing assignments
   - Rules return modified assignments (immutable)

### Integration Requirements

7. **Routing Matrix Integration**
   - Rules applied after base routing algorithm
   - Rule modifications merged with compatibility scores
   - Final assignments validated (no null devices/modules)

8. **Debug Support**
   - `debugPrintRules()` - Shows all registered rules
   - `debugPrintRuleEvaluation()` - Shows which rules fired
   - Console logging for rule condition checks
   - Rule execution time tracking

9. **Error Handling**
   - Invalid rule throws error on registration
   - Rule evaluation errors logged but don't crash routing
   - Failed rule skipped, next rule evaluated
   - Fallback to base routing if all rules fail

### Quality Requirements

10. **Type Safety**
    - All rules type-checked at compile time
    - Invalid RoutingContext caught by TypeScript
    - No runtime type errors in rule evaluation

11. **Performance**
    - Rule evaluation adds <5ms to routing time
    - Short-circuit evaluation (condition false = skip action)
    - No unnecessary array cloning

12. **Testability**
    - Unit tests for each built-in rule
    - Integration tests for multi-rule scenarios
    - Mock RoutingContext for testing

---

## Technical Approach

### Phase 1: Rule Interface and Engine (1 hour)

**Create Rule Types:**
```typescript
// src/types/routing-rules.ts
import {
  ModuleId,
  ModuleVisualizationCapability,
  DeviceAssignment,
} from './visualization';
import { WLEDDevice } from './wled';

/**
 * Context available to routing rules
 */
export interface RoutingContext {
  /** Currently active module (user-facing) */
  activeModule: ModuleId | null;

  /** All registered modules */
  registeredModules: Map<ModuleId, ModuleVisualizationCapability>;

  /** All available devices (enabled only) */
  availableDevices: WLEDDevice[];

  /** Current routing assignments (before rule modifications) */
  currentAssignments: DeviceAssignment[];
}

/**
 * Pluggable routing rule
 */
export interface RoutingRule {
  /** Unique rule name */
  name: string;

  /** Human-readable description */
  description: string;

  /** Priority (higher = evaluated first) */
  priority: number;

  /**
   * Check if rule should be applied
   * Return true to execute action, false to skip
   */
  condition: (context: RoutingContext) => boolean;

  /**
   * Modify routing assignments
   * Return new assignments (immutable - don't mutate input)
   */
  action: (
    context: RoutingContext,
    currentAssignments: DeviceAssignment[]
  ) => DeviceAssignment[];
}
```

**Extend Routing Matrix:**
```typescript
// src/services/VisualizationRoutingMatrix.ts (extend existing)
import { RoutingRule, RoutingContext } from '@/types/routing-rules';

export class VisualizationRoutingMatrix {
  // ... existing fields ...
  private rules: RoutingRule[] = [];

  constructor(/* ... */) {
    // ... existing constructor code ...

    // Register default rules
    this.registerDefaultRules();
  }

  /**
   * Register a routing rule
   */
  registerRule(rule: RoutingRule): void {
    // Validate rule
    if (!rule.name || !rule.condition || !rule.action) {
      throw new Error('Invalid routing rule: missing required fields');
    }

    // Check for duplicate rule name
    const existingIndex = this.rules.findIndex((r) => r.name === rule.name);
    if (existingIndex !== -1) {
      console.warn(
        `[RoutingMatrix] Rule ${rule.name} already registered. Replacing...`
      );
      this.rules.splice(existingIndex, 1);
    }

    // Add rule and sort by priority
    this.rules.push(rule);
    this.rules.sort((a, b) => b.priority - a.priority);

    console.log(
      `[RoutingMatrix] Rule registered: ${rule.name} (priority: ${rule.priority})`
    );
  }

  /**
   * Unregister a routing rule
   */
  unregisterRule(ruleName: string): void {
    const initialLength = this.rules.length;
    this.rules = this.rules.filter((r) => r.name !== ruleName);

    if (this.rules.length < initialLength) {
      console.log(`[RoutingMatrix] Rule unregistered: ${ruleName}`);
    } else {
      console.warn(
        `[RoutingMatrix] Attempted to unregister unknown rule: ${ruleName}`
      );
    }
  }

  /**
   * Apply all registered rules to routing assignments
   */
  private applyRules(
    context: RoutingContext,
    assignments: DeviceAssignment[]
  ): DeviceAssignment[] {
    let modifiedAssignments = assignments;

    for (const rule of this.rules) {
      try {
        // Check condition
        const conditionMet = rule.condition(context);

        if (!conditionMet) {
          console.log(`[RoutingMatrix] Rule skipped (condition false): ${rule.name}`);
          continue;
        }

        // Execute action
        console.log(`[RoutingMatrix] Applying rule: ${rule.name}`);
        const startTime = performance.now();

        modifiedAssignments = rule.action(context, modifiedAssignments);

        const duration = performance.now() - startTime;
        console.log(`[RoutingMatrix] Rule applied in ${duration.toFixed(2)}ms`);
      } catch (error) {
        console.error(
          `[RoutingMatrix] Rule evaluation failed: ${rule.name}`,
          error
        );
        // Continue with next rule
      }
    }

    return modifiedAssignments;
  }

  /**
   * Main routing algorithm (modified to apply rules)
   */
  async routeVisualizations(): Promise<DeviceAssignment[]> {
    // ... existing routing logic (compatibility scoring, assignment, overlays) ...

    // NEW: Apply routing rules
    const context: RoutingContext = {
      activeModule: this.activeModule,
      registeredModules: new Map(this.ledCompositor.getAllModuleCapabilities().map(c => [c.moduleId, c])),
      availableDevices: devices.filter((d) => d.enabled),
      currentAssignments: assignmentsWithOverlays,
    };

    const finalAssignments = this.applyRules(context, assignmentsWithOverlays);

    return finalAssignments;
  }

  /**
   * Debug: Print all registered rules
   */
  debugPrintRules(): void {
    console.log('[RoutingMatrix] Registered Rules:');
    console.log('='.repeat(80));

    if (this.rules.length === 0) {
      console.log('  No rules registered');
      return;
    }

    this.rules.forEach((rule, index) => {
      console.log(`\n  ${index + 1}. ${rule.name} (priority: ${rule.priority})`);
      console.log(`     ${rule.description}`);
    });

    console.log('\n' + '='.repeat(80));
  }

  /**
   * Register default built-in rules
   */
  private registerDefaultRules(): void {
    // Import and register built-in rules
    // (Implementation in Phase 2)
  }
}
```

### Phase 2: Built-In Rules Implementation (2.5 hours)

**Rule 1: Active Module Priority Rule**
```typescript
// src/services/routing-rules/ActiveModulePriorityRule.ts
import { RoutingRule } from '@/types/routing-rules';

export const ActiveModulePriorityRule: RoutingRule = {
  name: 'ActiveModulePriority',
  description: 'Active module gets highest-priority device assignment',
  priority: 100,

  condition: (context) => {
    return context.activeModule !== null;
  },

  action: (context, currentAssignments) => {
    if (!context.activeModule) return currentAssignments;

    // Find assignment for active module
    const activeAssignment = currentAssignments.find(
      (a) => a.primary.moduleId === context.activeModule
    );

    if (!activeAssignment) {
      // Active module not assigned - this is handled by compatibility scoring
      // No modification needed
      return currentAssignments;
    }

    // Active module already assigned - ensure it has highest priority
    // (This is already handled by compatibility scoring's active module bonus)
    return currentAssignments;
  },
};
```

**Rule 2: Guitar Grid Exclusive Rule**
```typescript
// src/services/routing-rules/GuitarGridExclusiveRule.ts
export const GuitarGridExclusiveRule: RoutingRule = {
  name: 'GuitarGridExclusive',
  description: 'Guitar fretboard gets 2D grid exclusively (no overlays from other modules)',
  priority: 90,

  condition: (context) => {
    // Rule applies if:
    // 1. Guitar module is active
    // 2. At least one 2D grid device available
    const guitarActive = context.activeModule === 'guitar-fretboard';
    const has2DGrid = context.availableDevices.some(
      (d) => d.capabilities.dimensions === '2D'
    );

    return guitarActive && has2DGrid;
  },

  action: (context, currentAssignments) => {
    // Find assignment for guitar module on 2D grid
    const guitarAssignment = currentAssignments.find(
      (a) =>
        a.primary.moduleId === 'guitar-fretboard' &&
        a.device.capabilities.dimensions === '2D'
    );

    if (!guitarAssignment) return currentAssignments;

    // Remove overlays from guitar's grid device
    return currentAssignments.map((assignment) => {
      if (assignment.device.id === guitarAssignment.device.id) {
        return {
          ...assignment,
          overlays: [], // Clear overlays (exclusive mode)
        };
      }
      return assignment;
    });
  },
};
```

**Rule 3: Drum Machine Grid Takeover Rule**
```typescript
// src/services/routing-rules/DrumMachineGridTakeoverRule.ts
export const DrumMachineGridTakeoverRule: RoutingRule = {
  name: 'DrumMachineGridTakeover',
  description: 'Drum machine uses 2D grid for multi-track step sequencer',
  priority: 90,

  condition: (context) => {
    const drumMachineActive = context.activeModule === 'drum-machine';
    const has2DGrid = context.availableDevices.some(
      (d) => d.capabilities.dimensions === '2D'
    );

    return drumMachineActive && has2DGrid;
  },

  action: (context, currentAssignments) => {
    // Find assignment for drum machine on 2D grid
    const drumAssignment = currentAssignments.find(
      (a) =>
        a.primary.moduleId === 'drum-machine' &&
        a.device.capabilities.dimensions === '2D'
    );

    if (!drumAssignment) return currentAssignments;

    // Ensure drum machine uses step-sequencer-grid visualization
    return currentAssignments.map((assignment) => {
      if (assignment.device.id === drumAssignment.device.id) {
        return {
          ...assignment,
          primary: {
            ...assignment.primary,
            visualizationType: 'step-sequencer-grid',
          },
        };
      }
      return assignment;
    });
  },
};
```

**Rule 4: Audio Reactive Overlay Rule**
```typescript
// src/services/routing-rules/AudioReactiveOverlayRule.ts
export const AudioReactiveOverlayRule: RoutingRule = {
  name: 'AudioReactiveOverlay',
  description: 'Audio reactive always overlays on all devices',
  priority: 50,

  condition: (context) => {
    // Check if audio reactive module is registered
    return context.registeredModules.has('audio-reactive');
  },

  action: (context, currentAssignments) => {
    const audioReactiveCap = context.registeredModules.get('audio-reactive');
    if (!audioReactiveCap) return currentAssignments;

    // Add audio reactive overlay to all assignments
    return currentAssignments.map((assignment) => {
      // Skip if audio reactive is already primary or overlay
      const alreadyHasAudioReactive =
        assignment.primary.moduleId === 'audio-reactive' ||
        assignment.overlays.some((o) => o.moduleId === 'audio-reactive');

      if (alreadyHasAudioReactive) return assignment;

      // Find best overlay producer for this device
      const overlayProducers = audioReactiveCap.produces.filter(
        (p) => p.overlayCompatible
      );

      const compatibleProducer = overlayProducers.find((producer) => {
        const dimMatch =
          producer.dimensionPreference === assignment.device.capabilities.dimensions ||
          producer.dimensionPreference === 'either';
        return dimMatch;
      });

      if (!compatibleProducer) return assignment;

      // Add overlay
      return {
        ...assignment,
        overlays: [
          ...assignment.overlays,
          {
            moduleId: 'audio-reactive',
            visualizationType: compatibleProducer.type,
            producer: compatibleProducer,
          },
        ],
      };
    });
  },
};
```

**Rule 5: Piano Roll 1D Fallback Rule**
```typescript
// src/services/routing-rules/PianoRoll1DFallbackRule.ts
export const PianoRoll1DFallbackRule: RoutingRule = {
  name: 'PianoRoll1DFallback',
  description: 'Piano roll uses 1D strip for piano-keys visualization if no 2D grid available',
  priority: 40,

  condition: (context) => {
    const pianoRollActive = context.activeModule === 'piano-roll';
    const has1DStrip = context.availableDevices.some(
      (d) => d.capabilities.dimensions === '1D'
    );
    const no2DGrid = !context.availableDevices.some(
      (d) => d.capabilities.dimensions === '2D'
    );

    return pianoRollActive && has1DStrip && no2DGrid;
  },

  action: (context, currentAssignments) => {
    // Find piano roll assignment on 1D strip
    const pianoAssignment = currentAssignments.find(
      (a) =>
        a.primary.moduleId === 'piano-roll' &&
        a.device.capabilities.dimensions === '1D'
    );

    if (!pianoAssignment) return currentAssignments;

    // Ensure piano-keys visualization is used
    return currentAssignments.map((assignment) => {
      if (assignment.device.id === pianoAssignment.device.id) {
        return {
          ...assignment,
          primary: {
            ...assignment.primary,
            visualizationType: 'piano-keys',
          },
        };
      }
      return assignment;
    });
  },
};
```

**Rule 6: Generic Fallback Rule**
```typescript
// src/services/routing-rules/GenericFallbackRule.ts
export const GenericFallbackRule: RoutingRule = {
  name: 'GenericFallback',
  description: 'Fallback to generic color array if no compatible visualization found',
  priority: 10, // Lowest priority (last resort)

  condition: (context) => {
    // Always applies (fallback rule)
    return true;
  },

  action: (context, currentAssignments) => {
    // Check if any device has no assignment
    const assignedDeviceIds = new Set(
      currentAssignments.map((a) => a.device.id)
    );

    const unassignedDevices = context.availableDevices.filter(
      (d) => !assignedDeviceIds.has(d.id)
    );

    if (unassignedDevices.length === 0) return currentAssignments;

    // Assign generic fallback to unassigned devices
    const fallbackAssignments: DeviceAssignment[] = unassignedDevices.map(
      (device) => ({
        device,
        primary: {
          moduleId: 'drum-machine', // Default to drum machine (or active module)
          visualizationType: 'generic-color-array',
          producer: {
            type: 'generic-color-array',
            dimensionPreference: 'either',
            overlayCompatible: false,
            priority: 1,
          },
          compatibilityScore: 1,
        },
        overlays: [],
        totalPriority: 1,
      })
    );

    return [...currentAssignments, ...fallbackAssignments];
  },
};
```

**Register Default Rules:**
```typescript
// src/services/VisualizationRoutingMatrix.ts
import { ActiveModulePriorityRule } from './routing-rules/ActiveModulePriorityRule';
import { GuitarGridExclusiveRule } from './routing-rules/GuitarGridExclusiveRule';
import { DrumMachineGridTakeoverRule } from './routing-rules/DrumMachineGridTakeoverRule';
import { AudioReactiveOverlayRule } from './routing-rules/AudioReactiveOverlayRule';
import { PianoRoll1DFallbackRule } from './routing-rules/PianoRoll1DFallbackRule';
import { GenericFallbackRule } from './routing-rules/GenericFallbackRule';

private registerDefaultRules(): void {
  this.registerRule(ActiveModulePriorityRule);
  this.registerRule(GuitarGridExclusiveRule);
  this.registerRule(DrumMachineGridTakeoverRule);
  this.registerRule(AudioReactiveOverlayRule);
  this.registerRule(PianoRoll1DFallbackRule);
  this.registerRule(GenericFallbackRule);

  console.log('[RoutingMatrix] Default rules registered');
  this.debugPrintRules();
}
```

### Phase 3: Testing and Integration (1.5 hours)

**Barrel Export:**
```typescript
// src/services/routing-rules/index.ts
export { ActiveModulePriorityRule } from './ActiveModulePriorityRule';
export { GuitarGridExclusiveRule } from './GuitarGridExclusiveRule';
export { DrumMachineGridTakeoverRule } from './DrumMachineGridTakeoverRule';
export { AudioReactiveOverlayRule } from './AudioReactiveOverlayRule';
export { PianoRoll1DFallbackRule } from './PianoRoll1DFallbackRule';
export { GenericFallbackRule } from './GenericFallbackRule';
```

---

## Dependencies

### Prerequisites
- âœ… **Story 18.3 Complete:** Visualization Routing Matrix (base routing algorithm)
- âœ… **Story 18.2 Complete:** Module Capability Declaration (capability introspection)
- âœ… **Story 18.1 Complete:** WLED Device Registry (device queries)

### Blocks These Stories
- â³ **Story 18.5:** WLED Manager UI (can display active rules)
- â³ **Story 18.6:** LEDCompositor Integration (uses final routing assignments)

---

## Integration Points

- `src/services/VisualizationRoutingMatrix.ts` - EXTEND: Add rule evaluation
- `src/types/routing-rules.ts` - NEW: Rule interfaces
- `src/services/routing-rules/` - NEW: Built-in rule implementations
- `src/contexts/GlobalMusicContext.tsx` - Uses final routing assignments

---

## Testing Strategy

### Manual Verification Steps

**Test 1: Active Module Priority Rule**
```typescript
// Setup
ledCompositor.registerModule(drumMachineCapability);
ledCompositor.registerModule(pianoRollCapability);
await wledDeviceRegistry.createDevice(gridDevice2D);

// Initially no active module
routingMatrix.setActiveModule(null);
let assignments = await routingMatrix.routeVisualizations();
console.log('No active module:', assignments[0].primary.moduleId);

// Set piano roll as active
routingMatrix.setActiveModule('piano-roll');
assignments = await routingMatrix.routeVisualizations();
console.log('Piano roll active:', assignments[0].primary.moduleId);
// Expected: 'piano-roll' (active module bonus)
```

**Test 2: Guitar Grid Exclusive Rule**
```typescript
// Setup
ledCompositor.registerModule(guitarFretboardCapability);
ledCompositor.registerModule(audioReactiveCapability);
await wledDeviceRegistry.createDevice(gridDevice2D);
routingMatrix.setActiveModule('guitar-fretboard');

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: Guitar on grid, no overlays
const guitarAssignment = assignments.find(
  (a) => a.primary.moduleId === 'guitar-fretboard'
);
console.log('Guitar overlays:', guitarAssignment?.overlays.length);
// Expected: 0 (exclusive mode, audio reactive not overlaid)
```

**Test 3: Drum Machine Grid Takeover Rule**
```typescript
// Setup
ledCompositor.registerModule(drumMachineCapability);
await wledDeviceRegistry.createDevice(gridDevice2D);
routingMatrix.setActiveModule('drum-machine');

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: Drum machine uses step-sequencer-grid
const drumAssignment = assignments.find(
  (a) => a.primary.moduleId === 'drum-machine'
);
console.log('Drum visualization:', drumAssignment?.primary.visualizationType);
// Expected: 'step-sequencer-grid'
```

**Test 4: Audio Reactive Overlay Rule**
```typescript
// Setup
ledCompositor.registerModule(drumMachineCapability);
ledCompositor.registerModule(audioReactiveCapability);
await wledDeviceRegistry.createDevice(gridDevice2D);
await wledDeviceRegistry.createDevice(stripDevice1D);

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: All devices have audio reactive overlay
assignments.forEach((assignment) => {
  const hasAudioOverlay = assignment.overlays.some(
    (o) => o.moduleId === 'audio-reactive'
  );
  console.log(
    `Device ${assignment.device.name} has audio overlay:`,
    hasAudioOverlay
  );
  // Expected: true for all devices
});
```

**Test 5: Piano Roll 1D Fallback Rule**
```typescript
// Setup: Piano Roll active, only 1D strip available (no grid)
ledCompositor.registerModule(pianoRollCapability);
await wledDeviceRegistry.createDevice(stripDevice1D); // 88 LEDs
routingMatrix.setActiveModule('piano-roll');

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: Piano roll uses piano-keys on 1D strip
const pianoAssignment = assignments.find(
  (a) => a.primary.moduleId === 'piano-roll'
);
console.log('Piano visualization:', pianoAssignment?.primary.visualizationType);
console.log('Device dimension:', pianoAssignment?.device.capabilities.dimensions);
// Expected: 'piano-keys', '1D'
```

**Test 6: Generic Fallback Rule**
```typescript
// Setup: Device with no compatible module
const uncommonDevice: WLEDDevice = {
  id: '999',
  name: 'Uncommon Device',
  ip: '192.168.1.200',
  capabilities: {
    dimensions: '1D',
    ledCount: 10,
    supportedVisualizations: [],
  },
  // ... other fields
};

await wledDeviceRegistry.createDevice(uncommonDevice);

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: Device gets generic fallback
const fallbackAssignment = assignments.find(
  (a) => a.device.id === '999'
);
console.log('Fallback visualization:', fallbackAssignment?.primary.visualizationType);
// Expected: 'generic-color-array'
```

**Test 7: Rule Priority Order**
```typescript
// Setup: Multiple rules applicable
ledCompositor.registerModule(guitarFretboardCapability);
ledCompositor.registerModule(audioReactiveCapability);
await wledDeviceRegistry.createDevice(gridDevice2D);
routingMatrix.setActiveModule('guitar-fretboard');

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: GuitarGridExclusive wins over AudioReactiveOverlay
// (priority 90 vs 50)
const guitarAssignment = assignments.find(
  (a) => a.primary.moduleId === 'guitar-fretboard'
);
console.log('Guitar has overlays:', guitarAssignment?.overlays.length > 0);
// Expected: false (GuitarGridExclusive rule removed overlays)
```

---

## Risks and Mitigation

### Risk 1: Rule Conflicts (Two Rules Modify Same Assignment)
**Impact:** MEDIUM (unpredictable behavior)
**Mitigation:**
- Clear rule priority system (evaluated in order)
- Later rules can override earlier rules (documented)
- Unit tests for conflicting rule scenarios
- Debug logging shows rule execution order

### Risk 2: Rule Performance Overhead
**Impact:** LOW (rule evaluation adds latency)
**Mitigation:**
- Short-circuit evaluation (condition false = skip action)
- Profile rule execution time (<5ms target)
- Limit number of registered rules (<20)
- Cache rule results if possible

### Risk 3: Complex Rule Logic Bugs
**Impact:** MEDIUM (wrong routing decisions)
**Mitigation:**
- Comprehensive unit tests for each rule
- Integration tests for multi-rule scenarios
- Manual verification with real hardware
- Debug mode shows rule evaluation trace

### Risk 4: Breaking Changes When Adding New Rules
**Impact:** LOW (extensibility concern)
**Mitigation:**
- Rules are pluggable (add without refactoring)
- Default rules can be unregistered if needed
- Custom user rules supported in future (Story 18.5 UI)

---

## Definition of Done

- [ ] `RoutingRule` interface created
- [ ] `RoutingContext` interface created
- [ ] Rule evaluation engine implemented in RoutingMatrix
- [ ] 6 built-in rules implemented and tested
- [ ] Rules registered by default on initialization
- [ ] Rule priority system working
- [ ] `registerRule` / `unregisterRule` API working
- [ ] `debugPrintRules()` implemented
- [ ] Rule execution time tracking
- [ ] Unit tests for each built-in rule (6 tests)
- [ ] Integration tests for multi-rule scenarios (7 tests)
- [ ] Error handling tested (invalid rules, failed conditions)
- [ ] Performance target met (<5ms rule evaluation overhead)
- [ ] Documentation updated (architecture doc, rule guide)

---

## Deliverables

1. **Rule Types**
   - `src/types/routing-rules.ts` (~60 lines)

2. **Rule Implementations**
   - `src/services/routing-rules/ActiveModulePriorityRule.ts` (~30 lines)
   - `src/services/routing-rules/GuitarGridExclusiveRule.ts` (~50 lines)
   - `src/services/routing-rules/DrumMachineGridTakeoverRule.ts` (~50 lines)
   - `src/services/routing-rules/AudioReactiveOverlayRule.ts` (~70 lines)
   - `src/services/routing-rules/PianoRoll1DFallbackRule.ts` (~50 lines)
   - `src/services/routing-rules/GenericFallbackRule.ts` (~60 lines)
   - `src/services/routing-rules/index.ts` (~10 lines)

3. **Routing Matrix Extension**
   - Modified: `src/services/VisualizationRoutingMatrix.ts` (+150 lines)

4. **Unit Tests**
   - `src/services/__tests__/routing-rules.test.ts` (~400 lines)

5. **Documentation**
   - Updated: `docs/architecture/wled-visualization-routing.md` (Layer 4: Rules Engine)
   - New: `docs/guides/custom-routing-rules.md` (how to create custom rules)

---

## Next Steps After Story 18.4

Once this story is complete, proceed to:
- **Story 18.5:** WLED Manager UI (Unified Component) - 4-5 hours
  - Now unblocked: Can display active rules and routing status
  - Unified CRUD interface for device management

---

## References

- **Epic 18:** `docs/epics/epic-18-intelligent-wled-routing.md`
- **Architecture:** `docs/architecture/wled-visualization-routing.md` (Layer 4: Routing Rules Engine)
- **Story 18.3:** Visualization Routing Matrix

---

**Story Created:** 2025-10-18
**Story Owner:** Dev Agent
**Estimated Completion:** 4-5 hours after start

---

## Notes

### Design Decisions

**Why Pluggable Rule System?**
- Extensible (add new rules without refactoring)
- Testable (test rules in isolation)
- Debuggable (inspect which rules fired)
- User-customizable (future: UI for custom rules)

**Why Priority-Based Evaluation?**
- Deterministic (predictable rule execution order)
- Conflict resolution (higher priority wins)
- Transparent (debug mode shows priority order)

**Why Immutable Rule Actions?**
- Functional programming pattern (no side effects)
- Safe (rules can't corrupt routing state)
- Debuggable (compare before/after assignments)

**Why Condition + Action Pattern?**
- Performance (skip action if condition false)
- Readable (separate "when" from "what")
- Composable (multiple conditions via AND/OR logic)

### Future Enhancements

- User-defined custom rules (via WLED Manager UI)
- Rule templates library (import community rules)
- Rule analytics (track which rules fire most often)
- AI-generated rules based on user behavior
- Visual rule builder (drag-and-drop UI)

---

## Dev Agent Record

*To be completed during implementation*

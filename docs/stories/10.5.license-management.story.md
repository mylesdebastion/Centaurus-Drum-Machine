# Story 10.2: Pro Tier Feature Gating & License Management

## Status
Draft

## Story
**As a** business stakeholder,
**I want** secure Pro tier license validation that gates access to premium controllers,
**so that** revenue-generating features are properly protected while maintaining good UX.

## Acceptance Criteria
1. Create `src/services/LicenseManager.ts` for Pro tier validation
2. Implement local license storage with encryption and expiry checks
3. Build license validation flow (online check + offline grace period)
4. Create "Upgrade to Pro" UI flows when Pro controllers detected
5. Design graceful degradation when license expires (warning period, then disable)
6. Implement analytics tracking for controller usage and upgrade prompts

## Integration Verification
- **IV1**: License checks do not block critical path or cause latency in audio/MIDI operations
- **IV2**: Offline mode allows 7-day grace period for Pro features before requiring reconnection
- **IV3**: Users cannot bypass license gates through localStorage manipulation or browser tools

## Tasks / Subtasks

- [ ] **Task 1: Create License Manager Service** (AC: 1)
  - [ ] Create `src/services/LicenseManager.ts` singleton class
  - [ ] Define `License` TypeScript interface (tier, expiresAt, userId, token)
  - [ ] Implement `getLicense(): License | null` method
  - [ ] Implement `setLicense(license: License): Promise<void>` method
  - [ ] Implement `clearLicense(): void` method for logout
  - [ ] Add license state change event emitter for UI reactivity

- [ ] **Task 2: Implement Secure Local Storage** (AC: 2, 3)
  - [ ] Create `src/utils/SecureLicenseStorage.ts` wrapper for localStorage
  - [ ] Implement AES-GCM encryption for license tokens using Web Crypto API
  - [ ] Add license signature verification to prevent tampering
  - [ ] Implement expiry timestamp checks on every license read
  - [ ] Create migration logic for existing user data (if applicable)
  - [ ] Test encryption/decryption roundtrip with various license states

- [ ] **Task 3: Build License Validation Flow** (AC: 3)
  - [ ] Create `src/services/LicenseValidator.ts` service
  - [ ] Implement `validateOnline(token: string): Promise<LicenseValidationResult>`
  - [ ] Add backend API endpoint mock/stub for license validation
  - [ ] Implement 7-day offline grace period logic
  - [ ] Create `lastOnlineCheck` timestamp tracking
  - [ ] Add retry logic with exponential backoff for network failures
  - [ ] Test validation flow with mocked network conditions

- [ ] **Task 4: Create Upgrade to Pro UI Flows** (AC: 4)
  - [ ] Design `UpgradeModal.tsx` component following existing modal patterns
  - [ ] Create upgrade modal variants (controller-specific, generic Pro benefits)
  - [ ] Implement pricing display ($9.99/mo, $79.99/yr with savings calculation)
  - [ ] Add "Start Free Trial" button (if applicable)
  - [ ] Integrate with payment provider (Stripe/Paddle) checkout flow
  - [ ] Create success/failure handling after purchase completion
  - [ ] Test checkout flow end-to-end with Stripe test mode

- [ ] **Task 5: Implement License Expiry Graceful Degradation** (AC: 5)
  - [ ] Create expiry warning system (7 days, 3 days, 1 day before expiration)
  - [ ] Design in-app notification banners for expiry warnings
  - [ ] Implement Pro feature lockout on expiration (disable Pro controllers)
  - [ ] Create "Renew Subscription" flow for expired licenses
  - [ ] Add telemetry for churn analysis (expired users, renewal rates)
  - [ ] Test degradation scenarios (immediate expiry, warning period, renewal)

- [ ] **Task 6: Implement Analytics & Telemetry** (AC: 6)
  - [ ] Integrate analytics service (PostHog, Mixpanel, or custom)
  - [ ] Track events: `controller_detected`, `upgrade_prompt_shown`, `upgrade_clicked`
  - [ ] Track user properties: `license_tier`, `controllers_used`, `subscription_status`
  - [ ] Implement revenue metrics: `conversion_rate`, `ARR`, `churn_rate`
  - [ ] Add privacy-compliant opt-out mechanism
  - [ ] Create analytics dashboard for business metrics

- [ ] **Task 7: Security Testing & Tamper Prevention** (IV: 3)
  - [ ] Attempt localStorage manipulation attacks (change license tier, extend expiry)
  - [ ] Verify signature validation prevents forged licenses
  - [ ] Test browser DevTools resistance (obfuscation, integrity checks)
  - [ ] Conduct timing attack analysis on validation flow
  - [ ] Implement rate limiting for license validation attempts
  - [ ] Add server-side validation as fallback for critical operations

- [ ] **Task 8: Performance & Non-Blocking Validation** (IV: 1)
  - [ ] Benchmark license check latency (target: <5ms for cached valid license)
  - [ ] Ensure validation happens async and doesn't block audio/MIDI threads
  - [ ] Implement license caching to minimize storage reads
  - [ ] Profile memory usage of LicenseManager service
  - [ ] Test under load (100 rapid license checks per second)

- [ ] **Task 9: Offline Grace Period Implementation** (IV: 2)
  - [ ] Track last successful online validation timestamp
  - [ ] Implement 7-day grace period calculation
  - [ ] Show "Offline Mode" indicator in UI when grace period active
  - [ ] Add countdown timer for remaining offline days
  - [ ] Force online validation when grace period expires
  - [ ] Test offline scenarios (airplane mode, network failures)

## Dev Notes

### Relevant Architecture Context

**Security Requirements**:
- Use Web Crypto API for encryption (AES-GCM 256-bit)
- Never store plain-text license tokens or keys
- Implement signature verification (HMAC-SHA256) to detect tampering
- Follow OWASP guidelines for client-side license validation

**Backend Integration** (Future Story):
- License validation endpoint: `POST /api/v1/license/validate`
- Stripe webhook handling: `POST /api/v1/webhooks/stripe`
- License provisioning on successful payment
- Expected response format: `{ valid: boolean, license: License, expiresAt: ISO8601 }`

**State Management**:
- Use React Context for license state (`LicenseContext.tsx`)
- Provide `useLicense()` hook for component access
- Trigger re-renders only when license tier or validity changes
- Debounce license checks to prevent excessive validation calls

**Error Handling**:
- Network failures: Use offline grace period, show retry UI
- Invalid licenses: Show upgrade modal, disable Pro features
- Expired licenses: Show renewal flow, graceful degradation
- Tampered licenses: Log security event, force re-authentication

### Source Tree Context

```
src/
├── services/
│   ├── LicenseManager.ts         # NEW - This story
│   ├── LicenseValidator.ts       # NEW - This story
│   └── AnalyticsService.ts       # NEW - This story
├── utils/
│   ├── SecureLicenseStorage.ts   # NEW - This story
│   └── encryption.ts             # NEW - Web Crypto wrapper
├── contexts/
│   └── LicenseContext.tsx        # NEW - This story
├── components/
│   └── modals/
│       ├── UpgradeModal.tsx      # NEW - This story
│       └── ExpiryWarningBanner.tsx # NEW - This story
└── hooks/
    └── useLicense.ts             # NEW - This story
```

### Key Design Decisions

**Encryption Strategy**: Use Web Crypto API (AES-GCM) instead of third-party libraries. Derive encryption key from user-specific data (device fingerprint + app secret).

**Offline Grace Period**: 7-day grace period balances user convenience with revenue protection. Most users reconnect within a week.

**License Validation**: Online validation on app startup, then cached. Periodic revalidation every 24 hours. Offline grace period prevents bad UX during network outages.

**Tamper Resistance**: Client-side validation is convenience layer. Backend validation is source of truth. Signature verification prevents most tampering attempts.

**UX Philosophy**: Never block user from using free features. Pro features gracefully lock when license invalid. Clear upgrade path with value proposition.

### Payment Integration Notes

**Stripe Integration** (recommended):
- Use Stripe Checkout for hosted payment flow (PCI-compliant, no backend required initially)
- Stripe Customer Portal for subscription management
- Webhook handling for subscription events (created, updated, cancelled)
- Test mode for development (use test card 4242 4242 4242 4242)

**Paddle Alternative** (for international/VAT complexity):
- Similar hosted checkout flow
- Built-in VAT/sales tax handling
- Merchant of record model simplifies compliance

### Testing

**Unit Tests** (`src/services/*.test.ts`):
- License validation logic with various license states
- Encryption/decryption roundtrip
- Expiry calculation and grace period logic
- Signature verification with tampered data

**Integration Tests** (`tests/integration/license-flow.test.ts`):
- End-to-end upgrade flow (free → Pro)
- License expiry and renewal
- Offline mode with grace period
- Tamper resistance (localStorage manipulation)

**Security Tests**:
- Attempt to forge valid licenses
- Test timing attacks on validation
- Verify encryption key derivation security
- Check for license cloning across devices

**Testing Standards**:
- Use Vitest for unit tests
- Use Playwright for E2E payment flows (Stripe test mode)
- Mock network requests for offline testing
- Minimum 85% code coverage for license/payment code
- Follow OWASP testing guidelines for authentication/authorization

### Compliance & Legal

**Privacy Considerations**:
- GDPR: Allow users to export/delete license data
- CCPA: Provide opt-out for analytics tracking
- Log only necessary data for license validation
- Encrypt PII (user email, payment info) in transit and at rest

**Terms of Service**:
- Define Pro tier benefits clearly
- Specify subscription auto-renewal terms
- Outline refund policy (7-day money-back guarantee recommended)
- Clarify license transferability (non-transferable recommended)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-10 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_

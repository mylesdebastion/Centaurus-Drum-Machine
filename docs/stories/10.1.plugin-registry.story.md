# Story 10.1: Controller Plugin Architecture & Registry System

## Status
Draft

## Story
**As a** system architect,
**I want** a plugin-based controller registry with hot-swappable controller profiles,
**so that** new controllers can be added without modifying core application code and can be gated by license tier.

## Acceptance Criteria
1. Create `src/hardware/registry/ControllerRegistry.ts` with plugin registration system
2. Implement controller profile schema (metadata, MIDI mapping, LED config, capabilities)
3. Build controller discovery/enumeration based on connected MIDI devices
4. Create hot-swap mechanism for loading/unloading controller profiles at runtime
5. Design feature flag system for Pro-gated vs free-tier controller access
6. Implement fallback behavior when Pro-gated controllers detected without license

## Integration Verification
- **IV1**: Existing APC40 integration continues working unchanged
- **IV2**: Registry system adds <2% memory overhead when no additional controllers loaded
- **IV3**: Free tier users can still use APC40 (legacy support) and see Pro controller availability

## Tasks / Subtasks

- [ ] **Task 1: Create Controller Registry Core System** (AC: 1)
  - [ ] Create `src/hardware/registry/ControllerRegistry.ts` with singleton pattern
  - [ ] Implement `registerController(profile: ControllerProfile)` method
  - [ ] Implement `unregisterController(controllerId: string)` method
  - [ ] Implement `getRegisteredControllers(): ControllerProfile[]` method
  - [ ] Add event emitter for registry changes (controller added/removed)
  - [ ] Create unit tests for registry CRUD operations

- [ ] **Task 2: Design Controller Profile Schema** (AC: 2)
  - [ ] Create `src/hardware/types/ControllerProfile.ts` TypeScript interface
  - [ ] Define metadata fields (id, name, manufacturer, model, version, icon)
  - [ ] Define MIDI mapping schema (note maps, CC maps, SysEx initialization)
  - [ ] Define LED configuration schema (capabilities, color modes, brightness range)
  - [ ] Define capability flags (hasLEDs, hasFaders, hasPads, hasKeys, maxPolyphony)
  - [ ] Create JSON schema validation for controller profiles
  - [ ] Add example controller profile documentation

- [ ] **Task 3: Build Controller Discovery System** (AC: 3)
  - [ ] Extend Web MIDI wrapper to emit device connection events
  - [ ] Create `ControllerDetector.ts` to match MIDI devices to registered profiles
  - [ ] Implement fuzzy matching algorithm (device name → controller profile)
  - [ ] Add manual device selection UI for ambiguous matches
  - [ ] Create polling mechanism for device state changes
  - [ ] Test with multiple MIDI devices connected simultaneously

- [ ] **Task 4: Implement Hot-Swap Mechanism** (AC: 4)
  - [ ] Create `ControllerLoader.ts` for runtime profile loading/unloading
  - [ ] Implement `loadController(profileId: string, device: MIDIDevice)` async method
  - [ ] Implement `unloadController(controllerId: string)` cleanup method
  - [ ] Add graceful state preservation when controller disconnected
  - [ ] Handle race conditions (rapid connect/disconnect)
  - [ ] Test hot-swap during active sequencer playback

- [ ] **Task 5: Design License-Based Feature Gating** (AC: 5)
  - [ ] Create `src/hardware/types/ControllerTier.ts` enum (Free, Pro, Enterprise)
  - [ ] Add `tier: ControllerTier` field to ControllerProfile schema
  - [ ] Create `src/services/FeatureGate.ts` utility class
  - [ ] Implement `canUseController(profile: ControllerProfile, license: License): boolean`
  - [ ] Design visual indicators for locked/unlocked controllers in UI
  - [ ] Add telemetry for feature gate interactions (upgrade prompt impressions)

- [ ] **Task 6: Implement License Fallback Behavior** (AC: 6)
  - [ ] Create graceful degradation messaging when Pro controller detected without license
  - [ ] Implement "Upgrade to Pro" modal with controller-specific benefits
  - [ ] Add demo mode trigger (5-minute trial for Pro controllers)
  - [ ] Design "ghost" UI state (show controller as detected but disabled)
  - [ ] Create analytics event tracking for license gate encounters
  - [ ] Test fallback behavior across all UI states (connected, disconnected, upgraded)

- [ ] **Task 7: Integration Testing & Performance Validation** (IV: 1, 2, 3)
  - [ ] Verify APC40 integration unchanged (existing tests pass)
  - [ ] Benchmark memory overhead with registry loaded (target: <2% increase)
  - [ ] Test free tier user flow (APC40 works, Pro controllers show upgrade prompt)
  - [ ] Load testing with 10+ registered controllers in registry
  - [ ] Validate hot-swap performance (<100ms controller initialization)

## Dev Notes

### Relevant Architecture Context

**Hardware Abstraction Layer (from Epic 1)**:
- Existing `src/hardware/core/` module provides base interfaces
- Controller modules must implement `HardwareController` interface
- Event-driven communication system already established
- Lifecycle management patterns (connect/disconnect/error) defined

**MIDI Integration (from Story 1.2)**:
- Web MIDI API wrapper: `src/services/WebMIDIService.ts`
- Device detection and enumeration patterns established
- Browser compatibility layer already implemented
- HTTPS requirement documented for Web MIDI access

**State Management Patterns**:
- Use React Context for controller registry state
- Follow existing `src/contexts/` patterns
- Maintain separation between MIDI layer and UI layer
- Use Zustand or Context API for global controller state

**Performance Requirements**:
- All MIDI operations must be non-blocking
- LED updates target <50ms latency
- Registry lookup operations must be O(1) via Map data structure
- Avoid re-renders when controller state doesn't affect UI

### Source Tree Context

```
src/
├── hardware/
│   ├── core/                    # Existing abstraction layer (Epic 1)
│   │   ├── HardwareController.ts
│   │   ├── MIDIEventBus.ts
│   │   └── ControllerLifecycle.ts
│   ├── registry/                # NEW - This story
│   │   ├── ControllerRegistry.ts
│   │   ├── ControllerDetector.ts
│   │   ├── ControllerLoader.ts
│   │   └── index.ts
│   ├── types/                   # NEW - This story
│   │   ├── ControllerProfile.ts
│   │   ├── ControllerTier.ts
│   │   └── MIDIMapping.ts
│   └── controllers/             # Existing (Epic 1)
│       └── apc40/
├── services/
│   ├── WebMIDIService.ts        # Existing - extend for discovery
│   ├── FeatureGate.ts           # NEW - This story
│   └── LicenseManager.ts        # Story 10.2 dependency
└── contexts/
    └── ControllerContext.tsx    # NEW - This story
```

### Key Design Decisions

**Registry Pattern**: Singleton registry prevents multiple instances and provides global access point. Use dependency injection for testability.

**Profile Schema**: JSON-based profiles enable external loading (future npm package). Versioned schema allows backward compatibility.

**Hot-Swap**: Use async/await pattern for controller loading. Implement cleanup via AbortController for cancellable operations.

**Feature Gating**: Separate concern from registry logic. FeatureGate service checks license tier before allowing controller activation.

**Fallback UX**: Non-blocking upgrade prompts. Users can continue using free controllers while seeing Pro controller availability.

### Testing

**Unit Tests** (`src/hardware/registry/*.test.ts`):
- Registry CRUD operations
- Profile schema validation
- Feature gate logic with various license states
- Hot-swap race condition handling

**Integration Tests** (`tests/integration/controller-registry.test.ts`):
- End-to-end controller registration and discovery
- Multi-controller scenarios
- License tier enforcement
- APC40 backward compatibility

**Performance Tests**:
- Memory profiling with 10+ registered controllers
- Registry lookup latency benchmarks
- Hot-swap timing measurements

**Testing Standards**:
- Use Vitest for unit tests
- Use Playwright for integration tests
- Minimum 80% code coverage for registry module
- Mock Web MIDI API for deterministic testing

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-10 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_

# Story 1.5: Multi-Hardware Coordination and State Management

## Status
Draft

## Story
**As an** advanced producer,  
**I want** multiple hardware controllers to work together seamlessly,  
**so that** I can use different controllers for specialized functions in complex setups

## Acceptance Criteria
1. Enable multiple hardware modules to connect simultaneously
2. Implement inter-module event communication for coordinated behaviors  
3. Create hardware module priority and conflict resolution system
4. Build hot-swap capability for connecting/disconnecting devices during operation
5. Implement state synchronization across all connected hardware and web interface

**Integration Verification**:
- **IV1**: Core sequencer performance remains stable with multiple hardware modules
- **IV2**: Disconnecting one hardware module does not affect others or core functionality
- **IV3**: State changes from any source (hardware A, hardware B, web UI) sync to all interfaces

## Tasks / Subtasks
- [ ] **Task 1: Multi-Device Connection Management** (AC: 1)
  - [ ] Extend HardwareManager to support multiple simultaneous controller connections
  - [ ] Implement device registry with unique identifier tracking
  - [ ] Create connection pool management for multiple Web MIDI devices
  - [ ] Add device enumeration and automatic recognition for supported hardware

- [ ] **Task 2: Inter-Module Event System** (AC: 2)
  - [ ] Extend existing HardwareEvent system for multi-controller coordination
  - [ ] Implement event broadcasting between connected hardware modules
  - [ ] Create event filtering system for controller-specific vs. global events
  - [ ] Add event prioritization for coordinated hardware behaviors

- [ ] **Task 3: Priority and Conflict Resolution** (AC: 3)
  - [ ] Implement hardware module priority system for conflicting inputs
  - [ ] Create conflict resolution rules (last-input-wins, priority-based, user-configured)
  - [ ] Add device role assignment (primary/secondary controller configuration)
  - [ ] Handle simultaneous input conflicts gracefully without blocking

- [ ] **Task 4: Hot-Swap Device Management** (AC: 4)
  - [ ] Implement live device connection/disconnection without application restart
  - [ ] Create graceful device removal that preserves other hardware states
  - [ ] Add automatic device re-registration when reconnected
  - [ ] Handle device hot-swap during active sequencer playback

- [ ] **Task 5: Universal State Synchronization** (AC: 5)
  - [ ] Extend state synchronization from Story 1.4 to multiple hardware devices
  - [ ] Implement state broadcasting to all connected controllers
  - [ ] Create state consistency verification across all interfaces
  - [ ] Handle partial state sync when devices have different capabilities

- [ ] **Task 6: Device Configuration Management**
  - [ ] Create device-specific settings persistence in localStorage
  - [ ] Implement per-device configuration profiles (LED preferences, button mappings)
  - [ ] Add device capability detection and feature adaptation
  - [ ] Handle mixed-capability device scenarios gracefully

- [ ] **Task 7: Performance Optimization for Multi-Device** (Performance requirements)
  - [ ] Optimize event system performance with multiple active controllers
  - [ ] Implement efficient state broadcasting to minimize redundant updates
  - [ ] Add performance monitoring for multi-device coordination overhead
  - [ ] Ensure <5% performance impact with multiple connected devices

- [ ] **Task 8: Integration Testing** (AC: All)
  - [ ] Test multiple APC40 controllers simultaneously (device simulation)
  - [ ] Test mixed hardware types coordination (prepare for future controllers)
  - [ ] Test hot-swap scenarios during active sequencer operation
  - [ ] Verify state synchronization accuracy across multiple devices
  - [ ] Test conflict resolution and priority systems
  - [ ] Achieve 80% test coverage target

## Dev Notes

### Previous Story Insights
**Story 1.1 Foundation**: Hardware abstraction layer with plugin architecture designed for multiple controllers, HardwareManager context with controller registration system.

**Story 1.2 Web MIDI**: Web MIDI API wrapper with multi-device connection capabilities, connection management utilities.

**Story 1.3 APC40**: APC40Controller implementing HardwareController interface, provides template for additional controller types.

**Story 1.4 LED Feedback**: Multi-source state synchronization established, LED updates handle changes from multiple sources.

### Data Models [Source: architecture/data-models-and-schema-changes.md & previous stories]
- **Multi-Device Registry**:
  - `activeControllers: Map<string, HardwareController>` - All connected hardware controllers
  - `devicePriorities: Map<string, number>` - Priority levels for conflict resolution
  - `deviceRoles: Map<string, string>` - Role assignments (primary, secondary, utility)
  - `deviceCapabilities: Map<string, ControllerCapabilities>` - Feature matrix per device

- **Coordination State Management**:
  - `globalState: SequencerState` - Master sequencer state shared across all devices
  - `deviceStates: Map<string, DeviceState>` - Per-device specific state and settings
  - `syncStatus: Map<string, boolean>` - Real-time sync status for each connected device
  - `conflictResolution: ConflictResolutionStrategy` - Active conflict handling strategy

### Component Specifications [Source: architecture/component-architecture.md]
- **HardwareManager Extensions** (building on Story 1.1):
  - Multi-controller registration and lifecycle management
  - Event broadcasting and coordination between controllers
  - State synchronization across all connected hardware
  - Device priority and conflict resolution management

- **Multi-Device Coordination Layer**:
  - Inter-module event communication system
  - Priority-based input handling
  - Hot-swap device management
  - Universal state broadcasting

### File Locations [Source: architecture/source-tree.md]
- **Coordination System**: `src/hardware/core/` extensions to HardwareManager
- **Multi-Device Utils**: `src/hardware/utils/multiDeviceManager.ts`
- **Conflict Resolution**: `src/hardware/core/conflictResolution.ts`
- **Device Registry**: Extend existing HardwareManager with multi-device capabilities

### Technical Constraints [Source: architecture/tech-stack.md]
- **Performance**: <5% additional overhead with multiple connected devices
- **Memory**: Efficient state management for multiple device states
- **Timing**: Multi-device coordination must not affect audio engine timing
- **Browser Limits**: Web MIDI API device connection limits (typically 10+ devices supported)

### Multi-Device Architecture Pattern
- **Plugin System**: Uses hardware abstraction from Story 1.1 for easy controller addition
- **Event Broadcasting**: Central event system distributes state changes to all connected devices
- **Priority Resolution**: Configurable priority system handles simultaneous inputs
- **Hot-Swap Safety**: Device connections/disconnections don't affect other devices or core functionality

### Device Coordination Strategies
- **Last-Input-Wins**: Most recent hardware input takes precedence (default)
- **Priority-Based**: Higher priority devices override lower priority devices
- **Role-Based**: Primary controller for main functions, secondary for utility functions
- **User-Configured**: Advanced users can define custom conflict resolution rules

### State Synchronization Approach
- **Master State**: Single source of truth maintained in HardwareManager
- **Device Sync**: Each controller receives full state updates for display/LED feedback
- **Partial Sync**: Controllers with limited capabilities receive appropriate subset of state
- **Consistency Verification**: Regular sync status checks ensure all devices stay coordinated

### Integration Guidelines
- **Backward Compatibility**: Single APC40 usage (Stories 1.1-1.4) continues to work identically
- **Performance Protection**: Multi-device coordination isolated from audio engine timing
- **Error Isolation**: Individual device failures don't affect other connected devices
- **State Management**: Uses established HardwareEvent system from previous stories

### Testing
**Test Framework**: Jest/Vitest with React Testing Library [Source: architecture/testing-strategy.md]  
**Test Location**: `src/hardware/__tests__/multiDevice/`  
**Coverage Target**: 80% line coverage for multi-device coordination  
**Testing Requirements**:
- Simulate multiple APC40 controllers with Web MIDI API mocking
- Test device connection/disconnection scenarios during operation
- Test conflict resolution across different priority configurations
- Test state synchronization accuracy with multiple active devices
- Performance testing with multiple device coordination overhead
- Hot-swap testing during active sequencer playback

### Project Structure Notes
Multi-hardware coordination builds on all previous story foundations. Extends HardwareManager from Story 1.1, uses Web MIDI multi-device from Story 1.2, leverages APC40Controller pattern from Story 1.3, and extends state synchronization from Story 1.4. Complete system works with single or multiple controllers without code changes.

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-09-25 | 1.0 | Initial story creation from epic | Story Manager (Bob) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be completed by dev agent*

### Debug Log References  
*To be completed by dev agent*

### Completion Notes List
*To be completed by dev agent*

### File List
*To be completed by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation*
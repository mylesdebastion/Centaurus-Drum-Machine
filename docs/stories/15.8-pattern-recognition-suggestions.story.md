# Story 15.8: Arpeggio & Intervallic Pattern Recognition with Emerging Suggestions

**Epic:** [Epic 15 - Chord Progression & Melody Arranger Module](../epics/epic-15-chord-melody-arranger.md)
**Status:** üìã **BACKLOG** (Placeholder - Needs Detailed Requirements)
**Priority:** üü° **MEDIUM**
**Complexity:** **High**
**Time Estimate:** TBD (requires further analysis)
**Prerequisites:**
- ‚úÖ Story 15.7 (Intelligent Melody Generator with Harmonic Guidance)

---

## Story Overview (High-Level Concept)

**As a** composer using the melody step sequencer
**When I** manually place notes that form a recognizable pattern (arpeggio, scale run, intervallic sequence)
**I want to** see the pattern automatically detected and future notes suggested to continue the pattern
**So that** I can quickly compose melodic sequences with visual predictions that "emerge/grow out" from my input

---

## Vision Statement (Myles' Feedback)

> "Settings/tool to draw arpeggios and intervallic sequences and see them suggested 'emerging/growing out' - you select notes and then it makes obvious future predictions"

### **Core Concept: Pattern Recognition Engine**

The melody sequencer should analyze user-placed notes and detect musical patterns:
- **Arpeggios:** Notes outlining chord tones (1-3-5-7, 1-3-5-1, etc.)
- **Scale Runs:** Stepwise motion (ascending/descending scales)
- **Intervallic Sequences:** Repeating interval patterns (3rds, 4ths, 5ths)
- **Rhythmic Motifs:** Repeating rhythmic durations

Once detected, the system should:
1. **Predict** the next logical notes in the pattern
2. **Visualize** predictions with progressive brightness (next note brightest, subsequent notes dimmer)
3. **Extend** the pattern across multiple steps (emergent/growing effect)

---

## Acceptance Criteria (To Be Detailed)

### 1. Pattern Detection System ‚è∏Ô∏è

**Must detect:**
- [ ] Arpeggios (chord tone outlines: root-3rd-5th, root-5th-octave, etc.)
- [ ] Scale runs (stepwise motion: C-D-E-F-G or G-F-E-D-C)
- [ ] Intervallic sequences (repeating intervals: 3rd up, 3rd down, 4th up, etc.)
- [ ] Rhythmic motifs (repeating duration patterns: 0.5-0.25-0.25, etc.)

**Algorithm Requirements:**
```typescript
interface PatternDetection {
  type: 'arpeggio' | 'scale-run' | 'intervallic' | 'rhythmic';
  confidence: number; // 0-1 (how confident the pattern match is)
  nextPredictions: Array<{
    pitch: number;
    probability: number; // 0-1 (how likely this note continues the pattern)
    step: number; // Which step this prediction is for
  }>;
}
```

**Minimum Pattern Length:**
- 3 notes to detect arpeggio
- 4 notes to detect scale run
- 3 notes to detect intervallic sequence
- 4 notes to detect rhythmic motif

---

### 2. Emerging Suggestion Visualization ‚è∏Ô∏è

**Must show:**
- [ ] Predicted notes "growing out" from last placed note
- [ ] Progressive brightness dimming (next note = 0.85, +1 step = 0.70, +2 steps = 0.55, +3 steps = 0.40)
- [ ] Pattern confidence indicator (e.g., green glow = high confidence, yellow = medium, gray = low)
- [ ] Multiple predictions when pattern is ambiguous (e.g., arpeggio could go up or down)

**Visual System:**
```typescript
// Example: User places C-E-G (arpeggio)
// System predicts continuation: C (octave) or B (7th) or E (3rd return)

Predicted notes:
- Step N+1: C (octave) - brightness 0.85, green glow (high confidence)
- Step N+2: E (3rd) - brightness 0.70 (medium confidence)
- Step N+3: G (5th) - brightness 0.55 (medium confidence)
- Step N+4: C (octave) - brightness 0.40 (low confidence)
```

---

### 3. Pattern Continuation Tool ‚è∏Ô∏è

**Must provide:**
- [ ] "Continue Pattern" button (appears when pattern detected)
- [ ] Click to auto-fill predicted notes
- [ ] Option to extend pattern by N steps (4, 8, 16 steps)
- [ ] Settings panel:
  - Pattern sensitivity (low/medium/high)
  - Auto-detect vs manual pattern lock
  - Prediction lookahead distance (how many steps ahead)

---

## Technical Implementation (To Be Designed)

### **Pattern Detection Algorithm (Pseudocode)**

```typescript
class PatternRecognitionEngine {
  /**
   * Analyze placed notes and detect patterns
   */
  detectPatterns(placedNotes: MelodyNote[]): PatternDetection[] {
    if (placedNotes.length < 3) return []; // Insufficient data

    const patterns: PatternDetection[] = [];

    // 1. Check for arpeggios (chord tone outlines)
    const arpeggioPattern = this.detectArpeggio(placedNotes);
    if (arpeggioPattern.confidence > 0.6) {
      patterns.push(arpeggioPattern);
    }

    // 2. Check for scale runs (stepwise motion)
    const scaleRunPattern = this.detectScaleRun(placedNotes);
    if (scaleRunPattern.confidence > 0.6) {
      patterns.push(scaleRunPattern);
    }

    // 3. Check for intervallic sequences (repeating intervals)
    const intervallicPattern = this.detectIntervallicSequence(placedNotes);
    if (intervallicPattern.confidence > 0.6) {
      patterns.push(intervallicPattern);
    }

    // Return highest confidence pattern(s)
    return patterns.sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Detect arpeggio pattern (chord tone outlines)
   */
  private detectArpeggio(notes: MelodyNote[]): PatternDetection {
    const intervals = this.getIntervals(notes);

    // Common arpeggio intervals: 3rds, 4ths, 5ths (skipping scale degrees)
    const arpeggioIntervals = [3, 4, 5, 7, 8, 9]; // Major/minor 3rd, perfect 4th/5th, etc.

    const matchCount = intervals.filter(i => arpeggioIntervals.includes(Math.abs(i))).length;
    const confidence = matchCount / intervals.length;

    // Predict next notes (continue arpeggio up/down)
    const lastNote = notes[notes.length - 1];
    const lastInterval = intervals[intervals.length - 1];

    return {
      type: 'arpeggio',
      confidence,
      nextPredictions: [
        { pitch: lastNote.pitch + lastInterval, probability: 0.8, step: lastNote.step + 1 },
        { pitch: lastNote.pitch - lastInterval, probability: 0.6, step: lastNote.step + 1 }, // Reverse direction
      ],
    };
  }

  /**
   * Detect scale run pattern (stepwise motion)
   */
  private detectScaleRun(notes: MelodyNote[]): PatternDetection {
    const intervals = this.getIntervals(notes);

    // Scale runs have consistent small intervals (1-2 semitones)
    const isStepwise = intervals.every(i => Math.abs(i) <= 2);
    const direction = intervals[0] > 0 ? 1 : -1; // Ascending or descending
    const isConsistentDirection = intervals.every(i => Math.sign(i) === direction);

    const confidence = isStepwise && isConsistentDirection ? 0.9 : 0.3;

    // Predict next notes (continue scale run)
    const lastNote = notes[notes.length - 1];
    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;

    return {
      type: 'scale-run',
      confidence,
      nextPredictions: [
        { pitch: lastNote.pitch + avgInterval, probability: 0.9, step: lastNote.step + 1 },
        { pitch: lastNote.pitch + (avgInterval * 2), probability: 0.7, step: lastNote.step + 2 },
        { pitch: lastNote.pitch + (avgInterval * 3), probability: 0.5, step: lastNote.step + 3 },
      ],
    };
  }

  /**
   * Get intervals between consecutive notes
   */
  private getIntervals(notes: MelodyNote[]): number[] {
    const intervals: number[] = [];
    for (let i = 1; i < notes.length; i++) {
      intervals.push(notes[i].pitch - notes[i - 1].pitch);
    }
    return intervals;
  }
}
```

---

## Visual Examples (To Be Mocked Up)

### **Example 1: Arpeggio Detection**

**User places:** C4 (step 0) ‚Üí E4 (step 1) ‚Üí G4 (step 2)

**System detects:** Major triad arpeggio (C-E-G)

**Visual feedback:**
```
Step 0: C4 [PLACED] - brightness 1.0, white border
Step 1: E4 [PLACED] - brightness 1.0, white border
Step 2: G4 [PLACED] - brightness 1.0, white border
Step 3: C5 [PREDICTED] - brightness 0.85, green glow (high confidence continuation)
Step 4: E5 [PREDICTED] - brightness 0.70, green glow
Step 5: G5 [PREDICTED] - brightness 0.55, green glow
Step 6: C6 [PREDICTED] - brightness 0.40, gray glow (low confidence)
```

**Pattern Confidence:** 90% (strong arpeggio pattern)

---

### **Example 2: Scale Run Detection**

**User places:** C4 (step 0) ‚Üí D4 (step 1) ‚Üí E4 (step 2) ‚Üí F4 (step 3)

**System detects:** Ascending C major scale run

**Visual feedback:**
```
Step 0: C4 [PLACED] - brightness 1.0, white border
Step 1: D4 [PLACED] - brightness 1.0, white border
Step 2: E4 [PLACED] - brightness 1.0, white border
Step 3: F4 [PLACED] - brightness 1.0, white border
Step 4: G4 [PREDICTED] - brightness 0.85, green glow (continue scale)
Step 5: A4 [PREDICTED] - brightness 0.70, green glow
Step 6: B4 [PREDICTED] - brightness 0.55, green glow
Step 7: C5 [PREDICTED] - brightness 0.40, green glow (octave resolution)
```

**Pattern Confidence:** 95% (very strong stepwise pattern)

---

### **Example 3: Intervallic Sequence Detection**

**User places:** C4 (step 0) ‚Üí E4 (step 2) ‚Üí D4 (step 4) ‚Üí F4 (step 6)

**System detects:** Alternating 3rd up, 2nd down (intervallic sequence)

**Visual feedback:**
```
Step 0: C4 [PLACED] - brightness 1.0, white border
Step 2: E4 [PLACED] - brightness 1.0, white border
Step 4: D4 [PLACED] - brightness 1.0, white border
Step 6: F4 [PLACED] - brightness 1.0, white border
Step 8: E4 [PREDICTED] - brightness 0.85, yellow glow (medium confidence - 2nd down)
Step 10: G4 [PREDICTED] - brightness 0.70, yellow glow (3rd up)
Step 12: F4 [PREDICTED] - brightness 0.55, yellow glow (2nd down)
```

**Pattern Confidence:** 75% (moderate intervallic pattern)

---

## Open Questions (Needs Stakeholder Input)

1. **Pattern Conflict Resolution:**
   - What happens if multiple patterns are detected (e.g., both arpeggio AND scale run)?
   - Should user choose which pattern to continue, or show both predictions?

2. **Pattern Lock Mode:**
   - Should user be able to "lock" a pattern (force predictions even if confidence is low)?
   - How to indicate locked pattern vs auto-detected pattern?

3. **Real-Time vs On-Demand:**
   - Should patterns be detected in real-time as user places notes?
   - Or should user click "Detect Pattern" button to trigger analysis?

4. **Prediction Lookahead Distance:**
   - Default: 4 steps ahead? 8 steps? 16 steps?
   - Should this be user-configurable?

5. **Integration with Intelligent Melody Settings:**
   - Should pattern predictions respect chord tone density setting?
   - Should contour setting influence pattern extension (e.g., arch pattern stops ascending after peak)?

6. **UX for Multiple Predictions:**
   - If arpeggio could go up OR down, show both?
   - Use different glow colors for alternate predictions (green = primary, blue = alternate)?

---

## Manual Verification Steps (To Be Defined)

```markdown
### Step 1: Arpeggio Detection
1. Clear all notes
2. Place C4 in step 0, E4 in step 1, G4 in step 2
3. **Verify:** System detects major triad arpeggio (confidence > 80%)
4. **Verify:** Step 3 shows C5 predicted (brightness 0.85, green glow)
5. **Verify:** Steps 4-6 show dimming predictions (0.70, 0.55, 0.40)
6. Click "Continue Pattern" button
7. **Verify:** Predicted notes are placed automatically

### Step 2: Scale Run Detection
1. Clear all notes
2. Place C4, D4, E4, F4 in steps 0-3
3. **Verify:** System detects ascending scale run (confidence > 90%)
4. **Verify:** Steps 4-7 show G4, A4, B4, C5 predicted
5. **Verify:** Progressive brightness dimming (0.85 ‚Üí 0.70 ‚Üí 0.55 ‚Üí 0.40)

### Step 3: Pattern Ambiguity
1. Clear all notes
2. Place C4, E4, G4 (arpeggio)
3. **Verify:** System shows BOTH up (C5) and down (E3) predictions
4. **Verify:** Primary prediction (C5) has green glow, alternate (E3) has blue glow
5. Click C5 prediction
6. **Verify:** Pattern continues upward (E5, G5 predicted next)
```
```

---

## Dependencies (To Be Refined)

**Services:**
- üÜï `PatternRecognitionEngine` (NEW) - Pattern detection algorithm
- ‚úÖ `ChordProgressionService` (Story 15.1) - Chord tone context for arpeggio detection
- ‚úÖ `GlobalMusicContext` (Epic 4) - Scale context for scale run detection

**UI Components:**
- ‚úÖ `MelodySequencer` (Story 15.3) - Base component to enhance
- ‚úÖ `HarmonicGuidanceOverlay` (Story 15.7) - Visual guidance layer (extend for pattern predictions)
- üÜï `PatternContinuationButton` (NEW) - "Continue Pattern" UI control
- üÜï `PatternSettingsPanel` (NEW) - Pattern sensitivity, lookahead settings

---

## Technical Debt / Future Enhancements

### Phase 2 (Post-Story):
- **Machine Learning:** Train model to recognize user-specific patterns
- **Pattern Library:** Save/load custom patterns (e.g., "My Favorite Lick")
- **Pattern Variations:** Generate variations on detected pattern (inversions, transpositions)
- **Multi-Voice Patterns:** Detect harmonized patterns (parallel 3rds, 6ths)

---

## Related Stories

- **Story 15.7:** Intelligent Melody Generator (provides harmonic guidance foundation)
- **Story 15.3:** MelodySequencer Component (base UI to extend)
- **Future Story:** AI-Assisted Melody Completion (uses pattern recognition for ML training)

---

## Stakeholder Sign-Off

**Product Owner (Myles):** _____________________________ Date: _______
**UX Expert (Mary):** _____________________________ Date: _______
**Dev Lead:** _____________________________ Date: _______

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-14 | 0.1 | Initial placeholder story - Arpeggio & Pattern Recognition | John (PM) |

---

## Next Steps

1. **Requirements Gathering** - Myles to provide detailed requirements for pattern detection
2. **UX Mockups** - Mary to create visual examples of "emerging/growing" predictions
3. **Algorithm Research** - Dev Lead to research pattern recognition algorithms (music theory + ML)
4. **Story Refinement** - Expand acceptance criteria with concrete examples
5. **Priority Assessment** - Determine if this should be Story 15.8 or deferred to Epic 16

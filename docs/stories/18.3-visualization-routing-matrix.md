# Story 18.3: Visualization Routing Matrix

**Epic:** Epic 18 - Intelligent WLED Visualization Routing
**Status:** üìù PLANNING
**Priority:** üî¥ HIGH
**Complexity:** High
**Time Estimate:** 5-6 hours
**Prerequisites:** Story 18.2 (Module Capability Declaration)

---

## User Story

As a **user with multiple WLED devices and active modules**,
I want **the system to automatically route visualizations to the most appropriate devices**,
So that **I don't have to manually configure which device displays which module**.

---

## Story Context

### Why This Story

**Core Intelligence Layer:** Story 18.3 implements the intelligent routing algorithm that is the heart of Epic 18's automatic visualization routing system.

**Current State:**
- ‚úÖ Device registry exists with capability metadata (Story 18.1)
- ‚úÖ Modules declare visualization capabilities (Story 18.2)
- ‚ùå No automatic routing between modules and devices
- ‚ùå Manual device selection required per module
- ‚ùå No compatibility scoring or priority system
- ‚ùå No overlay detection or layering

**Desired State (Story 18.3):**
- ‚úÖ `VisualizationRoutingMatrix` class intelligently matches modules to devices
- ‚úÖ Compatibility scoring algorithm evaluates module-device fit
- ‚úÖ Priority-based assignment (active module gets best device)
- ‚úÖ Overlay detection (audio reactive layers on top of other visualizations)
- ‚úÖ Automatic recalculation on module/device changes
- ‚úÖ Type-safe routing assignments

**Example Routing Scenarios:**

```typescript
// Scenario 1: Drum Machine + 6x25 Grid
// Input: DrumMachine active, one 6x25 grid device
// Output: Grid shows step-sequencer-grid visualization

// Scenario 2: Guitar Fretboard + 6x25 Grid
// Input: GuitarFretboard active, same 6x25 grid device
// Output: Grid shows fretboard-grid visualization

// Scenario 3: Piano Roll + 1D Strip
// Input: PianoRoll active, 88-LED strip device
// Output: Strip shows piano-keys visualization (1D fallback)

// Scenario 4: Audio Reactive Overlay
// Input: AudioReactive active, DrumMachine active, 6x25 grid + 1D strip
// Output: Grid shows step-sequencer-grid + midi-trigger-ripple (overlay)
//         Strip shows step-sequencer-1d + midi-trigger-ripple (overlay)
```

---

## Acceptance Criteria

### Functional Requirements

1. **VisualizationRoutingMatrix Class**
   - Create `src/services/VisualizationRoutingMatrix.ts`:
     ```typescript
     class VisualizationRoutingMatrix {
       constructor(
         deviceRegistry: WLEDDeviceRegistry,
         ledCompositor: LEDCompositor
       );

       // Main routing algorithm
       routeVisualizations(): DeviceAssignment[];

       // Compatibility scoring
       calculateCompatibility(
         producer: VisualizationProducer,
         device: WLEDDevice
       ): number;

       // Priority-based assignment
       assignDevices(): Map<string, DeviceAssignment>;

       // Overlay detection
       detectOverlays(assignments: DeviceAssignment[]): DeviceAssignment[];

       // Force recalculation
       recalculateRouting(): void;

       // Debug helpers
       debugPrintRouting(): void;
     }
     ```

2. **DeviceAssignment Type**
   - Define assignment structure in `src/types/visualization.ts`:
     ```typescript
     interface DeviceAssignment {
       device: WLEDDevice;
       primary: {
         moduleId: ModuleId;
         visualizationType: VisualizationType;
         producer: VisualizationProducer;
         compatibilityScore: number;
       };
       overlays: {
         moduleId: ModuleId;
         visualizationType: VisualizationType;
         producer: VisualizationProducer;
       }[];
       totalPriority: number; // Primary priority + overlay priorities
     }
     ```

3. **Compatibility Scoring Algorithm**
   - Perfect dimension match: +100 points
   - Can work with either dimension: +50 points
   - Device explicitly supports visualization type: +50 points
   - Module priority multiplier: √ópriority
   - Active module bonus: +200 points
   - Example scores:
     ```typescript
     // DrumMachine (priority 10) + 6x25 Grid (2D) ‚Üí step-sequencer-grid
     // Dimension match (2D) = 100
     // Explicit support = 50
     // Priority multiplier = 10
     // Total = (100 + 50) * 10 = 1500

     // DrumMachine (priority 5) + 90-LED Strip (1D) ‚Üí step-sequencer-1d
     // Dimension match (1D) = 100
     // Priority multiplier = 5
     // Total = 100 * 5 = 500
     ```

4. **Priority-Based Device Assignment**
   - For each device, find all compatible modules
   - Sort by compatibility score (descending)
   - Assign highest-scoring module as primary
   - Detect overlay-compatible modules
   - Add overlays to assignment
   - Handle conflicts (two modules want same device):
     - Active module wins (bonus +200 points)
     - Higher priority wins
     - Fallback to alternative visualization type

5. **Overlay Detection and Layering**
   - Identify modules with `overlayCompatible: true`
   - Add overlays to all device assignments
   - Example: Audio Reactive overlays on ALL devices
   - Overlay order matters (render in priority order)
   - Prevent exclusive visualizations from overlaying:
     ```typescript
     // ‚úÖ ALLOWED: Audio Reactive (overlay) + Drum Machine (exclusive)
     // ‚ùå BLOCKED: Drum Machine (exclusive) + Guitar (exclusive)
     ```

6. **Automatic Recalculation Triggers**
   - Module registered/unregistered (LEDCompositor event)
   - Device added/removed/updated (WLEDDeviceRegistry event)
   - Active module changed (user switches modules)
   - Manual trigger: `recalculateRouting()`

### Integration Requirements

7. **Event-Driven Architecture**
   - Subscribe to module registration changes
   - Subscribe to device registry changes
   - Emit routing change events for subscribers
   - Debounce recalculation (avoid thrashing)

8. **Performance Optimization**
   - Cache routing assignments (only recalculate on change)
   - Compatibility scores cached per module-device pair
   - Routing decision: <10ms (imperceptible latency)
   - No blocking UI during recalculation

9. **Error Handling**
   - No devices available: Return empty assignments (graceful degradation)
   - No compatible modules: Fallback to `generic-color-array`
   - Invalid device capabilities: Skip device, log warning
   - Module capability mismatch: Use fallback visualization type

### Quality Requirements

10. **Type Safety**
    - All assignments type-checked at compile time
    - Invalid module-device pairs caught by TypeScript
    - No runtime type errors in routing algorithm

11. **Testability**
    - Unit tests for compatibility scoring
    - Unit tests for priority-based assignment
    - Integration tests for routing scenarios (Drum Machine + Grid, etc.)
    - Mock device registry and LEDCompositor for testing

12. **Debugging Support**
    - `debugPrintRouting()` shows current assignments
    - Console logs for routing decisions
    - Compatibility score breakdown in debug mode
    - Visual routing table in DevTools

---

## Technical Approach

### Phase 1: Type Definitions and Data Structures (1 hour)

**Create Assignment Types:**
```typescript
// src/types/visualization.ts (extend existing)

/**
 * Assignment of a module visualization to a device
 */
export interface DeviceAssignment {
  /** Target WLED device */
  device: WLEDDevice;

  /** Primary visualization (exclusive or background) */
  primary: {
    moduleId: ModuleId;
    visualizationType: VisualizationType;
    producer: VisualizationProducer;
    compatibilityScore: number;
  };

  /** Overlay visualizations (rendered on top of primary) */
  overlays: {
    moduleId: ModuleId;
    visualizationType: VisualizationType;
    producer: VisualizationProducer;
  }[];

  /** Combined priority (primary + overlays) */
  totalPriority: number;
}

/**
 * Context for routing decisions
 */
export interface RoutingContext {
  /** Currently active module (user-facing) */
  activeModule: ModuleId | null;

  /** All registered modules */
  registeredModules: Map<ModuleId, ModuleVisualizationCapability>;

  /** All available devices */
  availableDevices: WLEDDevice[];

  /** Previous routing assignments (for change detection) */
  previousAssignments: DeviceAssignment[];
}

/**
 * Routing change event
 */
export interface RoutingChangeEvent {
  assignments: DeviceAssignment[];
  timestamp: number;
  trigger: 'module-change' | 'device-change' | 'manual';
}
```

### Phase 2: Compatibility Scoring Algorithm (1.5 hours)

**Implement Scoring System:**
```typescript
// src/services/VisualizationRoutingMatrix.ts
import { WLEDDevice, DeviceCapabilities } from '@/types/wled';
import {
  ModuleId,
  VisualizationProducer,
  VisualizationType,
} from '@/types/visualization';

export class VisualizationRoutingMatrix {
  /**
   * Calculate compatibility score for a module-device pair
   *
   * Scoring breakdown:
   * - Perfect dimension match: +100
   * - Can work with either: +50
   * - Device explicitly supports viz type: +50
   * - Module priority multiplier: √ópriority
   * - Active module bonus: +200
   */
  calculateCompatibility(
    producer: VisualizationProducer,
    device: WLEDDevice,
    isActiveModule: boolean = false
  ): number {
    let score = 0;

    // Dimension compatibility
    if (producer.dimensionPreference === device.capabilities.dimensions) {
      score += 100; // Perfect match
    } else if (producer.dimensionPreference === 'either') {
      score += 50; // Can adapt
    } else {
      // Incompatible dimensions (e.g., 2D viz on 1D device)
      return 0; // Skip this combination
    }

    // Device explicitly supports this visualization type
    if (
      device.capabilities.supportedVisualizations.includes(producer.type)
    ) {
      score += 50;
    }

    // Apply module priority multiplier
    score *= producer.priority;

    // Active module bonus (ensures active module gets best device)
    if (isActiveModule) {
      score += 200;
    }

    return score;
  }

  /**
   * Find best visualization type for a module-device pair
   * Returns highest-scoring producer from module's capabilities
   */
  private findBestProducer(
    moduleCapability: ModuleVisualizationCapability,
    device: WLEDDevice,
    isActiveModule: boolean
  ): { producer: VisualizationProducer; score: number } | null {
    let bestProducer: VisualizationProducer | null = null;
    let bestScore = 0;

    for (const producer of moduleCapability.produces) {
      const score = this.calculateCompatibility(
        producer,
        device,
        isActiveModule
      );

      if (score > bestScore) {
        bestScore = score;
        bestProducer = producer;
      }
    }

    if (!bestProducer) return null;

    return { producer: bestProducer, score: bestScore };
  }
}
```

### Phase 3: Routing Algorithm Implementation (2 hours)

**Implement Main Routing Logic:**
```typescript
export class VisualizationRoutingMatrix {
  private deviceRegistry: WLEDDeviceRegistry;
  private ledCompositor: LEDCompositor;
  private activeModule: ModuleId | null = null;
  private cachedAssignments: DeviceAssignment[] = [];
  private routingListeners: ((event: RoutingChangeEvent) => void)[] = [];

  constructor(
    deviceRegistry: WLEDDeviceRegistry,
    ledCompositor: LEDCompositor
  ) {
    this.deviceRegistry = deviceRegistry;
    this.ledCompositor = ledCompositor;

    // Subscribe to module changes
    // NOTE: LEDCompositor will emit events when modules register/unregister
    // (Implementation in Story 18.6)

    // Subscribe to device changes
    this.deviceRegistry.subscribeToDevices(() => {
      this.recalculateRouting();
    });
  }

  /**
   * Set the currently active module (user-facing)
   */
  setActiveModule(moduleId: ModuleId | null): void {
    if (this.activeModule !== moduleId) {
      this.activeModule = moduleId;
      this.recalculateRouting();
    }
  }

  /**
   * Main routing algorithm
   * Returns device assignments for all available devices
   */
  async routeVisualizations(): Promise<DeviceAssignment[]> {
    const devices = await this.deviceRegistry.getDevices();
    const moduleCapabilities = this.ledCompositor.getAllModuleCapabilities();

    if (devices.length === 0 || moduleCapabilities.length === 0) {
      console.log('[RoutingMatrix] No devices or modules available');
      return [];
    }

    const assignments: DeviceAssignment[] = [];

    // Step 1: Assign primary visualization for each device
    for (const device of devices) {
      if (!device.enabled) continue; // Skip disabled devices

      let bestModule: ModuleId | null = null;
      let bestProducer: VisualizationProducer | null = null;
      let bestScore = 0;

      // Find best module for this device
      for (const capability of moduleCapabilities) {
        // Skip overlay-only modules for primary assignment
        const nonOverlayProducers = capability.produces.filter(
          (p) => !p.overlayCompatible || capability.produces.length === 1
        );

        if (nonOverlayProducers.length === 0) continue;

        const isActive = capability.moduleId === this.activeModule;
        const result = this.findBestProducer(capability, device, isActive);

        if (result && result.score > bestScore) {
          bestScore = result.score;
          bestModule = capability.moduleId;
          bestProducer = result.producer;
        }
      }

      // No compatible module found - use fallback
      if (!bestModule || !bestProducer) {
        console.warn(
          `[RoutingMatrix] No compatible module for device: ${device.name}`
        );
        continue; // Skip this device
      }

      // Create assignment
      assignments.push({
        device,
        primary: {
          moduleId: bestModule,
          visualizationType: bestProducer.type,
          producer: bestProducer,
          compatibilityScore: bestScore,
        },
        overlays: [],
        totalPriority: bestProducer.priority,
      });
    }

    // Step 2: Add overlays to all assignments
    const assignmentsWithOverlays = this.detectOverlays(
      assignments,
      moduleCapabilities
    );

    return assignmentsWithOverlays;
  }

  /**
   * Detect and add overlay visualizations to all device assignments
   */
  private detectOverlays(
    assignments: DeviceAssignment[],
    moduleCapabilities: ModuleVisualizationCapability[]
  ): DeviceAssignment[] {
    // Find all overlay-compatible modules
    const overlayModules = moduleCapabilities.filter((capability) =>
      capability.produces.some((p) => p.overlayCompatible)
    );

    if (overlayModules.length === 0) return assignments;

    // Add overlays to each assignment
    return assignments.map((assignment) => {
      const overlays: DeviceAssignment['overlays'] = [];

      for (const overlayModule of overlayModules) {
        // Skip if this module is already the primary
        if (overlayModule.moduleId === assignment.primary.moduleId) continue;

        // Find overlay-compatible producer for this device
        const overlayProducers = overlayModule.produces.filter(
          (p) => p.overlayCompatible
        );

        for (const producer of overlayProducers) {
          const score = this.calculateCompatibility(
            producer,
            assignment.device,
            false
          );

          if (score > 0) {
            overlays.push({
              moduleId: overlayModule.moduleId,
              visualizationType: producer.type,
              producer,
            });
            break; // Only add one overlay type per module
          }
        }
      }

      // Sort overlays by priority (render in priority order)
      overlays.sort((a, b) => b.producer.priority - a.producer.priority);

      return {
        ...assignment,
        overlays,
        totalPriority:
          assignment.primary.producer.priority +
          overlays.reduce((sum, o) => sum + o.producer.priority, 0),
      };
    });
  }

  /**
   * Force recalculation of routing assignments
   */
  async recalculateRouting(): Promise<void> {
    console.log('[RoutingMatrix] Recalculating routing...');

    const newAssignments = await this.routeVisualizations();

    // Check if assignments changed
    const assignmentsChanged = this.hasAssignmentsChanged(
      this.cachedAssignments,
      newAssignments
    );

    if (assignmentsChanged) {
      this.cachedAssignments = newAssignments;

      // Emit change event
      const event: RoutingChangeEvent = {
        assignments: newAssignments,
        timestamp: Date.now(),
        trigger: 'manual',
      };

      this.routingListeners.forEach((listener) => listener(event));

      console.log(
        `[RoutingMatrix] Routing updated: ${newAssignments.length} assignments`
      );
      this.debugPrintRouting();
    }
  }

  /**
   * Check if routing assignments have changed
   */
  private hasAssignmentsChanged(
    oldAssignments: DeviceAssignment[],
    newAssignments: DeviceAssignment[]
  ): boolean {
    if (oldAssignments.length !== newAssignments.length) return true;

    for (let i = 0; i < oldAssignments.length; i++) {
      const oldA = oldAssignments[i];
      const newA = newAssignments[i];

      if (
        oldA.device.id !== newA.device.id ||
        oldA.primary.moduleId !== newA.primary.moduleId ||
        oldA.primary.visualizationType !== newA.primary.visualizationType ||
        oldA.overlays.length !== newA.overlays.length
      ) {
        return true;
      }
    }

    return false;
  }

  /**
   * Subscribe to routing changes
   */
  onRoutingChange(
    listener: (event: RoutingChangeEvent) => void
  ): () => void {
    this.routingListeners.push(listener);

    // Return unsubscribe function
    return () => {
      this.routingListeners = this.routingListeners.filter(
        (l) => l !== listener
      );
    };
  }

  /**
   * Get current routing assignments
   */
  getCurrentAssignments(): DeviceAssignment[] {
    return this.cachedAssignments;
  }

  /**
   * Debug: Print current routing table
   */
  debugPrintRouting(): void {
    console.log('[RoutingMatrix] Current Routing Table:');
    console.log('='.repeat(80));

    if (this.cachedAssignments.length === 0) {
      console.log('  No assignments');
      return;
    }

    this.cachedAssignments.forEach((assignment, index) => {
      console.log(`\n  Device ${index + 1}: ${assignment.device.name}`);
      console.log(`  ‚îî‚îÄ Primary: ${assignment.primary.moduleId}`);
      console.log(
        `     ‚îú‚îÄ Visualization: ${assignment.primary.visualizationType}`
      );
      console.log(
        `     ‚îú‚îÄ Score: ${assignment.primary.compatibilityScore}`
      );

      if (assignment.overlays.length > 0) {
        console.log(`     ‚îî‚îÄ Overlays:`);
        assignment.overlays.forEach((overlay, i) => {
          const prefix =
            i === assignment.overlays.length - 1 ? '        ‚îî‚îÄ' : '        ‚îú‚îÄ';
          console.log(
            `${prefix} ${overlay.moduleId}: ${overlay.visualizationType}`
          );
        });
      }
    });

    console.log('\n' + '='.repeat(80));
  }
}

// Singleton instance
export const routingMatrix = new VisualizationRoutingMatrix(
  wledDeviceRegistry,
  ledCompositor
);
```

### Phase 4: Integration and Testing (1.5 hours)

**GlobalMusicContext Integration:**
```typescript
// src/contexts/GlobalMusicContext.tsx
import { routingMatrix } from '@/services/VisualizationRoutingMatrix';

export const GlobalMusicProvider: React.FC<GlobalMusicProviderProps> = ({
  children,
}) => {
  const [routingAssignments, setRoutingAssignments] = useState<
    DeviceAssignment[]
  >([]);

  // Subscribe to routing changes
  useEffect(() => {
    const unsubscribe = routingMatrix.onRoutingChange((event) => {
      setRoutingAssignments(event.assignments);
      console.log('[GlobalMusicContext] Routing updated:', event);
    });

    // Initial routing calculation
    routingMatrix.recalculateRouting();

    return unsubscribe;
  }, []);

  // Track active module
  useEffect(() => {
    // This will be set based on which module is currently open
    // For now, assume activeModuleId is part of GlobalMusicState
    if (state.activeModuleId) {
      routingMatrix.setActiveModule(state.activeModuleId);
    }
  }, [state.activeModuleId]);

  // ... rest of context
};
```

---

## Dependencies

### Prerequisites
- ‚úÖ **Story 18.1 Complete:** WLED Device Registry (WLEDDevice type, device queries)
- ‚úÖ **Story 18.2 Complete:** Module Capability Declaration (capability introspection API)

### Blocks These Stories
- ‚è≥ **Story 18.4:** Routing Rules Engine (needs routing matrix as foundation)
- ‚è≥ **Story 18.5:** WLED Manager UI (needs routing status display)
- ‚è≥ **Story 18.6:** LEDCompositor Integration (needs routing assignments)

---

## Integration Points

- `src/services/WLEDDeviceRegistry.ts` - Query devices, subscribe to changes
- `src/services/LEDCompositor.ts` - Query module capabilities
- `src/services/VisualizationRoutingMatrix.ts` - NEW: Routing algorithm
- `src/types/visualization.ts` - EXTEND: Add DeviceAssignment, RoutingContext types
- `src/contexts/GlobalMusicContext.tsx` - ADD: routingAssignments state

---

## Testing Strategy

### Manual Verification Steps

**Test 1: Basic Routing (Single Module, Single Device)**
```typescript
// Setup
const device: WLEDDevice = {
  id: '1',
  name: 'Test Grid',
  ip: '192.168.1.100',
  capabilities: {
    dimensions: '2D',
    ledCount: 150,
    gridConfig: { width: 6, height: 25, serpentine: true, orientation: 'horizontal' },
    supportedVisualizations: ['step-sequencer-grid'],
  },
  // ... other fields
};

await wledDeviceRegistry.createDevice(device);
ledCompositor.registerModule(drumMachineCapability);

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify
console.log(assignments[0].primary.moduleId); // 'drum-machine'
console.log(assignments[0].primary.visualizationType); // 'step-sequencer-grid'
```

**Test 2: Compatibility Scoring**
```typescript
// DrumMachine + 6x25 Grid (perfect match)
const score1 = routingMatrix.calculateCompatibility(
  {
    type: 'step-sequencer-grid',
    dimensionPreference: '2D',
    overlayCompatible: false,
    priority: 10,
  },
  gridDevice2D,
  false
);
console.log('Score (2D + 2D, priority 10):', score1); // Expected: 1500

// DrumMachine + 1D Strip (dimension mismatch)
const score2 = routingMatrix.calculateCompatibility(
  {
    type: 'step-sequencer-grid',
    dimensionPreference: '2D',
    overlayCompatible: false,
    priority: 10,
  },
  stripDevice1D,
  false
);
console.log('Score (2D + 1D, incompatible):', score2); // Expected: 0

// Audio Reactive + Any Device ('either' preference)
const score3 = routingMatrix.calculateCompatibility(
  {
    type: 'midi-trigger-ripple',
    dimensionPreference: 'either',
    overlayCompatible: true,
    priority: 3,
  },
  gridDevice2D,
  false
);
console.log('Score (either + 2D, priority 3):', score3); // Expected: 150
```

**Test 3: Priority-Based Assignment (Multiple Modules, One Device)**
```typescript
// Setup: DrumMachine (priority 10) + PianoRoll (priority 10) + AudioReactive (priority 3)
ledCompositor.registerModule(drumMachineCapability);
ledCompositor.registerModule(pianoRollCapability);
ledCompositor.registerModule(audioReactiveCapability);

// One 2D grid device
await wledDeviceRegistry.createDevice(gridDevice2D);

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: DrumMachine should win (better dimension match for grid)
console.log(assignments[0].primary.moduleId); // 'drum-machine'
console.log(assignments[0].primary.visualizationType); // 'step-sequencer-grid'

// AudioReactive should be overlay
console.log(assignments[0].overlays.length); // 1
console.log(assignments[0].overlays[0].moduleId); // 'audio-reactive'
```

**Test 4: Active Module Bonus**
```typescript
// Setup: DrumMachine + PianoRoll competing for same device
ledCompositor.registerModule(drumMachineCapability);
ledCompositor.registerModule(pianoRollCapability);
await wledDeviceRegistry.createDevice(gridDevice2D);

// Set PianoRoll as active module
routingMatrix.setActiveModule('piano-roll');

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: PianoRoll wins (active module bonus +200 points)
console.log(assignments[0].primary.moduleId); // 'piano-roll'
```

**Test 5: Overlay Detection**
```typescript
// Setup: DrumMachine + AudioReactive
ledCompositor.registerModule(drumMachineCapability);
ledCompositor.registerModule(audioReactiveCapability);
await wledDeviceRegistry.createDevice(gridDevice2D);
await wledDeviceRegistry.createDevice(stripDevice1D);

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: Both devices have audio reactive overlay
assignments.forEach((assignment) => {
  console.log(`Device: ${assignment.device.name}`);
  console.log(`  Primary: ${assignment.primary.moduleId}`);
  console.log(`  Overlays:`, assignment.overlays.map((o) => o.moduleId));
  // Expected: Overlays include 'audio-reactive'
});
```

**Test 6: Automatic Recalculation**
```typescript
// Setup: Initial state with one device
await wledDeviceRegistry.createDevice(gridDevice2D);
ledCompositor.registerModule(drumMachineCapability);

let recalculationCount = 0;
routingMatrix.onRoutingChange(() => {
  recalculationCount++;
  console.log('Routing recalculated:', recalculationCount);
});

// Trigger 1: Add new device
await wledDeviceRegistry.createDevice(stripDevice1D);
// Expected: recalculationCount = 1

// Trigger 2: Register new module
ledCompositor.registerModule(pianoRollCapability);
// Expected: recalculationCount = 2 (Story 18.6 will implement this trigger)

// Trigger 3: Change active module
routingMatrix.setActiveModule('piano-roll');
// Expected: recalculationCount = 3
```

**Test 7: Fallback to Generic**
```typescript
// Setup: Module with no compatible devices
const incompatibleModule: ModuleVisualizationCapability = {
  moduleId: 'test-module',
  produces: [
    {
      type: 'fretboard-grid',
      dimensionPreference: '2D',
      overlayCompatible: false,
      priority: 10,
    },
  ],
};

ledCompositor.registerModule(incompatibleModule);
await wledDeviceRegistry.createDevice(stripDevice1D); // Only 1D device

// Execute
const assignments = await routingMatrix.routeVisualizations();

// Verify: No assignment (incompatible)
console.log(assignments.length); // Expected: 0 (or fallback to generic-color-array)
```

---

## Risks and Mitigation

### Risk 1: Routing Algorithm Performance
**Impact:** HIGH (blocking UI, missed frames)
**Mitigation:**
- Cache routing assignments (only recalculate on change)
- Debounce recalculation (avoid thrashing from rapid changes)
- Profile algorithm with 10+ devices, 10+ modules
- Target: <10ms for routing decision

### Risk 2: Incorrect Compatibility Scoring
**Impact:** HIGH (wrong devices assigned)
**Mitigation:**
- Comprehensive unit tests for scoring algorithm
- Test all dimension combinations (1D+1D, 1D+2D, 2D+2D, either+1D, either+2D)
- Manual verification with real hardware
- Debug logging shows score breakdown

### Risk 3: Overlay Priority Conflicts
**Impact:** MEDIUM (visual artifacts, unexpected overlays)
**Mitigation:**
- Clear overlay ordering rules (priority-based)
- Unit tests for overlay detection
- Visual testing with multiple overlay modules active
- Document overlay behavior in architecture doc

### Risk 4: Memory Leak from Event Listeners
**Impact:** MEDIUM (performance degradation over time)
**Mitigation:**
- Proper cleanup in unsubscribe functions
- Test: Add/remove 100 listeners, verify no leaks
- Use WeakMap for listener storage if needed

---

## Definition of Done

- [ ] `VisualizationRoutingMatrix` class created
- [ ] Compatibility scoring algorithm implemented
- [ ] Priority-based assignment working
- [ ] Overlay detection implemented
- [ ] Automatic recalculation on device/module changes
- [ ] Event-driven architecture (routing change events)
- [ ] Performance target met (<10ms routing decision)
- [ ] Unit tests for compatibility scoring (8+ scenarios)
- [ ] Integration tests for routing scenarios (7 test cases)
- [ ] Debug logging and `debugPrintRouting()` implemented
- [ ] Type-safe assignments (DeviceAssignment type)
- [ ] GlobalMusicContext integration
- [ ] No memory leaks from event listeners
- [ ] Documentation updated (architecture doc)

---

## Deliverables

1. **Routing Matrix Service**
   - `src/services/VisualizationRoutingMatrix.ts` (~400 lines)

2. **Type Definitions**
   - Modified: `src/types/visualization.ts` (+80 lines)
   - Add: DeviceAssignment, RoutingContext, RoutingChangeEvent

3. **Context Integration**
   - Modified: `src/contexts/GlobalMusicContext.tsx` (+40 lines)

4. **Unit Tests**
   - `src/services/__tests__/VisualizationRoutingMatrix.test.ts` (~300 lines)

5. **Documentation**
   - Updated: `docs/architecture/wled-visualization-routing.md` (routing algorithm details)

---

## Next Steps After Story 18.3

Once this story is complete, proceed to:
- **Story 18.4:** Context-Aware Routing Rules Engine - 4-5 hours
  - Now unblocked: Can extend routing matrix with rules
  - Implement built-in rules (Active Module Priority, Guitar Grid Exclusive, etc.)

---

## References

- **Epic 18:** `docs/epics/epic-18-intelligent-wled-routing.md`
- **Architecture:** `docs/architecture/wled-visualization-routing.md` (Layer 3: Visualization Routing Matrix)
- **Story 18.1:** WLED Device Registry
- **Story 18.2:** Module Capability Declaration

---

**Story Created:** 2025-10-18
**Story Owner:** Dev Agent
**Estimated Completion:** 5-6 hours after start

---

## Notes

### Design Decisions

**Why Compatibility Scoring Over Simple Matching?**
- Enables intelligent fallbacks (Piano Roll on 1D strip)
- Handles conflicting module priorities gracefully
- Extensible (future: user-defined scoring weights)
- Transparent (debug mode shows score breakdown)

**Why Cache Routing Assignments?**
- Avoid unnecessary recalculations (performance)
- Change detection enables granular event emission
- Enables "routing diff" visualization in future UI

**Why Event-Driven Architecture?**
- LEDCompositor can react to routing changes automatically
- UI components can subscribe to routing updates
- Decoupled (routing matrix doesn't know about consumers)

**Why Active Module Bonus (+200 points)?**
- Ensures user-facing module gets best device
- Prevents background modules from "stealing" primary device
- Aligns with user expectation (active module is most important)

### Future Enhancements

- User-defined scoring weights (via UI preferences)
- Machine learning model learns user's routing preferences
- Visual routing table in WLED Manager UI
- "Lock" device to specific module (manual override)
- Routing analytics (track which modules use which devices)

---

## Dev Agent Record

*To be completed during implementation*

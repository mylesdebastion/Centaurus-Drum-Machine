# Story 4.1: Global Music State Context

## Status
Ready for Review

## Story
**As a** system architect,
**I want** a centralized global music state context using React Context API,
**so that** all views can access shared musical configuration (tempo, key, scale, settings).

## Acceptance Criteria
1. Create `src/contexts/GlobalMusicContext.tsx` with state management
2. Define `GlobalMusicState` TypeScript interface:
   - `tempo: number` (BPM, default 120)
   - `key: RootNote` (musical root, default 'C')
   - `scale: ScaleName` (scale pattern, default 'major')
   - `colorMode: 'chromatic' | 'harmonic'` (visualization mode, default 'chromatic')
   - `masterVolume: number` (0-1, default 0.7)
3. Implement `useGlobalMusic()` hook for components
4. Integrate with existing `useMusicalScale` hook (wrap and extend it)
5. Add localStorage persistence with simple JSON schema
6. Wrap Router in App.tsx with `<GlobalMusicProvider>`

## Integration Verification
- **IV1**: Existing views continue working when provider added (no breaking changes)
- **IV2**: State changes in one view reflect in other mounted views instantly
- **IV3**: Settings persist across page refresh via localStorage

## Tasks / Subtasks

- [x] **Task 1: Create GlobalMusicContext Foundation** (AC: 1, 2)
  - [x] Create `src/contexts/` directory if not exists
  - [x] Create `src/contexts/GlobalMusicContext.tsx` file
  - [x] Define `GlobalMusicState` TypeScript interface
  - [x] Define action types for state updates
  - [x] Create React Context with createContext()
  - [x] Implement GlobalMusicProvider component with useState/useReducer
  - [x] Export context and provider

- [x] **Task 2: Implement useGlobalMusic Hook** (AC: 3)
  - [x] Create `useGlobalMusic()` custom hook
  - [x] Provide accessors for all state properties
  - [x] Provide setter functions (updateTempo, updateKey, updateScale, etc.)
  - [x] Add validation for state updates (BPM range 40-300, etc.)
  - [x] Add error handling for invalid state changes
  - [x] Export hook from context file

- [x] **Task 3: Integrate with useMusicalScale** (AC: 4)
  - [x] Import existing `useMusicalScale` hook
  - [x] Use `useMusicalScale` internally in GlobalMusicProvider
  - [x] Sync global state with useMusicalScale state
  - [x] Expose musical scale utilities through useGlobalMusic
  - [x] Ensure backward compatibility with existing useMusicalScale usage

- [x] **Task 4: Add localStorage Persistence** (AC: 5)
  - [x] Define localStorage schema version 1
  - [x] Implement `saveStateToLocalStorage()` utility
  - [x] Implement `loadStateFromLocalStorage()` utility
  - [x] Add useEffect to save state on changes (debounced)
  - [x] Add useEffect to load state on mount
  - [x] Handle localStorage errors gracefully (quotas, disabled, etc.)
  - [x] Add timestamp to saved state for debugging

- [x] **Task 5: Wrap App.tsx with Provider** (AC: 6)
  - [x] Update `src/App.tsx`
  - [x] Import GlobalMusicProvider
  - [x] Wrap Router with `<GlobalMusicProvider>`
  - [x] Verify no existing functionality breaks
  - [x] Test all routes still render correctly

- [x] **Task 6: Create Unit Tests**
  - [x] Test GlobalMusicProvider rendering
  - [x] Test useGlobalMusic hook accessors
  - [x] Test state update functions
  - [x] Test localStorage save/load
  - [x] Test state validation and error handling
  - [x] Test integration with useMusicalScale

- [x] **Task 7: Integration Testing** (IV: 1, 2, 3)
  - [x] Verify existing views unchanged (backward compatibility)
  - [x] Test state propagation across multiple views
  - [x] Test localStorage persistence across sessions
  - [x] Performance test state change latency (<50ms)
  - [x] Test with multiple browser tabs (state isolation)

## Dev Notes

### Relevant Architecture Context

**Existing Musical Scale System**:
- `src/hooks/useMusicalScale.ts` - Comprehensive scale/key management hook
- Already supports 14 scale patterns and 12 root notes
- Used by PianoRoll, GuitarFretboard, IsometricSequencer
- Should be wrapped/extended, not replaced

**React Context Best Practices**:
- Use Context for truly global state (avoid prop drilling)
- Keep context focused and domain-specific (music settings only)
- Memoize context value to prevent unnecessary re-renders
- Provide default values for SSR compatibility

**State Management Pattern**:
```typescript
interface GlobalMusicState {
  tempo: number;              // BPM (40-300)
  key: RootNote;              // C, C#, D, etc.
  scale: ScaleName;           // major, minor, dorian, etc.
  colorMode: 'chromatic' | 'harmonic';
  masterVolume: number;       // 0-1
  hardware: {
    midi: {
      inputDevice: string | null;
      outputDevice: string | null;
      connected: boolean;
    };
    wled: {
      devices: WLEDDevice[];
      activeDeviceId: string | null;
    };
  };
}
```

### localStorage Schema

```json
{
  "version": 1,
  "state": {
    "tempo": 120,
    "key": "C",
    "scale": "major",
    "colorMode": "chromatic",
    "masterVolume": 0.7,
    "hardware": {
      "midi": { "inputDevice": null, "outputDevice": null, "connected": false },
      "wled": { "devices": [], "activeDeviceId": null }
    }
  },
  "timestamp": "2025-01-11T10:30:00Z"
}
```

### Performance Considerations

- **Debounce localStorage saves**: 500ms debounce to avoid excessive writes
- **Memoize context value**: Use useMemo to prevent child re-renders
- **Selective updates**: Only update changed state properties
- **Target latency**: State changes propagate in <50ms (NFR9)

### Integration Strategy

**Phase 1** (This Story):
1. Create context and provider
2. Wrap App.tsx (non-breaking, passive)
3. No views consume it yet

**Phase 2** (Later Stories):
1. GlobalMusicHeader consumes context
2. Individual views migrate to global state
3. Remove redundant local state

### Testing

**Unit Tests** (`src/contexts/GlobalMusicContext.test.tsx`):
- Context provider renders without errors
- useGlobalMusic hook returns expected interface
- State updates work correctly
- localStorage save/load functions
- Validation catches invalid values

**Integration Tests**:
- Multiple components consuming context simultaneously
- State changes propagate to all consumers
- localStorage persists across browser sessions
- Performance benchmarks (state change latency)

**Testing Standards**:
- Use Vitest for unit tests
- Use React Testing Library for component tests
- Mock localStorage for deterministic tests
- Minimum 80% code coverage for context module

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-11 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929

### Debug Log References
None - Implementation completed without major debugging sessions

### Completion Notes List
- Created GlobalMusicContext with full TypeScript interfaces and React Context API
- Integrated useMusicalScale hook for musical scale utilities (key, scale, note calculations)
- Implemented localStorage persistence with 500ms debouncing for optimal performance
- Added comprehensive validation for tempo (40-300 BPM) and volume (0-1) ranges
- Wrapped App.tsx with GlobalMusicProvider - all routes now have access to global music state
- Created 29 comprehensive unit tests covering provider, hooks, state updates, localStorage, and musical scale integration
- Updated vitest configuration to include contexts tests
- All tests passing (29/29) with 100% coverage of implemented functionality
- Verified backward compatibility: 291 tests passed, existing functionality unchanged
- Dev server confirmed running successfully with provider integrated

### File List
**Created:**
- `src/contexts/GlobalMusicContext.tsx` - Main context implementation (386 lines)
- `src/contexts/__tests__/GlobalMusicContext.test.tsx` - Comprehensive test suite (495 lines)

**Modified:**
- `src/App.tsx` - Added GlobalMusicProvider wrapper around Routes
- `vite.config.ts` - Updated test configuration to include contexts tests

## QA Results
_To be populated by QA agent_

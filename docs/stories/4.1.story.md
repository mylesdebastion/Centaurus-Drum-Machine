# Story 4.1: Global Music State Context

## Status
In Progress

## Story
**As a** system architect,
**I want** a centralized global music state context using React Context API,
**so that** all views can access shared musical configuration (tempo, key, scale, settings).

## Acceptance Criteria
1. Create `src/contexts/GlobalMusicContext.tsx` with state management
2. Define `GlobalMusicState` TypeScript interface:
   - `tempo: number` (BPM, default 120)
   - `key: RootNote` (musical root, default 'C')
   - `scale: ScaleName` (scale pattern, default 'major')
   - `colorMode: 'chromatic' | 'harmonic'` (visualization mode, default 'chromatic')
   - `masterVolume: number` (0-1, default 0.7)
3. Implement `useGlobalMusic()` hook for components
4. Integrate with existing `useMusicalScale` hook (wrap and extend it)
5. Add localStorage persistence with simple JSON schema
6. Wrap Router in App.tsx with `<GlobalMusicProvider>`

## Integration Verification
- **IV1**: Existing views continue working when provider added (no breaking changes)
- **IV2**: State changes in one view reflect in other mounted views instantly
- **IV3**: Settings persist across page refresh via localStorage

## Tasks / Subtasks

- [ ] **Task 1: Create GlobalMusicContext Foundation** (AC: 1, 2)
  - [ ] Create `src/contexts/` directory if not exists
  - [ ] Create `src/contexts/GlobalMusicContext.tsx` file
  - [ ] Define `GlobalMusicState` TypeScript interface
  - [ ] Define action types for state updates
  - [ ] Create React Context with createContext()
  - [ ] Implement GlobalMusicProvider component with useState/useReducer
  - [ ] Export context and provider

- [ ] **Task 2: Implement useGlobalMusic Hook** (AC: 3)
  - [ ] Create `useGlobalMusic()` custom hook
  - [ ] Provide accessors for all state properties
  - [ ] Provide setter functions (updateTempo, updateKey, updateScale, etc.)
  - [ ] Add validation for state updates (BPM range 40-300, etc.)
  - [ ] Add error handling for invalid state changes
  - [ ] Export hook from context file

- [ ] **Task 3: Integrate with useMusicalScale** (AC: 4)
  - [ ] Import existing `useMusicalScale` hook
  - [ ] Use `useMusicalScale` internally in GlobalMusicProvider
  - [ ] Sync global state with useMusicalScale state
  - [ ] Expose musical scale utilities through useGlobalMusic
  - [ ] Ensure backward compatibility with existing useMusicalScale usage

- [ ] **Task 4: Add localStorage Persistence** (AC: 5)
  - [ ] Define localStorage schema version 1
  - [ ] Implement `saveStateToLocalStorage()` utility
  - [ ] Implement `loadStateFromLocalStorage()` utility
  - [ ] Add useEffect to save state on changes (debounced)
  - [ ] Add useEffect to load state on mount
  - [ ] Handle localStorage errors gracefully (quotas, disabled, etc.)
  - [ ] Add timestamp to saved state for debugging

- [ ] **Task 5: Wrap App.tsx with Provider** (AC: 6)
  - [ ] Update `src/App.tsx`
  - [ ] Import GlobalMusicProvider
  - [ ] Wrap Router with `<GlobalMusicProvider>`
  - [ ] Verify no existing functionality breaks
  - [ ] Test all routes still render correctly

- [ ] **Task 6: Create Unit Tests**
  - [ ] Test GlobalMusicProvider rendering
  - [ ] Test useGlobalMusic hook accessors
  - [ ] Test state update functions
  - [ ] Test localStorage save/load
  - [ ] Test state validation and error handling
  - [ ] Test integration with useMusicalScale

- [ ] **Task 7: Integration Testing** (IV: 1, 2, 3)
  - [ ] Verify existing views unchanged (backward compatibility)
  - [ ] Test state propagation across multiple views
  - [ ] Test localStorage persistence across sessions
  - [ ] Performance test state change latency (<50ms)
  - [ ] Test with multiple browser tabs (state isolation)

## Dev Notes

### Relevant Architecture Context

**Existing Musical Scale System**:
- `src/hooks/useMusicalScale.ts` - Comprehensive scale/key management hook
- Already supports 14 scale patterns and 12 root notes
- Used by PianoRoll, GuitarFretboard, IsometricSequencer
- Should be wrapped/extended, not replaced

**React Context Best Practices**:
- Use Context for truly global state (avoid prop drilling)
- Keep context focused and domain-specific (music settings only)
- Memoize context value to prevent unnecessary re-renders
- Provide default values for SSR compatibility

**State Management Pattern**:
```typescript
interface GlobalMusicState {
  tempo: number;              // BPM (40-300)
  key: RootNote;              // C, C#, D, etc.
  scale: ScaleName;           // major, minor, dorian, etc.
  colorMode: 'chromatic' | 'harmonic';
  masterVolume: number;       // 0-1
  hardware: {
    midi: {
      inputDevice: string | null;
      outputDevice: string | null;
      connected: boolean;
    };
    wled: {
      devices: WLEDDevice[];
      activeDeviceId: string | null;
    };
  };
}
```

### localStorage Schema

```json
{
  "version": 1,
  "state": {
    "tempo": 120,
    "key": "C",
    "scale": "major",
    "colorMode": "chromatic",
    "masterVolume": 0.7,
    "hardware": {
      "midi": { "inputDevice": null, "outputDevice": null, "connected": false },
      "wled": { "devices": [], "activeDeviceId": null }
    }
  },
  "timestamp": "2025-01-11T10:30:00Z"
}
```

### Performance Considerations

- **Debounce localStorage saves**: 500ms debounce to avoid excessive writes
- **Memoize context value**: Use useMemo to prevent child re-renders
- **Selective updates**: Only update changed state properties
- **Target latency**: State changes propagate in <50ms (NFR9)

### Integration Strategy

**Phase 1** (This Story):
1. Create context and provider
2. Wrap App.tsx (non-breaking, passive)
3. No views consume it yet

**Phase 2** (Later Stories):
1. GlobalMusicHeader consumes context
2. Individual views migrate to global state
3. Remove redundant local state

### Testing

**Unit Tests** (`src/contexts/GlobalMusicContext.test.tsx`):
- Context provider renders without errors
- useGlobalMusic hook returns expected interface
- State updates work correctly
- localStorage save/load functions
- Validation catches invalid values

**Integration Tests**:
- Multiple components consuming context simultaneously
- State changes propagate to all consumers
- localStorage persists across browser sessions
- Performance benchmarks (state change latency)

**Testing Standards**:
- Use Vitest for unit tests
- Use React Testing Library for component tests
- Mock localStorage for deterministic tests
- Minimum 80% code coverage for context module

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-11 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_

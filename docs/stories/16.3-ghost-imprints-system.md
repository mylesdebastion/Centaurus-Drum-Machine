# Story 16.3: Ghost Imprints System

## Status
In Progress

## Story
**As a** guitar player using the fretboard module,
**I want** to see faint persistent shadows from played/clicked frets that show where melodic paths lead,
**so that** I can discover melodic continuations even when not actively hovering.

## Acceptance Criteria
1. Clicked frets create faint shadows on harmonically related frets (ghost imprints)
2. Ghost brightness = 70% of full harmonic calculation (multiply by 0.7)
3. Multiple placed notes accumulate ghosts (brightest ghost wins at each position)
4. Ghosts persist for duration of note (2 seconds in current implementation via `clickedNotes` Set)
5. Ghosts visible even when not hovering over any fret
6. Performance: Ghost calculation skipped for cells already in temporal proximity (avoid redundant work)

## Tasks / Subtasks

- [ ] Implement ghost brightness calculation function (AC: 1, 2, 3)
  - [ ] Create `calculateGhostBrightness(string, fret, clickedNotes)` function
  - [ ] Loop through all notes in `clickedNotes` Set
  - [ ] For each placed note, calculate temporal proximity (same logic as Story 16.2)
  - [ ] If within temporal pattern, calculate harmonic brightness
  - [ ] Multiply by 0.7 for ghost effect
  - [ ] Track maximum ghost brightness across all placed notes

- [ ] Integrate ghost calculation into rendering loop (AC: 1, 4, 5)
  - [ ] Call `calculateGhostBrightness()` for each empty cell
  - [ ] Skip if cell already has temporal proximity highlighting (AC: 6)
  - [ ] Apply ghost brightness to cell border color
  - [ ] Ensure ghost brightness persists independently of hover state

- [ ] Optimize ghost calculation performance (AC: 6)
  - [ ] Early exit if `showHarmonicGuidance === false`
  - [ ] Early exit if cell has note placed (brightness = 1.0)
  - [ ] Early exit if cell in temporal proximity to hovered fret
  - [ ] Cache placed note MIDI pitches (avoid recalculating per frame)

- [ ] Update visual rendering priority (AC: 5)
  - [ ] Priority 1: Placed notes (brightness = 1.0, background + white border)
  - [ ] Priority 2: Temporal proximity (bright colored border)
  - [ ] Priority 3: Ghost imprints (faint colored border, 70% brightness)
  - [ ] Priority 4: Base brightness (very dim colored border, 0.4)

- [ ] Handle ghost persistence with note duration (AC: 4)
  - [ ] Existing `clickedNotes` Set persists for 2 seconds
  - [ ] Ghost calculation automatically uses this Set
  - [ ] Verify ghosts disappear when notes removed from Set

## Dev Notes

### Relevant Source Tree
- **GuitarFretboard**: `src/components/GuitarFretboard/GuitarFretboard.tsx`
- **FretboardCanvas**: `src/components/GuitarFretboard/FretboardCanvas.tsx`
- **MelodySequencer Reference**: `src/components/Studio/modules/ChordMelodyArranger/MelodySequencer.tsx` (lines 933-983 for ghost imprint logic)

### Ghost Imprints Concept

**Definition**: Faint brightness echoes left by placed notes that persist even when not hovering.

**Purpose**:
1. **Persistent Guidance**: User sees multiple melodic paths at once without hovering
2. **Composition Memory**: Grid "remembers" where placed notes suggest going next
3. **Path Discovery**: User discovers new melodic routes by seeing faint suggestions
4. **Musical Intuition**: Mimics how composers mentally hear "where the melody wants to go"

**Visual Characteristics**:
- **70% brightness**: Faint enough to not overpower, bright enough to guide
- **Max accumulation**: If multiple notes suggest same cell, brightest wins
- **Full harmonic calculation**: Ghost uses same music theory as interactive highlighting
- **Diagonal pattern**: Ghost follows same temporal offset rules

### Implementation Algorithm

```typescript
function calculateGhostBrightness(
  string: number,
  fret: number,
  clickedNotes: Set<number>, // Set of MIDI note numbers
  currentTuningMIDI: number[]
): number {
  let maxGhostBrightness = 0;

  const currentPitch = getMIDINoteFromFret(string, fret, currentTuningMIDI);

  // For each placed note, check if current cell is on its melodic path
  for (const placedMidiNote of clickedNotes) {
    // Find which string/fret this placed note is on
    // (Need to reverse-lookup from MIDI note to fret position)
    const placedFretPosition = findFretPositionForMidi(placedMidiNote, currentTuningMIDI);
    if (!placedFretPosition) continue;

    const pitchDistance = Math.abs(currentPitch - placedMidiNote);

    // Calculate expected fret offset (same logic as temporal proximity)
    let expectedFretOffset = 0;
    if (pitchDistance >= 6) expectedFretOffset = 2;
    else if (pitchDistance >= 3) expectedFretOffset = 1;

    // Bidirectional support
    const isAscending = currentPitch > placedMidiNote;
    const fretOffset = isAscending ? expectedFretOffset : -expectedFretOffset;
    const expectedFret = placedFretPosition.fret + fretOffset;

    // Check if current fret is within tolerance (±1 fret)
    const isTemporallyClose = Math.abs(fret - expectedFret) <= 1;

    if (isTemporallyClose) {
      // Calculate full harmonic brightness
      const harmonicBrightness = melodyService.calculateNoteBrightness(
        currentPitch,
        0, // Use step 0 (strong beat)
        currentChord,
        scaleNotes,
        settings,
        placedMidiNote, // Pass placed note pitch for interval adjustments
        false // Not a placed note
      );

      // Apply ghost effect (70% brightness)
      const ghostBrightness = harmonicBrightness * 0.7;

      // Track maximum (if multiple placed notes suggest this cell)
      maxGhostBrightness = Math.max(maxGhostBrightness, ghostBrightness);
    }
  }

  return maxGhostBrightness;
}

// Helper function to find fret position for a given MIDI note
function findFretPositionForMidi(
  midiNote: number,
  currentTuningMIDI: number[]
): { string: number; fret: number } | null {
  // Check each string
  for (let string = 0; string < 6; string++) {
    const openStringMidi = currentTuningMIDI[string];
    const fret = midiNote - openStringMidi;

    // Valid fret range: 0-24
    if (fret >= 0 && fret <= 24) {
      return { string, fret };
    }
  }

  return null; // MIDI note not playable on this tuning
}
```

### Visual Rendering Priority Logic

```typescript
function calculateFinalBrightness(
  string: number,
  fret: number,
  isPlacedNote: boolean,
  showHarmonicGuidance: boolean,
  hoveredFret: { string: number; fret: number } | null,
  clickedNotes: Set<number>
): number {
  // Priority 1: Placed notes (always full brightness)
  if (isPlacedNote) {
    return 1.0;
  }

  // Priority 2: Temporal proximity (interactive highlighting)
  if (showHarmonicGuidance && hoveredFret) {
    const temporalBrightness = calculateTemporalProximityBrightness(
      string,
      fret,
      hoveredFret
    );
    if (temporalBrightness !== null) {
      return temporalBrightness;
    }
  }

  // Priority 3: Ghost imprints (persistent faint shadows)
  if (showHarmonicGuidance && clickedNotes.size > 0) {
    const ghostBrightness = calculateGhostBrightness(
      string,
      fret,
      clickedNotes,
      currentTuningMIDI
    );
    if (ghostBrightness > 0) {
      return ghostBrightness;
    }
  }

  // Priority 4: Base harmonic brightness (always visible when guidance enabled)
  if (showHarmonicGuidance) {
    return melodyService.calculateNoteBrightness(
      getMIDINoteFromFret(string, fret, currentTuningMIDI),
      0,
      currentChord,
      scaleNotes,
      settings,
      null,
      false
    ) * 0.4; // Dim base brightness
  }

  // Fallback: Default brightness (in-scale: 0.65, out-of-scale: 0.2)
  const currentPitch = getMIDINoteFromFret(string, fret, currentTuningMIDI);
  const noteClass = currentPitch % 12;
  const isInScale = scaleNotes.some(n => (n % 12) === noteClass);
  return isInScale ? 0.65 : 0.2;
}
```

### Performance Optimization Strategy

**Problem**: Calculating ghost brightness for 150 cells (6 strings × 25 frets) per frame could be expensive if `clickedNotes` has many notes.

**Solution**: Multi-level early exits
1. **Check if guidance enabled**: `if (!showHarmonicGuidance) return 0;`
2. **Check if cell is placed note**: `if (isPlacedNote) return 1.0;`
3. **Check if cell in temporal proximity**: `if (temporalBrightness !== null) skip ghost calc`
4. **Check if any notes clicked**: `if (clickedNotes.size === 0) return 0;`
5. **Cache placed note positions**: Build map once per frame, not per cell

**Caching Strategy**:
```typescript
// Build cache at start of render loop
const placedNotePositions = useMemo(() => {
  const positions: Array<{ string: number; fret: number; midiNote: number }> = [];
  for (const midiNote of clickedNotes) {
    const pos = findFretPositionForMidi(midiNote, currentTuningMIDI);
    if (pos) {
      positions.push({ ...pos, midiNote });
    }
  }
  return positions;
}, [clickedNotes, currentTuningMIDI]);

// Use cached positions in ghost calculation
function calculateGhostBrightness(
  string: number,
  fret: number,
  placedNotePositions: Array<{ string: number; fret: number; midiNote: number }>
): number {
  let maxGhostBrightness = 0;

  for (const placedNote of placedNotePositions) {
    // ... ghost calculation logic ...
  }

  return maxGhostBrightness;
}
```

### Testing
**Manual Verification Steps**:

1. **Ghost Appearance**:
   - Click fret on String 3, Fret 5
   - Verify faint shadows appear on harmonically related frets
   - Shadows should follow diagonal stagger pattern (same as temporal proximity)
   - Verify ghost brightness is visibly dimmer than hover highlighting

2. **Ghost Persistence**:
   - Click fret
   - Move mouse away (no hover)
   - Verify ghosts persist for 2 seconds
   - After 2 seconds, verify ghosts disappear (note removed from `clickedNotes`)

3. **Ghost Accumulation**:
   - Click multiple frets (e.g., String 3 Fret 5, String 3 Fret 7, String 2 Fret 5)
   - Verify overlapping ghost suggestions accumulate (brightest wins)
   - Verify each placed note creates its own ghost pattern

4. **Visual Priority**:
   - Click fret (creates ghost)
   - Hover over different fret (creates temporal proximity highlighting)
   - Verify temporal proximity is brighter than ghosts
   - Verify placed note has full brightness background

5. **Performance**:
   - Click 10+ frets rapidly
   - Verify frame rate stays at 60 FPS
   - Check Chrome DevTools Performance tab for "Long Task" warnings

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-15 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*To be filled by QA agent*

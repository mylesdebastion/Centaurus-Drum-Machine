# Story 18.6: LEDCompositor Integration & Module Migration

**Epic:** Epic 18 - Intelligent WLED Visualization Routing
**Status:** ðŸ“ PLANNING
**Priority:** ðŸŸ¡ MEDIUM
**Complexity:** High
**Time Estimate:** 5-6 hours
**Prerequisites:** Stories 18.1-18.5 (Complete routing system + UI)

---

## User Story

As a **module developer integrating with the routing system**,
I want **automatic visualization routing when I submit LED frames**,
So that **my module's visualizations automatically appear on appropriate devices without manual device management**.

---

## Story Context

### Why This Story

**System Integration:** Story 18.6 integrates the routing matrix with the existing LEDCompositor, completing the automatic routing system and demonstrating the end-to-end workflow with a real module.

**Current State:**
- âœ… Routing matrix calculates assignments (Story 18.3)
- âœ… Routing rules applied (Story 18.4)
- âœ… WLED Manager UI working (Story 18.5)
- âŒ LEDCompositor doesn't use routing assignments
- âŒ Modules manually manage device selection
- âŒ No automatic frame routing on submitFrame()
- âŒ No overlay blending implementation

**Desired State (Story 18.6):**
- âœ… `LEDCompositor.submitFrame()` automatically routes frames to correct devices
- âœ… Overlay blending algorithm implemented (additive composition)
- âœ… DrumMachine migrated to use automatic routing
- âœ… Module registration pattern documented
- âœ… Zero breaking changes to existing modules (backward compatible)

**Integration Flow:**

```typescript
// Module registers capabilities on mount
useEffect(() => {
  ledCompositor.registerModule(drumMachineCapability);
  return () => ledCompositor.unregisterModule('drum-machine');
}, []);

// Module submits frame (no device specified)
const frame = generateDrumMachineFrame(pattern, activeStep);
ledCompositor.submitFrame({
  moduleId: 'drum-machine',
  pixelData: frame,
});

// LEDCompositor automatically:
// 1. Gets routing assignments from RoutingMatrix
// 2. Finds assignment for 'drum-machine'
// 3. Converts frame to device-specific format
// 4. Blends overlays (e.g., audio reactive)
// 5. Sends to WLED device(s)
```

---

## Acceptance Criteria

### Functional Requirements

1. **LEDCompositor Routing Integration**
   - Extend `LEDCompositor.submitFrame()` to use routing assignments:
     ```typescript
     class LEDCompositor {
       // NEW: Submit frame without specifying device
       async submitFrame(frame: ModuleFrameInput): Promise<void>;

       // Internal: Route frame to appropriate devices
       private async routeFrame(frame: ModuleFrameInput): Promise<void>;

       // Internal: Blend overlays onto primary frame
       private blendOverlays(
         primaryFrame: Uint8ClampedArray,
         overlays: OverlayFrame[]
       ): Uint8ClampedArray;
     }

     interface ModuleFrameInput {
       moduleId: ModuleId;
       pixelData: Uint8ClampedArray; // RGB bytes (generic format)
       timestamp?: number;
     }
     ```

2. **Automatic Device Assignment**
   - On `submitFrame()`:
     - Query routing matrix for current assignments
     - Find assignments where module is primary or overlay
     - Convert frame to device-specific format (1D strip vs 2D grid)
     - Send to all assigned devices

3. **Frame Format Conversion**
   - Generic frame â†’ Device-specific frame:
     ```typescript
     // Example: DrumMachine submits 6 tracks Ã— 16 steps
     const genericFrame = new Uint8ClampedArray(6 * 16 * 3); // RGB
     // ... populate frame ...

     // Routing Matrix assigns to 6x25 grid device
     // Convert: Map 6x16 pattern to 6x25 grid (center align, pad with black)

     // Routing Matrix also assigns to 90-LED strip device
     // Convert: Map 6 tracks to 90 LEDs (15 LEDs per track)
     ```

4. **Overlay Blending Algorithm**
   - Additive blending (default):
     ```typescript
     blendedColor = min(255, primaryColor + overlayColor);
     ```
   - Applied per-pixel for RGB channels
   - Multiple overlays: Blend in priority order (highest first)
   - Example:
     ```typescript
     // Primary: DrumMachine step sequencer (blue notes)
     // Overlay 1: AudioReactive ripple (white flash)
     // Result: Blue notes + white flash = cyan highlights
     ```

5. **DrumMachine Migration**
   - Update `DrumMachine.tsx` to:
     - Register capabilities on mount
     - Submit frames via `LEDCompositor.submitFrame()`
     - Remove manual device selection code
     - Preserve existing functionality (no breaking changes)

6. **Backward Compatibility**
   - Modules that don't register capabilities still work
   - Fallback: Use `generic-color-array` visualization type
   - Existing WLED device manager integration preserved
   - No breaking changes to LEDCompositor API

### Integration Requirements

7. **Module Registration Pattern**
   - Standard pattern for all modules:
     ```typescript
     import { ledCompositor } from '@/services/LEDCompositor';
     import { drumMachineCapability } from '@/capabilities/drumMachineCapability';

     export const DrumMachine: React.FC = () => {
       useEffect(() => {
         ledCompositor.registerModule(drumMachineCapability);
         return () => ledCompositor.unregisterModule('drum-machine');
       }, []);

       // ... rest of component
     };
     ```

8. **Routing Matrix Subscription**
   - LEDCompositor subscribes to routing changes
   - Recalculate frame distribution when routing changes
   - No frames sent to disabled devices
   - Handle device connection errors gracefully

9. **Frame Rate Optimization**
   - Maintain 60 FPS target (16ms budget)
   - Frame routing adds <2ms overhead
   - Batch frame submissions if multiple modules active
   - Skip frame conversion if no devices assigned

### Quality Requirements

10. **Performance**
    - Frame submission latency: <2ms (routing + conversion)
    - Overlay blending: <1ms per device
    - No dropped frames at 60 FPS
    - Memory usage: <100MB increase for overlay buffers

11. **Error Handling**
    - Module not registered: Log warning, use fallback
    - No routing assignment: Skip frame (log once)
    - Device connection error: Retry 3 times, then disable device
    - Invalid pixel data: Log error, skip frame

12. **Debugging Support**
    - `debugPrintFrameRouting()` - Shows frame â†’ device mapping
    - Console logs for frame submissions
    - Overlay blend visualization (debug mode)
    - Performance metrics (frame routing time)

---

## Technical Approach

### Phase 1: LEDCompositor Integration (2 hours)

**Extend LEDCompositor:**
```typescript
// src/services/LEDCompositor.ts (extend existing class)
import { routingMatrix } from './VisualizationRoutingMatrix';
import { ModuleId } from '@/types/visualization';

export interface ModuleFrameInput {
  moduleId: ModuleId;
  pixelData: Uint8ClampedArray; // Generic RGB format
  timestamp?: number;
}

interface OverlayFrame {
  moduleId: ModuleId;
  pixelData: Uint8ClampedArray;
}

export class LEDCompositor {
  // ... existing fields ...
  private frameCache: Map<ModuleId, Uint8ClampedArray> = new Map();

  /**
   * Submit LED frame for automatic routing
   * Frame will be routed to appropriate devices based on current assignments
   */
  async submitFrame(frame: ModuleFrameInput): Promise<void> {
    // Validate frame
    if (!frame.pixelData || frame.pixelData.length === 0) {
      console.warn(`[LEDCompositor] Empty frame from ${frame.moduleId}`);
      return;
    }

    // Cache frame for this module (used for overlays)
    this.frameCache.set(frame.moduleId, frame.pixelData);

    // Route frame to devices
    await this.routeFrame(frame);
  }

  /**
   * Route frame to appropriate devices based on current assignments
   */
  private async routeFrame(frame: ModuleFrameInput): Promise<void> {
    const startTime = performance.now();

    // Get current routing assignments
    const assignments = routingMatrix.getCurrentAssignments();

    if (assignments.length === 0) {
      console.log(
        `[LEDCompositor] No routing assignments for ${frame.moduleId}`
      );
      return;
    }

    // Find assignments where this module is primary
    const primaryAssignments = assignments.filter(
      (a) => a.primary.moduleId === frame.moduleId
    );

    // Process each assignment
    for (const assignment of primaryAssignments) {
      try {
        // Convert frame to device-specific format
        const deviceFrame = this.convertFrameToDevice(
          frame.pixelData,
          assignment.device,
          assignment.primary.visualizationType
        );

        // Collect overlay frames
        const overlayFrames: OverlayFrame[] = [];
        for (const overlay of assignment.overlays) {
          const cachedFrame = this.frameCache.get(overlay.moduleId);
          if (cachedFrame) {
            const overlayDeviceFrame = this.convertFrameToDevice(
              cachedFrame,
              assignment.device,
              overlay.visualizationType
            );
            overlayFrames.push({
              moduleId: overlay.moduleId,
              pixelData: overlayDeviceFrame,
            });
          }
        }

        // Blend overlays onto primary frame
        const blendedFrame = this.blendOverlays(deviceFrame, overlayFrames);

        // Send to WLED device
        await this.sendToWLED(assignment.device, blendedFrame);
      } catch (error) {
        console.error(
          `[LEDCompositor] Error routing frame to ${assignment.device.name}:`,
          error
        );
      }
    }

    const duration = performance.now() - startTime;
    if (duration > 2) {
      console.warn(
        `[LEDCompositor] Frame routing took ${duration.toFixed(2)}ms (target: <2ms)`
      );
    }
  }

  /**
   * Convert generic frame to device-specific format
   */
  private convertFrameToDevice(
    genericFrame: Uint8ClampedArray,
    device: WLEDDevice,
    visualizationType: VisualizationType
  ): Uint8ClampedArray {
    const deviceLedCount =
      device.capabilities.dimensions === '1D'
        ? device.capabilities.ledCount
        : (device.capabilities.gridConfig?.width || 0) *
          (device.capabilities.gridConfig?.height || 0);

    const deviceFrame = new Uint8ClampedArray(deviceLedCount * 3);

    // Different conversion logic based on visualization type
    switch (visualizationType) {
      case 'step-sequencer-grid':
        // Map generic frame to 2D grid
        this.convertToGrid(genericFrame, deviceFrame, device);
        break;

      case 'step-sequencer-1d':
        // Map generic frame to 1D strip
        this.convertTo1DStrip(genericFrame, deviceFrame, device);
        break;

      case 'piano-keys':
        // Map piano keys to 1D strip
        this.convertPianoKeysTo1D(genericFrame, deviceFrame, device);
        break;

      case 'fretboard-grid':
        // Map fretboard to 2D grid
        this.convertFretboardToGrid(genericFrame, deviceFrame, device);
        break;

      case 'midi-trigger-ripple':
        // Generic ripple effect (works on 1D or 2D)
        this.convertRipple(genericFrame, deviceFrame, device);
        break;

      case 'generic-color-array':
      default:
        // Direct copy (or scale if size mismatch)
        this.convertGeneric(genericFrame, deviceFrame);
        break;
    }

    // Apply device settings (brightness, reverse direction)
    this.applyDeviceSettings(deviceFrame, device);

    return deviceFrame;
  }

  /**
   * Convert step sequencer pattern to 2D grid
   * Generic frame: 6 tracks Ã— 16 steps
   * Device: 6 rows Ã— 25 columns (example)
   */
  private convertToGrid(
    genericFrame: Uint8ClampedArray,
    deviceFrame: Uint8ClampedArray,
    device: WLEDDevice
  ): void {
    const gridConfig = device.capabilities.gridConfig;
    if (!gridConfig) return;

    const genericWidth = 16; // Assume 16 steps
    const genericHeight = 6; // Assume 6 tracks
    const deviceWidth = gridConfig.width;
    const deviceHeight = gridConfig.height;

    // Center align pattern on grid
    const offsetX = Math.floor((deviceWidth - genericWidth) / 2);
    const offsetY = Math.floor((deviceHeight - genericHeight) / 2);

    for (let y = 0; y < genericHeight; y++) {
      for (let x = 0; x < genericWidth; x++) {
        const genericIndex = (y * genericWidth + x) * 3;
        const deviceX = offsetX + x;
        const deviceY = offsetY + y;

        if (
          deviceX >= 0 &&
          deviceX < deviceWidth &&
          deviceY >= 0 &&
          deviceY < deviceHeight
        ) {
          const deviceIndex = (deviceY * deviceWidth + deviceX) * 3;
          deviceFrame[deviceIndex] = genericFrame[genericIndex]; // R
          deviceFrame[deviceIndex + 1] = genericFrame[genericIndex + 1]; // G
          deviceFrame[deviceIndex + 2] = genericFrame[genericIndex + 2]; // B
        }
      }
    }

    // Apply serpentine wiring if needed
    if (gridConfig.serpentine) {
      this.applySerpentine(deviceFrame, gridConfig);
    }
  }

  /**
   * Convert step sequencer pattern to 1D strip
   * Generic frame: 6 tracks Ã— 16 steps
   * Device: 90 LEDs (example: 15 LEDs per track)
   */
  private convertTo1DStrip(
    genericFrame: Uint8ClampedArray,
    deviceFrame: Uint8ClampedArray,
    device: WLEDDevice
  ): void {
    const ledCount = device.capabilities.ledCount;
    const tracks = 6;
    const ledsPerTrack = Math.floor(ledCount / tracks);

    for (let track = 0; track < tracks; track++) {
      const trackStartGeneric = track * 16 * 3; // 16 steps per track
      const trackStartDevice = track * ledsPerTrack * 3;

      // Copy first N steps to device LEDs
      for (let i = 0; i < Math.min(16, ledsPerTrack); i++) {
        const srcIndex = trackStartGeneric + i * 3;
        const dstIndex = trackStartDevice + i * 3;

        if (dstIndex + 2 < deviceFrame.length) {
          deviceFrame[dstIndex] = genericFrame[srcIndex]; // R
          deviceFrame[dstIndex + 1] = genericFrame[srcIndex + 1]; // G
          deviceFrame[dstIndex + 2] = genericFrame[srcIndex + 2]; // B
        }
      }
    }
  }

  /**
   * Apply serpentine wiring (every other row reversed)
   */
  private applySerpentine(
    frame: Uint8ClampedArray,
    gridConfig: { width: number; height: number }
  ): void {
    const { width, height } = gridConfig;

    for (let y = 1; y < height; y += 2) {
      // Reverse odd rows
      const rowStart = y * width * 3;
      const rowEnd = rowStart + width * 3;
      const rowData = frame.slice(rowStart, rowEnd);

      for (let x = 0; x < width; x++) {
        const srcIndex = (width - 1 - x) * 3;
        const dstIndex = rowStart + x * 3;
        frame[dstIndex] = rowData[srcIndex];
        frame[dstIndex + 1] = rowData[srcIndex + 1];
        frame[dstIndex + 2] = rowData[srcIndex + 2];
      }
    }
  }

  /**
   * Apply device settings (brightness, reverse direction)
   */
  private applyDeviceSettings(
    frame: Uint8ClampedArray,
    device: WLEDDevice
  ): void {
    const brightnessScale = device.brightness / 255;

    for (let i = 0; i < frame.length; i++) {
      frame[i] = Math.floor(frame[i] * brightnessScale);
    }

    if (device.reverse_direction) {
      const reversed = new Uint8ClampedArray(frame.length);
      const pixelCount = frame.length / 3;

      for (let i = 0; i < pixelCount; i++) {
        const srcIndex = (pixelCount - 1 - i) * 3;
        const dstIndex = i * 3;
        reversed[dstIndex] = frame[srcIndex];
        reversed[dstIndex + 1] = frame[srcIndex + 1];
        reversed[dstIndex + 2] = frame[srcIndex + 2];
      }

      frame.set(reversed);
    }
  }

  /**
   * Blend overlay frames onto primary frame (additive composition)
   */
  private blendOverlays(
    primaryFrame: Uint8ClampedArray,
    overlays: OverlayFrame[]
  ): Uint8ClampedArray {
    if (overlays.length === 0) return primaryFrame;

    const blended = new Uint8ClampedArray(primaryFrame);

    for (const overlay of overlays) {
      for (let i = 0; i < blended.length; i++) {
        // Additive blending (clamped to 255)
        blended[i] = Math.min(255, blended[i] + overlay.pixelData[i]);
      }
    }

    return blended;
  }

  /**
   * Send frame to WLED device via HTTP
   */
  private async sendToWLED(
    device: WLEDDevice,
    frame: Uint8ClampedArray
  ): Promise<void> {
    // Convert RGB array to hex color array
    const hexColors: string[] = [];
    for (let i = 0; i < frame.length; i += 3) {
      const r = frame[i].toString(16).padStart(2, '0');
      const g = frame[i + 1].toString(16).padStart(2, '0');
      const b = frame[i + 2].toString(16).padStart(2, '0');
      hexColors.push(r + g + b);
    }

    // WLED JSON API endpoint
    const url = `http://${device.ip}/json/state`;
    const payload = {
      on: true,
      bri: device.brightness,
      seg: [
        {
          i: hexColors, // Individual LED colors
        },
      ],
    };

    try {
      await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        signal: AbortSignal.timeout(1000), // 1 second timeout
      });
    } catch (error) {
      console.error(`[LEDCompositor] Failed to send frame to ${device.name}:`, error);
      throw error;
    }
  }

  /**
   * Placeholder converters (implement as needed)
   */
  private convertPianoKeysTo1D(
    genericFrame: Uint8ClampedArray,
    deviceFrame: Uint8ClampedArray,
    device: WLEDDevice
  ): void {
    // TODO: Map 88 piano keys to device LED count
    this.convertGeneric(genericFrame, deviceFrame);
  }

  private convertFretboardToGrid(
    genericFrame: Uint8ClampedArray,
    deviceFrame: Uint8ClampedArray,
    device: WLEDDevice
  ): void {
    // TODO: Map 6 strings Ã— N frets to grid
    this.convertToGrid(genericFrame, deviceFrame, device);
  }

  private convertRipple(
    genericFrame: Uint8ClampedArray,
    deviceFrame: Uint8ClampedArray,
    device: WLEDDevice
  ): void {
    // TODO: Implement ripple effect
    this.convertGeneric(genericFrame, deviceFrame);
  }

  private convertGeneric(
    genericFrame: Uint8ClampedArray,
    deviceFrame: Uint8ClampedArray
  ): void {
    // Direct copy or scale if size mismatch
    const scale = deviceFrame.length / genericFrame.length;

    if (scale === 1) {
      deviceFrame.set(genericFrame);
    } else {
      // Simple scaling (nearest neighbor)
      for (let i = 0; i < deviceFrame.length; i += 3) {
        const srcIndex = Math.floor((i / deviceFrame.length) * genericFrame.length);
        deviceFrame[i] = genericFrame[srcIndex];
        deviceFrame[i + 1] = genericFrame[srcIndex + 1];
        deviceFrame[i + 2] = genericFrame[srcIndex + 2];
      }
    }
  }

  /**
   * Debug: Print frame routing table
   */
  debugPrintFrameRouting(): void {
    const assignments = routingMatrix.getCurrentAssignments();

    console.log('[LEDCompositor] Frame Routing Table:');
    console.log('='.repeat(80));

    assignments.forEach((assignment, index) => {
      console.log(`\n  Device ${index + 1}: ${assignment.device.name}`);
      console.log(`  â””â”€ Primary: ${assignment.primary.moduleId}`);
      console.log(`     â””â”€ Visualization: ${assignment.primary.visualizationType}`);

      if (assignment.overlays.length > 0) {
        console.log(`     â””â”€ Overlays:`);
        assignment.overlays.forEach((overlay) => {
          console.log(`        â””â”€ ${overlay.moduleId}: ${overlay.visualizationType}`);
        });
      }
    });

    console.log('\n' + '='.repeat(80));
  }
}
```

### Phase 2: DrumMachine Migration (2 hours)

**Update DrumMachine Component:**
```typescript
// src/components/DrumMachine/DrumMachine.tsx
import { ledCompositor } from '@/services/LEDCompositor';
import { drumMachineCapability } from '@/capabilities/drumMachineCapability';

export const DrumMachine: React.FC = () => {
  // ... existing state ...

  // NEW: Register module capability
  useEffect(() => {
    ledCompositor.registerModule(drumMachineCapability);
    console.log('[DrumMachine] Module registered with LEDCompositor');

    return () => {
      ledCompositor.unregisterModule('drum-machine');
      console.log('[DrumMachine] Module unregistered from LEDCompositor');
    };
  }, []);

  // MODIFIED: Submit frames via LEDCompositor
  useEffect(() => {
    if (!isPlaying) return;

    const interval = setInterval(() => {
      // Generate visualization frame
      const frame = generateDrumMachineFrame(pattern, currentStep);

      // Submit to LEDCompositor (automatic routing)
      ledCompositor.submitFrame({
        moduleId: 'drum-machine',
        pixelData: frame,
        timestamp: Date.now(),
      });

      // Update current step
      setCurrentStep((prev) => (prev + 1) % 16);
    }, (60000 / tempo) / 4); // 16th note interval

    return () => clearInterval(interval);
  }, [isPlaying, pattern, currentStep, tempo]);

  // ... rest of component (unchanged)
};

/**
 * Generate LED frame from drum machine pattern
 * Format: 6 tracks Ã— 16 steps (RGB)
 */
function generateDrumMachineFrame(
  pattern: DrumPattern,
  activeStep: number
): Uint8ClampedArray {
  const frame = new Uint8ClampedArray(6 * 16 * 3); // 6 tracks, 16 steps, RGB

  for (let track = 0; track < 6; track++) {
    for (let step = 0; step < 16; step++) {
      const index = (track * 16 + step) * 3;
      const isActive = pattern[track][step];
      const isCurrentStep = step === activeStep;

      if (isCurrentStep && isActive) {
        // Active step (white)
        frame[index] = 255;
        frame[index + 1] = 255;
        frame[index + 2] = 255;
      } else if (isCurrentStep) {
        // Current step, no note (dim white)
        frame[index] = 50;
        frame[index + 1] = 50;
        frame[index + 2] = 50;
      } else if (isActive) {
        // Note (blue)
        frame[index] = 0;
        frame[index + 1] = 100;
        frame[index + 2] = 255;
      } else {
        // Empty (black)
        frame[index] = 0;
        frame[index + 1] = 0;
        frame[index + 2] = 0;
      }
    }
  }

  return frame;
}
```

### Phase 3: Testing and Documentation (1.5 hours)

**Integration Test Scenario:**
```typescript
// Test: DrumMachine + AudioReactive + 2 Devices

// Setup devices
await wledDeviceRegistry.createDevice({
  name: 'Fretboard Grid',
  ip: '192.168.1.100',
  capabilities: {
    dimensions: '2D',
    ledCount: 150,
    gridConfig: { width: 6, height: 25, serpentine: true, orientation: 'horizontal' },
    supportedVisualizations: ['step-sequencer-grid'],
  },
});

await wledDeviceRegistry.createDevice({
  name: 'Stage Strip',
  ip: '192.168.1.101',
  capabilities: {
    dimensions: '1D',
    ledCount: 90,
    supportedVisualizations: ['step-sequencer-1d'],
  },
});

// Register modules
ledCompositor.registerModule(drumMachineCapability);
ledCompositor.registerModule(audioReactiveCapability);

// Set active module
routingMatrix.setActiveModule('drum-machine');

// Submit frame
const drumFrame = generateDrumMachineFrame(pattern, 0);
await ledCompositor.submitFrame({
  moduleId: 'drum-machine',
  pixelData: drumFrame,
});

// Verify:
// 1. Grid device shows step-sequencer-grid visualization
// 2. Strip device shows step-sequencer-1d visualization
// 3. Both devices have audio-reactive overlay (if AudioReactive submits frames)
// 4. Frame conversion correct (6x16 â†’ 6x25 grid, 6x16 â†’ 90 LEDs strip)
// 5. HTTP requests sent to both WLED devices
```

---

## Dependencies

### Prerequisites
- âœ… **Story 18.1-18.5 Complete:** Full routing system + UI

### Blocks These Stories
- â³ **Story 18.7:** Multi-Module Testing & Documentation (needs working integration)

---

## Integration Points

- `src/services/LEDCompositor.ts` - EXTEND: Add routing integration
- `src/components/DrumMachine/DrumMachine.tsx` - MODIFY: Use automatic routing
- `src/services/VisualizationRoutingMatrix.ts` - Query routing assignments
- `src/capabilities/drumMachineCapability.ts` - Used for registration

---

## Testing Strategy

### Manual Verification Steps

**Test 1: Basic Frame Routing (Single Module, Single Device)**
```typescript
// Setup
await wledDeviceRegistry.createDevice(gridDevice2D);
ledCompositor.registerModule(drumMachineCapability);

// Submit frame
const frame = generateDrumMachineFrame(testPattern, 0);
await ledCompositor.submitFrame({
  moduleId: 'drum-machine',
  pixelData: frame,
});

// Verify: HTTP request sent to device (check Network tab)
// Expected: POST http://192.168.1.100/json/state
```

**Test 2: Overlay Blending**
```typescript
// Setup
await wledDeviceRegistry.createDevice(gridDevice2D);
ledCompositor.registerModule(drumMachineCapability);
ledCompositor.registerModule(audioReactiveCapability);

// Submit frames
const drumFrame = generateDrumMachineFrame(testPattern, 0);
const audioFrame = generateAudioReactiveFrame(rippleState);

await ledCompositor.submitFrame({ moduleId: 'drum-machine', pixelData: drumFrame });
await ledCompositor.submitFrame({ moduleId: 'audio-reactive', pixelData: audioFrame });

// Verify: Blended frame sent to device (drum colors + audio ripple)
```

**Test 3: Multi-Device Routing**
```typescript
// Setup
await wledDeviceRegistry.createDevice(gridDevice2D);
await wledDeviceRegistry.createDevice(stripDevice1D);
ledCompositor.registerModule(drumMachineCapability);

// Submit frame
await ledCompositor.submitFrame({ moduleId: 'drum-machine', pixelData: drumFrame });

// Verify: Two HTTP requests sent (one to grid, one to strip)
// Expected: Grid shows 6x25 pattern, Strip shows 90 LEDs linear
```

**Test 4: DrumMachine End-to-End**
1. Open `/drum-machine`
2. Configure WLED devices (via `/wled-manager`)
3. Start playback
4. Verify LEDs update in real-time
5. Change pattern
6. Verify LED visualization updates

**Test 5: Performance (60 FPS)**
```typescript
// Submit 60 frames per second
for (let i = 0; i < 60; i++) {
  const start = performance.now();

  await ledCompositor.submitFrame({
    moduleId: 'drum-machine',
    pixelData: generateDrumMachineFrame(pattern, i % 16),
  });

  const duration = performance.now() - start;
  console.log(`Frame ${i}: ${duration.toFixed(2)}ms`);
  // Expected: <2ms per frame
}
```

---

## Risks and Mitigation

### Risk 1: Frame Routing Performance
**Impact:** CRITICAL (dropped frames, stuttering)
**Mitigation:**
- Profile frame routing path
- Optimize conversion algorithms
- Cache device frame buffers
- Target: <2ms per submitFrame()

### Risk 2: Overlay Blending Artifacts
**Impact:** MEDIUM (visual glitches)
**Mitigation:**
- Test blending with various color combinations
- Visual verification with real hardware
- Adjust blend mode if needed (additive vs multiply)

### Risk 3: Breaking Existing Modules
**Impact:** HIGH (regression)
**Mitigation:**
- Backward compatibility (modules without capabilities still work)
- Thorough testing of existing modules
- Fallback to generic-color-array

### Risk 4: Device Connection Errors
**Impact:** MEDIUM (frames not displayed)
**Mitigation:**
- Retry logic (3 attempts)
- Disable device on repeated failures
- User-friendly error messages in UI

---

## Definition of Done

- [ ] `LEDCompositor.submitFrame()` extended with routing integration
- [ ] Frame format conversion implemented (grid, 1D strip, piano keys)
- [ ] Overlay blending algorithm implemented
- [ ] Device settings applied (brightness, reverse direction)
- [ ] Serpentine wiring support implemented
- [ ] DrumMachine migrated to use automatic routing
- [ ] Module registration pattern documented
- [ ] Integration tests passing (4 scenarios)
- [ ] Performance target met (<2ms frame routing)
- [ ] No breaking changes to existing modules
- [ ] Error handling tested (connection errors, invalid frames)
- [ ] Debug logging implemented (`debugPrintFrameRouting`)
- [ ] Documentation updated (integration guide for modules)

---

## Deliverables

1. **LEDCompositor Extension**
   - Modified: `src/services/LEDCompositor.ts` (+600 lines)

2. **DrumMachine Migration**
   - Modified: `src/components/DrumMachine/DrumMachine.tsx` (+50 lines)

3. **Integration Tests**
   - `src/services/__tests__/LEDCompositor.integration.test.ts` (~250 lines)

4. **Documentation**
   - New: `docs/guides/module-led-integration.md` (module developer guide)
   - Updated: `docs/architecture/wled-visualization-routing.md` (LEDCompositor integration)

---

## Next Steps After Story 18.6

Once this story is complete, proceed to:
- **Story 18.7:** Multi-Module Testing & Documentation - 3-4 hours
  - Comprehensive testing with multiple modules active
  - Video demo of automatic routing
  - Final architecture documentation

---

## References

- **Epic 18:** `docs/epics/epic-18-intelligent-wled-routing.md`
- **Architecture:** `docs/architecture/wled-visualization-routing.md`
- **Epic 14:** Module Adapter System (LEDCompositor foundation)

---

**Story Created:** 2025-10-18
**Story Owner:** Dev Agent
**Estimated Completion:** 5-6 hours after start

---

## Notes

### Design Decisions

**Why Additive Blending?**
- Natural for overlay effects (ripples, flashes)
- Intuitive (brightness increases with overlays)
- Fast to compute (simple addition)
- Can switch to other modes if needed (multiply, screen)

**Why Frame Cache?**
- Overlays need primary frame
- Avoid re-generating frames
- Memory overhead minimal (<10MB for typical usage)

**Why Generic Frame Format?**
- Modules don't know about devices
- Enables automatic conversion
- Extensible (add new device types without changing modules)

**Why Backward Compatible?**
- Existing modules continue working
- Gradual migration path
- No big-bang refactor

### Future Enhancements

- Custom blend modes (multiply, screen, overlay)
- Per-overlay intensity controls
- Frame interpolation (smooth transitions)
- GPU-accelerated conversion (WebGL)
- Compression for network efficiency

---

## Dev Agent Record

*To be completed during implementation*

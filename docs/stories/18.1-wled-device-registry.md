# Story 18.1: WLED Device Registry (Supabase Backend)

**Epic:** Epic 18 - Intelligent WLED Visualization Routing
**Status:** üìù PLANNING
**Priority:** üî¥ HIGH
**Complexity:** Medium
**Time Estimate:** 4-5 hours
**Prerequisites:** Story 18.0 (User Authentication MVP)

---

## User Story

As a **user with multiple WLED devices**,
I want **my LED hardware configurations stored in the cloud**,
So that **my devices are accessible from any browser/device (iPad, Desktop) without re-configuration**.

---

## Story Context

### Why This Story

**Foundation for Intelligent Routing:** Story 18.1 creates the persistent device registry that enables automatic visualization routing in subsequent stories.

**Current State:**
- ‚úÖ `WLEDDeviceManager` stores devices in localStorage (per-browser only)
- ‚ùå Devices not shared across sessions (iPad vs Desktop)
- ‚ùå No device capability metadata (1D vs 2D, grid config, etc.)
- ‚ùå No real-time sync when devices added/removed

**Desired State (Story 18.1):**
- ‚úÖ Devices stored in Supabase `wled_devices` table (cloud-backed)
- ‚úÖ Devices accessible from all browsers/devices for same user
- ‚úÖ Real-time sync via Supabase Realtime (device added on desktop ‚Üí appears on iPad)
- ‚úÖ Rich capability metadata (dimensions, LED count, grid config, supported visualizations)
- ‚úÖ Row Level Security (users only see their own devices)

**Integration with Epic 18:**
- Story 18.2 uses device capabilities to match modules
- Story 18.3 uses device registry for routing decisions
- Story 18.5 uses device registry for WLED Manager UI

---

## Acceptance Criteria

### Functional Requirements

1. **Supabase Database Table**
   - `wled_devices` table created with schema:
     ```sql
     CREATE TABLE wled_devices (
       id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
       user_id UUID REFERENCES auth.users NOT NULL,
       name TEXT NOT NULL,
       ip TEXT NOT NULL,
       capabilities JSONB NOT NULL,
       location TEXT,
       priority INTEGER DEFAULT 0,
       enabled BOOLEAN DEFAULT true,
       brightness INTEGER DEFAULT 204,
       reverse_direction BOOLEAN DEFAULT false,
       created_at TIMESTAMPTZ DEFAULT NOW(),
       updated_at TIMESTAMPTZ DEFAULT NOW()
     );
     ```
   - RLS policies enforce user-specific access (auth.uid() = user_id)

2. **Device Capabilities Schema**
   - JSONB field stores rich capability metadata:
     ```typescript
     interface DeviceCapabilities {
       dimensions: '1D' | '2D';
       ledCount: number;
       gridConfig?: {
         width: number;
         height: number;
         serpentine: boolean;
         orientation: 'horizontal' | 'vertical';
       };
       supportedVisualizations: VisualizationType[];
     }
     ```

3. **WLEDDeviceRegistry Service**
   - Create `src/services/WLEDDeviceRegistry.ts` with CRUD operations:
     ```typescript
     class WLEDDeviceRegistry {
       async createDevice(device: WLEDDeviceInput): Promise<WLEDDevice>;
       async updateDevice(id: string, updates: Partial<WLEDDevice>): Promise<void>;
       async deleteDevice(id: string): Promise<void>;
       async getDevices(): Promise<WLEDDevice[]>;
       async getDevice(id: string): Promise<WLEDDevice | null>;

       // Realtime subscription
       subscribeToDevices(callback: (devices: WLEDDevice[]) => void): () => void;
     }
     ```

4. **Realtime Synchronization**
   - Supabase Realtime subscription for device changes
   - When device added/updated/deleted ‚Üí callback fires on all clients
   - Optimistic UI updates (update UI immediately, sync with DB in background)

5. **Migration from localStorage**
   - Detect existing devices in localStorage (from old `WLEDDeviceManager`)
   - One-time migration: Import localStorage devices to Supabase on first auth
   - Preserve device names, IPs, and basic settings
   - Add default capability metadata based on LED count

6. **Connection Testing**
   - `testConnection(deviceId: string): Promise<boolean>` method
   - HTTP request to `http://<device-ip>/json/info` (WLED API)
   - Parse response to detect LED count, firmware version
   - Auto-populate capability metadata from WLED response

### Integration Requirements

7. **TypeScript Type Definitions**
   - Create `src/types/wled.ts` with interfaces:
     ```typescript
     interface WLEDDevice {
       id: string;
       user_id: string;
       name: string;
       ip: string;
       capabilities: DeviceCapabilities;
       location?: string;
       priority: number;
       enabled: boolean;
       brightness: number;
       reverse_direction: boolean;
       created_at: string;
       updated_at: string;
     }

     type VisualizationType =
       | 'piano-keys'
       | 'step-sequencer-1d'
       | 'step-sequencer-grid'
       | 'fretboard-grid'
       | 'midi-trigger-ripple'
       | 'audio-spectrum'
       | 'note-trigger-flash'
       | 'generic-color-array';
     ```

8. **GlobalMusicContext Integration**
   - Add `wledDevices: WLEDDevice[]` to GlobalMusicState
   - Add `updateWLEDDevices` method (replace existing localStorage-based method)
   - Subscribe to device changes on context mount
   - Sync active device ID with Supabase

9. **Error Handling**
   - Network errors: Retry with exponential backoff
   - RLS violations: User-friendly "Access Denied" messages
   - Offline support: Queue mutations, sync when reconnected
   - Conflict resolution: Last-write-wins for simplicity (MVP)

### Quality Requirements

10. **Row Level Security (RLS)**
    - Users can only SELECT their own devices (auth.uid() = user_id)
    - Users can only INSERT devices with their own user_id
    - Users can only UPDATE/DELETE their own devices
    - Anonymous users cannot access wled_devices table

11. **Performance**
    - Device list query: <200ms (Supabase Realtime)
    - Device creation: <500ms (optimistic UI)
    - Realtime sync latency: <200ms (Supabase)
    - Offline mutation queue: No blocking UI

12. **Data Validation**
    - IP address format validation (IPv4)
    - LED count > 0
    - Brightness: 0-255
    - Device name: 1-50 characters
    - Grid width/height > 0 (if 2D)

---

## Technical Approach

### Phase 1: Database Schema and RLS (1 hour)

**Create Migration:**
```sql
-- Migration: create_wled_devices_table.sql
CREATE TABLE wled_devices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users NOT NULL,
  name TEXT NOT NULL CHECK (char_length(name) BETWEEN 1 AND 50),
  ip TEXT NOT NULL CHECK (ip ~ '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'),
  capabilities JSONB NOT NULL DEFAULT '{"dimensions": "1D", "ledCount": 0, "supportedVisualizations": []}'::jsonb,
  location TEXT,
  priority INTEGER DEFAULT 0,
  enabled BOOLEAN DEFAULT true,
  brightness INTEGER DEFAULT 204 CHECK (brightness BETWEEN 0 AND 255),
  reverse_direction BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create index for user_id lookups (performance optimization)
CREATE INDEX idx_wled_devices_user_id ON wled_devices(user_id);

-- Enable Row Level Security
ALTER TABLE wled_devices ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view own devices"
  ON wled_devices FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own devices"
  ON wled_devices FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own devices"
  ON wled_devices FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own devices"
  ON wled_devices FOR DELETE
  USING (auth.uid() = user_id);

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_wled_devices_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER wled_devices_updated_at
  BEFORE UPDATE ON wled_devices
  FOR EACH ROW
  EXECUTE FUNCTION update_wled_devices_updated_at();

-- Enable Realtime for wled_devices table
ALTER PUBLICATION supabase_realtime ADD TABLE wled_devices;
```

### Phase 2: Type Definitions (30 minutes)

**Create TypeScript Interfaces:**
```typescript
// src/types/wled.ts
export type VisualizationType =
  | 'piano-keys'
  | 'step-sequencer-1d'
  | 'step-sequencer-grid'
  | 'fretboard-grid'
  | 'midi-trigger-ripple'
  | 'audio-spectrum'
  | 'note-trigger-flash'
  | 'generic-color-array';

export interface GridConfig {
  width: number;
  height: number;
  serpentine: boolean;
  orientation: 'horizontal' | 'vertical';
}

export interface DeviceCapabilities {
  dimensions: '1D' | '2D';
  ledCount: number;
  gridConfig?: GridConfig;
  supportedVisualizations: VisualizationType[];
}

export interface WLEDDevice {
  id: string;
  user_id: string;
  name: string;
  ip: string;
  capabilities: DeviceCapabilities;
  location?: string;
  priority: number;
  enabled: boolean;
  brightness: number;
  reverse_direction: boolean;
  created_at: string;
  updated_at: string;
}

export interface WLEDDeviceInput {
  name: string;
  ip: string;
  capabilities: DeviceCapabilities;
  location?: string;
  priority?: number;
  brightness?: number;
  reverse_direction?: boolean;
}

// WLED API response type (for connection testing)
export interface WLEDInfoResponse {
  ver: string;            // Firmware version
  vid: number;            // Version ID
  leds: {
    count: number;        // Total LED count
    rgbw: boolean;        // RGBW mode
    wv: boolean;          // White value
    cct: boolean;         // CCT mode
    seglock: boolean;     // Segment lock
  };
  name: string;           // Device name
  udpport: number;        // UDP port
  live: boolean;          // Live mode
  // ... (additional fields)
}
```

### Phase 3: WLEDDeviceRegistry Service (2 hours)

**Create Service:**
```typescript
// src/services/WLEDDeviceRegistry.ts
import { supabase } from '@/lib/supabase';
import { WLEDDevice, WLEDDeviceInput, WLEDInfoResponse } from '@/types/wled';
import { RealtimeChannel } from '@supabase/supabase-js';

export class WLEDDeviceRegistry {
  private channel: RealtimeChannel | null = null;
  private callbacks: ((devices: WLEDDevice[]) => void)[] = [];

  /**
   * Fetch all devices for authenticated user
   */
  async getDevices(): Promise<WLEDDevice[]> {
    const { data, error } = await supabase
      .from('wled_devices')
      .select('*')
      .order('created_at', { ascending: true });

    if (error) {
      console.error('[WLEDDeviceRegistry] Error fetching devices:', error);
      throw error;
    }

    return data || [];
  }

  /**
   * Get single device by ID
   */
  async getDevice(id: string): Promise<WLEDDevice | null> {
    const { data, error } = await supabase
      .from('wled_devices')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null; // Not found
      console.error('[WLEDDeviceRegistry] Error fetching device:', error);
      throw error;
    }

    return data;
  }

  /**
   * Create new WLED device
   */
  async createDevice(input: WLEDDeviceInput): Promise<WLEDDevice> {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Must be authenticated to create devices');

    const { data, error } = await supabase
      .from('wled_devices')
      .insert({
        user_id: user.id,
        name: input.name,
        ip: input.ip,
        capabilities: input.capabilities,
        location: input.location,
        priority: input.priority ?? 0,
        brightness: input.brightness ?? 204,
        reverse_direction: input.reverse_direction ?? false,
      })
      .select()
      .single();

    if (error) {
      console.error('[WLEDDeviceRegistry] Error creating device:', error);
      throw error;
    }

    console.log('[WLEDDeviceRegistry] Device created:', data);
    return data;
  }

  /**
   * Update existing device
   */
  async updateDevice(id: string, updates: Partial<WLEDDeviceInput>): Promise<void> {
    const { error } = await supabase
      .from('wled_devices')
      .update(updates)
      .eq('id', id);

    if (error) {
      console.error('[WLEDDeviceRegistry] Error updating device:', error);
      throw error;
    }

    console.log('[WLEDDeviceRegistry] Device updated:', id);
  }

  /**
   * Delete device
   */
  async deleteDevice(id: string): Promise<void> {
    const { error } = await supabase
      .from('wled_devices')
      .delete()
      .eq('id', id);

    if (error) {
      console.error('[WLEDDeviceRegistry] Error deleting device:', error);
      throw error;
    }

    console.log('[WLEDDeviceRegistry] Device deleted:', id);
  }

  /**
   * Test connection to WLED device
   * Fetches /json/info endpoint and returns device info
   */
  async testConnection(ip: string): Promise<WLEDInfoResponse> {
    try {
      const response = await fetch(`http://${ip}/json/info`, {
        method: 'GET',
        headers: { 'Accept': 'application/json' },
        signal: AbortSignal.timeout(5000), // 5 second timeout
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data: WLEDInfoResponse = await response.json();
      return data;
    } catch (error) {
      console.error('[WLEDDeviceRegistry] Connection test failed:', error);
      throw error;
    }
  }

  /**
   * Auto-detect device capabilities from WLED /json/info
   */
  async detectCapabilities(ip: string): Promise<Partial<DeviceCapabilities>> {
    const info = await this.testConnection(ip);

    return {
      dimensions: '1D', // Default to 1D, user can change to 2D
      ledCount: info.leds.count,
      supportedVisualizations: ['generic-color-array'], // Default, user can add more
    };
  }

  /**
   * Subscribe to real-time device changes
   * Returns unsubscribe function
   */
  subscribeToDevices(callback: (devices: WLEDDevice[]) => void): () => void {
    this.callbacks.push(callback);

    // Create Realtime channel if not exists
    if (!this.channel) {
      this.channel = supabase.channel('wled-devices-changes');

      this.channel
        .on(
          'postgres_changes',
          {
            event: '*', // INSERT, UPDATE, DELETE
            schema: 'public',
            table: 'wled_devices',
          },
          async (payload) => {
            console.log('[WLEDDeviceRegistry] Realtime change:', payload);

            // Re-fetch all devices and notify callbacks
            const devices = await this.getDevices();
            this.callbacks.forEach((cb) => cb(devices));
          }
        )
        .subscribe();
    }

    // Return unsubscribe function
    return () => {
      this.callbacks = this.callbacks.filter((cb) => cb !== callback);

      // Cleanup channel if no more subscribers
      if (this.callbacks.length === 0 && this.channel) {
        this.channel.unsubscribe();
        this.channel = null;
      }
    };
  }

  /**
   * Migrate devices from localStorage to Supabase (one-time migration)
   */
  async migrateFromLocalStorage(): Promise<void> {
    try {
      const localDevices = localStorage.getItem('wled-devices');
      if (!localDevices) return;

      const devices = JSON.parse(localDevices);
      console.log('[WLEDDeviceRegistry] Migrating devices from localStorage:', devices);

      for (const device of devices) {
        await this.createDevice({
          name: device.name || 'Migrated Device',
          ip: device.ip,
          capabilities: {
            dimensions: '1D',
            ledCount: device.ledCount || 100,
            supportedVisualizations: ['generic-color-array'],
          },
          brightness: device.brightness,
        });
      }

      // Clear localStorage after successful migration
      localStorage.removeItem('wled-devices');
      console.log('[WLEDDeviceRegistry] Migration complete');
    } catch (error) {
      console.error('[WLEDDeviceRegistry] Migration failed:', error);
    }
  }
}

// Singleton instance
export const wledDeviceRegistry = new WLEDDeviceRegistry();
```

### Phase 4: Integration and Testing (1 hour)

**GlobalMusicContext Integration:**
```typescript
// src/contexts/GlobalMusicContext.tsx
import { wledDeviceRegistry } from '@/services/WLEDDeviceRegistry';

export const GlobalMusicProvider: React.FC<GlobalMusicProviderProps> = ({ children }) => {
  const [wledDevices, setWledDevices] = useState<WLEDDevice[]>([]);
  const auth = useAuth();

  // Subscribe to device changes when authenticated
  useEffect(() => {
    if (!auth.isAuthenticated) return;

    // Initial load
    wledDeviceRegistry.getDevices().then(setWledDevices);

    // Realtime subscription
    const unsubscribe = wledDeviceRegistry.subscribeToDevices(setWledDevices);

    // One-time migration from localStorage
    wledDeviceRegistry.migrateFromLocalStorage();

    return unsubscribe;
  }, [auth.isAuthenticated]);

  // ... rest of context
};
```

---

## Dependencies

### Prerequisites
- ‚úÖ **Story 18.0 Complete:** User authentication (auth.uid() available)
- ‚úÖ **Story 7.1 Complete:** Supabase client configured

### Blocks These Stories
- ‚è≥ **Story 18.2:** Module Capability Declaration (needs device capabilities schema)
- ‚è≥ **Story 18.3:** Visualization Routing Matrix (needs device registry)
- ‚è≥ **Story 18.5:** WLED Manager UI (needs CRUD operations)

---

## Integration Points

- `src/lib/supabase.ts` - Existing Supabase client
- `src/hooks/useAuth.ts` - User authentication state (Story 18.0)
- `src/contexts/GlobalMusicContext.tsx` - ADD: wledDevices state
- `src/services/WLEDDeviceRegistry.ts` - NEW: Device registry service
- `src/types/wled.ts` - NEW: Type definitions
- Database: `wled_devices` table + RLS policies

---

## Testing Strategy

### Manual Verification Steps

**Test 1: Database Schema and RLS**
```sql
-- As authenticated User A
SELECT * FROM wled_devices;
-- Expected: Only User A's devices

-- As User B (different user_id)
SELECT * FROM wled_devices;
-- Expected: Only User B's devices (RLS enforces isolation)

-- As anonymous user
SELECT * FROM wled_devices;
-- Expected: 0 rows (RLS blocks anonymous access)
```

**Test 2: CRUD Operations**
1. Sign in as User A
2. Create device:
   ```typescript
   await wledDeviceRegistry.createDevice({
     name: 'Test Strip',
     ip: '192.168.1.100',
     capabilities: {
       dimensions: '1D',
       ledCount: 144,
       supportedVisualizations: ['generic-color-array'],
     },
   });
   ```
3. Verify device appears in Supabase dashboard
4. Verify device appears in app UI
5. Update device name
6. Verify change reflected in UI
7. Delete device
8. Verify removed from UI

**Test 3: Realtime Sync (Multi-Device)**
1. Open app on Desktop (User A signed in)
2. Open app on iPad (User A signed in)
3. Desktop: Add new device
4. iPad: Verify device appears within 200ms (Realtime subscription)
5. iPad: Update device brightness
6. Desktop: Verify brightness change reflected

**Test 4: Connection Testing**
```typescript
// Test with real WLED device
const info = await wledDeviceRegistry.testConnection('192.168.1.100');
console.log('LED Count:', info.leds.count);
console.log('Firmware:', info.ver);

// Test with invalid IP (should throw error)
try {
  await wledDeviceRegistry.testConnection('192.168.1.999');
} catch (error) {
  console.log('Expected error:', error.message);
}
```

**Test 5: localStorage Migration**
1. Sign out (clear Supabase session)
2. Add devices via old WLEDDeviceManager (localStorage)
3. Verify localStorage key `'wled-devices'` populated
4. Sign in (create account)
5. Verify devices auto-migrated to Supabase
6. Verify localStorage key cleared after migration

**Test 6: Offline Support**
1. Sign in, load devices
2. Disconnect network (DevTools ‚Üí Network ‚Üí Offline)
3. Create new device (should queue mutation)
4. Verify optimistic UI update (device appears immediately)
5. Reconnect network
6. Verify mutation synced to Supabase
7. Verify device persisted

---

## Risks and Mitigation

### Risk 1: RLS Policy Bugs (User Can Access Other Users' Devices)
**Impact:** CRITICAL (data leak)
**Mitigation:**
- Comprehensive RLS testing with multiple user accounts
- Integration test: User A creates device, User B attempts access (should fail)
- Code review RLS policies before merging

### Risk 2: Realtime Subscription Memory Leak
**Impact:** MEDIUM (performance degradation)
**Mitigation:**
- Proper cleanup in unsubscribe function
- Test: Create/destroy subscription 100 times, check memory usage
- Use WeakMap for callbacks if needed

### Risk 3: Migration Overwrites Existing Devices
**Impact:** MEDIUM (duplicate devices)
**Mitigation:**
- Check if user already has devices before migration
- Migration runs only once (localStorage cleared after success)
- User can manually delete duplicates if needed

---

## Definition of Done

- [ ] `wled_devices` table created in Supabase
- [ ] RLS policies implemented and tested
- [ ] `WLEDDeviceRegistry` service created
- [ ] CRUD operations working (create, read, update, delete)
- [ ] Realtime subscription working (device changes sync across clients)
- [ ] Connection testing working (HTTP /json/info endpoint)
- [ ] Capability auto-detection working
- [ ] localStorage migration working
- [ ] TypeScript types defined (`src/types/wled.ts`)
- [ ] GlobalMusicContext integrated
- [ ] RLS tested with multiple users (User A cannot see User B's devices)
- [ ] Realtime sync tested (Desktop ‚Üí iPad within 200ms)
- [ ] Offline support tested (optimistic UI updates)
- [ ] Error handling tested (network errors, invalid IPs)
- [ ] Documentation updated

---

## Deliverables

1. **Database Migration**
   - `supabase/migrations/003_wled_devices.sql` (~100 lines)

2. **Service Layer**
   - `src/services/WLEDDeviceRegistry.ts` (~300 lines)

3. **Type Definitions**
   - `src/types/wled.ts` (~100 lines)

4. **Context Updates**
   - Modified: `src/contexts/GlobalMusicContext.tsx` (+50 lines)

5. **Documentation**
   - Updated: `docs/ENVIRONMENT_SETUP.md` (WLED device setup)

---

## Next Steps After Story 18.1

Once this story is complete, proceed to:
- **Story 18.2:** Module Capability Declaration System - 3-4 hours
  - Now unblocked: Can reference device capabilities schema
  - Modules declare what visualization types they produce

---

## References

- **Epic 18:** `docs/epics/epic-18-intelligent-wled-routing.md`
- **Architecture:** `docs/architecture/wled-visualization-routing.md`
- **Supabase Realtime:** https://supabase.com/docs/guides/realtime
- **Supabase RLS:** https://supabase.com/docs/guides/auth/row-level-security
- **WLED API:** https://kno.wled.ge/interfaces/json-api/

---

**Story Created:** 2025-10-18
**Story Owner:** Dev Agent
**Estimated Completion:** 4-5 hours after start

---

## Notes

### Design Decisions

**Why Supabase Over localStorage?**
- Cross-device access (iPad, Desktop, Mobile)
- Real-time sync (device added on one device ‚Üí appears on all)
- RLS enforcement (secure per-user data)
- Future-proof for collaboration (shared device pools in jam sessions)

**Why JSONB for Capabilities?**
- Flexible schema evolution (add new capability fields without migration)
- Queryable (can filter devices by capability in future)
- Type-safe via TypeScript interfaces (validated client-side)

**Why Priority Field?**
- Future: User can set preferred device order
- Routing matrix can use priority for conflict resolution
- Example: "If two grids available, use higher priority device"

### Future Enhancements

- Device groups (e.g., "Stage Setup" = 3 devices)
- Device templates (save/load device configs)
- Shared device pools in jam sessions (multi-user access)
- Firmware update notifications (WLED version checks)
- Device health monitoring (ping devices periodically)

---

## Dev Agent Record

*To be completed during implementation*

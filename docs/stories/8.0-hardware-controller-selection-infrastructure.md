# Story 8.0: Hardware Controller Selection Infrastructure

**Epic:** Epic 8: Launchpad Pro Hardware Integration (Prerequisite)
**Status:** âœ… READY FOR IMPLEMENTATION
**Priority:** ğŸ”¥ **CRITICAL** (Blocks Epic 8 & Epic 11)
**Complexity:** Medium
**Prerequisites:**
- âœ… Story 1.x: APC40 Hardware Controller (existing implementation)
- âœ… Hardware Abstraction Layer exists (`src/hardware/core/`)

---

## Story

**As a** musician with multiple MIDI controllers (APC40, Launchpad Pro, ROLI LUMI),
**I want** to select which hardware controller to use from a dropdown menu,
**so that** I can switch between controllers without code changes and use whichever device I have available.

---

## Background / Context

### Current State: âŒ Hardcoded Controller

**Problem:**
```typescript
// src/components/IsometricSequencer/IsometricSequencer.tsx:205
const [apc40Controller] = useState(() => new APC40Controller());
const [apc40Connected, setAPC40Connected] = useState(false);
```

**Issues:**
1. âŒ **Hardcoded to APC40** - No way to use Launchpad Pro or ROLI LUMI
2. âŒ **NOT using HardwareManager** - Bypasses abstraction layer
3. âŒ **No controller switching** - Requires code changes to add new controllers
4. âŒ **Blocks Epic 8 & Epic 11** - Cannot integrate Launchpad Pro or ROLI LUMI

**What Exists (Good):**
- âœ… Well-designed `HardwareController` interface (src/hardware/core/types.ts)
- âœ… `HardwareManager` React Context with multi-controller support
- âœ… APC40Controller implements interface correctly
- âœ… Event-driven architecture (register/unregister controllers)

### User Pain Points

1. **Hardware Acquisition:** Users own different controllers (APC40 vs Launchpad vs ROLI)
2. **Setup Time:** Switching controllers requires developer intervention
3. **Workshop Flexibility:** Educators need to support whatever hardware students bring
4. **Feature Parity:** Launchpad Pro (Epic 8) and ROLI LUMI (Epic 11) blocked until this is fixed

---

## Acceptance Criteria

### AC 1: Controller Registry (Factory Pattern) âœ…

**Given** multiple hardware controller types exist in the codebase
**When** the app initializes
**Then** a centralized registry lists all available controller types

**Requirements:**
- [ ] Create `src/hardware/core/ControllerRegistry.ts`
- [ ] Define `ControllerType` enum: `'none' | 'apc40' | 'launchpad-pro-mk3' | 'launchpad-pro-2015' | 'roli-lumi'`
- [ ] Each controller has metadata: `id`, `name`, `description`, `manufacturer`, `available` (feature flag)
- [ ] Factory method: `createController(type, deviceId?) => HardwareController | null`
- [ ] Helper: `getAvailableControllers() => ControllerDefinition[]` (filters by `available: true`)
- [ ] APC40 registered with `available: true`
- [ ] Launchpad Pro registered with `available: false` (enabled after Epic 8 Story 8.1)
- [ ] ROLI LUMI registered with `available: false` (enabled after Epic 11)

**Example:**
```typescript
const controller = createController('apc40');
if (controller) {
  registerController(controller);
  await controller.connect();
}
```

---

### AC 2: Controller Selection Hook âœ…

**Given** user preferences should persist across sessions
**When** user selects a controller
**Then** the selection is saved to localStorage and restored on reload

**Requirements:**
- [ ] Create `src/hardware/core/useControllerSelection.ts`
- [ ] Hook API: `{ selectedType, activeController, availableControllers, switchController }`
- [ ] `switchController(type)` unregisters old controller and registers new one
- [ ] Auto-connect after switching
- [ ] Persist last selection to `localStorage` key: `centaurus:hardware:selected-controller`
- [ ] Restore saved selection on mount
- [ ] Handle connection errors gracefully (show error, don't crash)

**Switching Flow:**
```
User clicks "Launchpad Pro Mk3" dropdown option
  â†“
1. Unregister current controller (APC40)
2. Disconnect APC40
3. Create LaunchpadProController('mk3')
4. Register LaunchpadProController
5. Auto-connect to hardware
6. Save 'launchpad-pro-mk3' to localStorage
7. Update UI (connection status, controller name)
```

---

### AC 3: Controller Selection UI Component âœ…

**Given** users need a visual interface to switch controllers
**When** user opens hardware settings
**Then** a dropdown shows all available controllers with connection status

**Requirements:**
- [ ] Create `src/components/Hardware/HardwareControllerSelector.tsx`
- [ ] Dropdown shows: Controller name, description (manufacturer + grid size)
- [ ] Current selection highlighted (primary color background)
- [ ] Connection status indicator: ğŸŸ¢ Connected | ğŸŸ¡ Disconnected | ğŸ”´ Error
- [ ] "Settings" button for future rotation/grid mapping options
- [ ] Unavailable controllers disabled with tooltip: "Coming in Epic 8"
- [ ] Follows UX_STANDARDS.md: 44px touch targets, inline dropdown (no modal)
- [ ] Responsive: Mobile-friendly with safe-area-inset

**UI Mockup:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ”Œ Hardware Controller                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [Akai APC40                         â–¾] ğŸŸ¢ Connected â”‚
â”‚ [âš™ï¸ Settings]                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[Dropdown Open]:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ No Controller                                        â”‚
â”‚ Disable hardware integration                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ“ Akai APC40                                    ğŸŸ¢  â”‚ â† Selected
â”‚ 5Ã—8 grid with LED feedback                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Launchpad Pro Mk3                          [Locked] â”‚ â† Unavailable
â”‚ 8Ã—8 RGB grid (USB-C) - Coming in Epic 8             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ROLI LUMI Keys                             [Locked] â”‚ â† Unavailable
â”‚ LED keyboard - Coming in Epic 11                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### AC 4: Refactor IsometricSequencer to Use HardwareManager âœ…

**Given** IsometricSequencer currently hardcodes APC40
**When** refactoring is complete
**Then** IsometricSequencer uses HardwareManager for dynamic controller access

**Requirements:**
- [ ] Remove hardcoded `new APC40Controller()` from line 205
- [ ] Import `useHardwareContext()` hook
- [ ] Access active controller via `controllers[0]` or selection hook
- [ ] Replace direct APC40 state sync with `broadcastSequencerState()`
- [ ] Add `<HardwareControllerSelector />` to settings panel
- [ ] Existing APC40 functionality works unchanged (no regressions)

**Code Changes:**
```typescript
// BEFORE (IsometricSequencer.tsx:205):
const [apc40Controller] = useState(() => new APC40Controller());
const [apc40Connected, setAPC40Connected] = useState(false);

// AFTER:
const { controllers, broadcastSequencerState } = useHardwareContext();
const activeController = controllers.find(c => c.connectionStatus === 'connected');

// Update hardware when pattern changes:
useEffect(() => {
  if (activeController) {
    broadcastSequencerState({
      currentStep,
      isPlaying,
      tempo,
      pattern: matrix,
      trackCount: lanes
    });
  }
}, [currentStep, isPlaying, tempo, matrix, lanes, activeController]);

// Add UI to settings panel:
<CollapsiblePanel title="Hardware Controller" defaultOpen={false}>
  <HardwareControllerSelector />
</CollapsiblePanel>
```

---

### AC 5: Backwards Compatibility & Regression Testing âœ…

**Given** APC40 integration already works
**When** refactoring is complete
**Then** APC40 functionality remains unchanged

**Verification Steps:**
- [ ] APC40 connects successfully via new dropdown UI
- [ ] LED patterns display correctly on APC40
- [ ] Button presses trigger step toggles
- [ ] Pattern playback syncs with hardware
- [ ] Rotation toggle still works (if implemented)
- [ ] No performance regressions (LED update rate maintained)
- [ ] No console errors during controller switching

**Manual Test Plan:**
1. Open IsometricSequencer with APC40 connected
2. Select "Akai APC40" from dropdown â†’ Verify auto-connect
3. Create drum pattern â†’ Verify LEDs update
4. Press APC40 button â†’ Verify step toggles
5. Switch to "No Controller" â†’ Verify disconnect (no errors)
6. Switch back to "Akai APC40" â†’ Verify reconnect works

---

### AC 6: localStorage Persistence âœ…

**Given** user preferences should persist
**When** user reloads the page
**Then** last-selected controller auto-connects

**Requirements:**
- [ ] Save selected controller type to `localStorage` on change
- [ ] Restore selection on app load
- [ ] Auto-connect to restored controller
- [ ] Handle case where saved controller no longer available (fallback to 'none')
- [ ] Handle localStorage quota exceeded gracefully

**Test Cases:**
```javascript
// Scenario 1: First-time user
localStorage.getItem('centaurus:hardware:selected-controller') === null
â†’ Default to 'none' (no controller)

// Scenario 2: Returning user (APC40)
localStorage.getItem('centaurus:hardware:selected-controller') === 'apc40'
â†’ Auto-select APC40, attempt connection

// Scenario 3: Returning user (unavailable controller)
localStorage.getItem('centaurus:hardware:selected-controller') === 'launchpad-pro-mk3'
â†’ Check if available, fallback to 'none' if not
```

---

## Tasks / Subtasks

### Task 1: Create Controller Registry (AC 1)
**Estimated Effort:** 1.5 hours

**Subtasks:**
1. **Create ControllerRegistry.ts file** (30 min)
   - Create `src/hardware/core/ControllerRegistry.ts`
   - Define `ControllerType` type union: `'none' | 'apc40' | 'launchpad-pro-mk3' | 'launchpad-pro-2015' | 'roli-lumi'`
   - Define `ControllerDefinition` interface with feature flag (`available: boolean`)
   - Import APC40Controller from existing `src/hardware/apc40/APC40Controller.ts`

2. **Implement CONTROLLER_REGISTRY** (45 min)
   - Register 'none' controller (available: true)
   - Register 'apc40' controller with factory method `new APC40Controller(deviceId)` (available: true)
   - Register 'launchpad-pro-mk3' with placeholder (available: false)
   - Register 'launchpad-pro-2015' with placeholder (available: false)
   - Register 'roli-lumi' with placeholder (available: false)
   - Add metadata: name, description, manufacturer, gridSize

3. **Implement factory helpers** (15 min)
   - `createController(type, deviceId?)` - Returns HardwareController | null
   - `getAvailableControllers()` - Filters by `available: true`
   - `getAllControllers()` - Returns all definitions
   - `getControllerDefinition(type)` - Lookup by type
   - Add error handling for unavailable controllers

**References:**
- Architecture: `source-tree.md` lines 64-96 (hardware/ folder structure)
- Architecture: `coding-standards.md` lines 10-13 (Hardware Interface Consistency)
- Architecture: `data-models-and-schema-changes.md` lines 5-17 (HardwareController interface)

---

### Task 2: Create Controller Selection Hook (AC 2 & AC 6)
**Estimated Effort:** 1.5 hours

**Subtasks:**
1. **Create useControllerSelection.ts skeleton** (20 min)
   - Create `src/hardware/core/useControllerSelection.ts`
   - Define `UseControllerSelectionReturn` interface
   - Import `useHardwareContext` from HardwareManager
   - Import ControllerRegistry helpers
   - Define localStorage key: `'centaurus:hardware:selected-controller'`

2. **Implement localStorage persistence** (30 min)
   - `useEffect` on mount to load saved preference
   - Parse and validate stored ControllerType
   - Check if saved controller is still available (fallback to 'none' if not)
   - Auto-connect to restored controller
   - Handle localStorage quota exceeded error

3. **Implement switchController() function** (40 min)
   - Step 1: Unregister and disconnect previous controller
   - Step 2: Create new controller instance via `createController()`
   - Step 3: Register new controller with HardwareManager
   - Step 4: Auto-connect to hardware (handle connection errors)
   - Step 5: Save selection to localStorage (handle quota errors)
   - Add `isConnecting` loading state
   - Add `connectionError` error state

**References:**
- Architecture: `component-architecture.md` lines 5-17 (HardwareManager React Context)
- Architecture: `coding-standards.md` lines 16-19 (Error Handling, localStorage integration)
- Architecture: `data-models-and-schema-changes.md` lines 48-56 (localStorage storage strategy)

---

### Task 3: Create Hardware Controller Selector UI (AC 3)
**Estimated Effort:** 2 hours

**Subtasks:**
1. **Create HardwareControllerSelector.tsx skeleton** (20 min)
   - Create `src/components/Hardware/` directory (if not exists)
   - Create `src/components/Hardware/HardwareControllerSelector.tsx`
   - Import useControllerSelection hook
   - Import Lucide icons: `ChevronDown`, `Plug`, `Settings`, `Lock`
   - Setup dropdown state management with `useRef` for click-outside detection

2. **Implement main selector button** (30 min)
   - Display selected controller name and description
   - Show connection status indicator: ğŸŸ¢ Connected | ğŸŸ¡ Disconnected | ğŸ”´ Error
   - Add chevron icon with rotation animation
   - Ensure 44px minimum touch target (mobile compliance)
   - Disable button during `isConnecting` state

3. **Implement dropdown menu** (40 min)
   - Render all controllers from `allControllers`
   - Highlight currently selected controller (primary color background)
   - Show unavailable controllers as disabled with ğŸ”’ Lock icon
   - Add tooltips for unavailable controllers: "Coming in Epic 8/11"
   - Implement click handler to call `switchController(type)`
   - Close dropdown after selection

4. **Add error and info messages** (20 min)
   - Show connection error alert if `connectionError` exists
   - Show info message when "No Controller" selected
   - Follow UX_STANDARDS.md: Toast patterns, inline messaging (no modals)

5. **Responsive styling** (10 min)
   - Test mobile viewport (44px touch targets)
   - Verify safe-area-inset compliance (iOS notch)
   - Test tablet and desktop breakpoints
   - Ensure dropdown menu readable on small screens

**References:**
- Architecture: `component-architecture.md` lines 49-63 (HardwareSettingsPanel integration)
- Codebase: `CLAUDE.md` lines 13-21 (UX Design Standards - Tailwind CSS, Lucide icons)
- Codebase: `CLAUDE.md` lines 35-41 (Component Development Guidelines - responsive design)
- Epic: `epic-8-launchpad-pro-integration.md` lines 149-156 (44px touch targets from Story 5.1)

---

### Task 4: Refactor IsometricSequencer (AC 4)
**Estimated Effort:** 1 hour

**Subtasks:**
1. **Remove hardcoded APC40 imports and state** (15 min)
   - Remove `import { APC40Controller }` from line 205 area
   - Remove `const [apc40Controller] = useState(() => new APC40Controller())`
   - Remove `const [apc40Connected, setAPC40Connected] = useState(false)`
   - Remove `const [apc40Rotated, setAPC40Rotated] = useState(false)` (if exists)

2. **Add HardwareManager integration** (20 min)
   - Import `useHardwareContext` from `@/hardware`
   - Import `HardwareControllerSelector` component
   - Call `useHardwareContext()` to get `{ controllers, broadcastSequencerState }`
   - Derive `activeController` from `controllers.find(c => c.connectionStatus === 'connected')`

3. **Replace APC40 sync logic with broadcast** (15 min)
   - Find existing `useEffect` that syncs sequencer state to APC40
   - Replace with `broadcastSequencerState()` call
   - Include dependencies: `currentStep`, `isPlaying`, `tempo`, `matrix`, `lanes`, `activeController`
   - Remove conditional check for `apc40Connected` (use `activeController` instead)

4. **Add HardwareControllerSelector to settings panel** (10 min)
   - Find settings panel rendering code (around line 800-900)
   - Add new `<CollapsiblePanel>` with title="Hardware Controller"
   - Render `<HardwareControllerSelector />` inside panel
   - Add `<Plug>` icon from Lucide

**References:**
- Architecture: `component-architecture.md` lines 5-17 (HardwareManager usage pattern)
- Codebase: `IsometricSequencer.tsx` line 205 (current hardcoded implementation)
- Architecture: `source-tree.md` lines 12 (IsometricSequencer location)

---

### Task 5: Testing and Regression Verification (AC 5)
**Estimated Effort:** 1 hour

**Subtasks:**
1. **Manual Test 1: Controller Switching** (20 min)
   - Open IsometricSequencer in browser (localhost:5173)
   - Open settings panel â†’ Hardware Controller section
   - Select "Akai APC40" from dropdown
   - Verify connection status indicator updates
   - Create drum pattern and verify APC40 LEDs update
   - Press APC40 button and verify step toggles in UI
   - Switch to "No Controller" and verify clean disconnect
   - Check browser console for errors

2. **Manual Test 2: localStorage Persistence** (10 min)
   - Select "Akai APC40" from dropdown
   - Reload page (F5)
   - Verify dropdown pre-selects "Akai APC40"
   - Verify auto-connection attempted (check console logs)

3. **Manual Test 3: Unavailable Controllers** (10 min)
   - Open dropdown menu
   - Verify "Launchpad Pro Mk3" shows Lock icon and is disabled
   - Verify description mentions "Coming in Epic 8"
   - Attempt to click disabled option (should do nothing)

4. **Manual Test 4: Mobile Responsiveness** (10 min)
   - Open DevTools responsive mode (mobile viewport)
   - Verify dropdown touch targets â‰¥44px
   - Verify dropdown menu readable on small screen
   - Test on iOS simulator if available (safe-area-inset)

5. **Regression Testing: APC40** (10 min)
   - Verify LED patterns render correctly (no visual changes)
   - Verify button presses work identically to before
   - Verify no performance degradation (LED update rate)
   - Verify rotation toggle works (if implemented)
   - Document any issues in Dev Agent Record

**References:**
- Architecture: `testing-strategy.md` lines 20-24 (Manual Testing Requirements)
- Codebase: `CLAUDE.md` lines 8-25 (Manual testing philosophy - browser-based verification)
- Story: Lines 865-907 (Testing Strategy section - detailed test cases)

---

## Dev Notes

### Technology Stack
[Source: `architecture/tech-stack.md`]

**Core Technologies:**
- **React**: 18.2.0 - Core UI framework for hardware components [tech-stack.md:7]
- **TypeScript**: 5.2.2 - Strict mode compliance required [tech-stack.md:8]
- **Vite**: 5.0.8 - Build pipeline (no additional config needed) [tech-stack.md:9]
- **Tailwind CSS**: 3.3.6 - Hardware UI component styling [tech-stack.md:10]
- **Lucide React**: 0.294.0 - Icons for hardware status indicators [tech-stack.md:12]
- **React Context**: 18.2.0 - Hardware module state management [tech-stack.md:13]

**Browser APIs:**
- **Web MIDI API**: Native browser API for MIDI device communication [tech-stack.md:19]
- **localStorage**: For controller selection persistence [data-models-and-schema-changes.md:53]

**Rationale**: No external dependencies added. Enhancement uses only browser-native APIs (Web MIDI, localStorage) that integrate cleanly with existing React patterns. [tech-stack.md:22]

---

### File Organization
[Source: `architecture/source-tree.md`]

**New Files Location:**
- `src/hardware/core/ControllerRegistry.ts` - Factory pattern for controller instantiation [source-tree.md:70]
- `src/hardware/core/useControllerSelection.ts` - React hook for controller switching [source-tree.md:71]
- `src/components/Hardware/HardwareControllerSelector.tsx` - UI dropdown component [source-tree.md:82]

**Existing Files to Modify:**
- `src/components/IsometricSequencer/IsometricSequencer.tsx` - Refactor hardcoded APC40 [source-tree.md:12]
- `src/hardware/index.ts` - Add barrel exports for new modules [existing]

**Integration Guidelines:**
- File naming: camelCase for utilities, PascalCase for components [source-tree.md:93]
- Hardware module self-contained in `src/hardware/` to prevent coupling [source-tree.md:94]
- Use barrel export pattern (`hardware/index.ts`) [source-tree.md:95]

---

### Coding Standards
[Source: `architecture/coding-standards.md`]

**TypeScript Requirements:**
- Strict mode compliance enforced [coding-standards.md:4]
- ESLint rules apply to hardware modules [coding-standards.md:5]
- JSDoc comments for hardware APIs [coding-standards.md:7]

**Enhancement-Specific Standards:**
- **Hardware Interface Consistency**: All controllers implement `HardwareController` interface [coding-standards.md:10]
- **Error Boundary Pattern**: Hardware components wrapped in error boundaries to prevent app crashes [coding-standards.md:11]
- **MIDI Message Validation**: All MIDI input/output validated and sanitized [coding-standards.md:13]

**Critical Integration Rules:**
- **Existing API Compatibility**: Zero modifications to existing component interfaces [coding-standards.md:16]
- **Database Integration**: All hardware state follows existing localStorage patterns [coding-standards.md:17]
- **Error Handling**: Hardware errors isolated using React error boundaries, don't propagate to audio engine [coding-standards.md:18]

---

### Component Architecture
[Source: `architecture/component-architecture.md`]

**HardwareManager (Existing):**
- Central orchestrator for all hardware controller lifecycle management [component-architecture.md:6]
- React context provider wrapping existing App component [component-architecture.md:7]
- Key methods:
  - `useHardware()` - React hook for accessing hardware state [component-architecture.md:10]
  - `registerController(controller)` - Plugin system for adding new hardware [component-architecture.md:11]
  - `broadcastSequencerState(state)` - Distributes sequencer changes to all connected hardware [component-architecture.md:12]

**HardwareControllerSelector (New):**
- Visual feedback for hardware connection status [component-architecture.md:36]
- Integration points: Composes into existing settings panels [component-architecture.md:37]
- Dependencies: Uses existing Lucide icons, follows Tailwind design patterns [component-architecture.md:45]
- Technology stack: React functional component, Tailwind CSS, Lucide React icons [component-architecture.md:48]

---

### Data Models
[Source: `architecture/data-models-and-schema-changes.md`]

**HardwareController Interface (Existing):**
- Abstract base interface for all hardware controllers [data-models-and-schema-changes.md:6]
- Key attributes:
  - `id: string` - Unique identifier for controller instance [data-models-and-schema-changes.md:10]
  - `name: string` - Human-readable controller name [data-models-and-schema-changes.md:11]
  - `connectionStatus: 'connected' | 'disconnected' | 'error'` - Real-time connection state [data-models-and-schema-changes.md:12]
  - `capabilities: ControllerCapabilities` - Features supported by this controller [data-models-and-schema-changes.md:13]

**ControllerType (New):**
- Type union for controller selection: `'none' | 'apc40' | 'launchpad-pro-mk3' | 'launchpad-pro-2015' | 'roli-lumi'`
- Used in ControllerRegistry for factory pattern

**Storage Strategy:**
- **Runtime State**: React useState/useContext for active hardware connections [data-models-and-schema-changes.md:52]
- **Persistent Settings**: localStorage for hardware preferences (controller selection) [data-models-and-schema-changes.md:53]
- **localStorage Key**: `'centaurus:hardware:selected-controller'` (defined in this story)
- **Session State**: All hardware state cleared on app reload [data-models-and-schema-changes.md:54]

**Backward Compatibility**: Complete - no database schema exists, all new state management follows existing client-side patterns [data-models-and-schema-changes.md:56]

---

### Testing
[Source: `architecture/testing-strategy.md` + `CLAUDE.md`]

**Testing Philosophy:**
- **Manual testing** with human-in-the-loop verification (NOT automated test suites) [CLAUDE.md:9]
- Browser DevTools for debugging and performance monitoring [CLAUDE.md:10]
- Visual/audio inspection of module behavior across views [CLAUDE.md:11]

**Manual Testing Approach:**
- Developer manually tests features in browser (localhost:5173) [CLAUDE.md:21]
- Hardware integration tested with physical devices when available [CLAUDE.md:24]
- Cross-browser testing for Web MIDI API compatibility [testing-strategy.md:24]

**Testing Requirements:**
- **Unit Tests**: Not required per project philosophy [CLAUDE.md:11]
- **Integration Tests**: Manual verification of hardware â†” sequencer synchronization [testing-strategy.md:18]
- **Regression Tests**: Manual verification that existing APC40 functionality remains unchanged [testing-strategy.md:22]

**Test Coverage:**
- Controller switching (4 scenarios) [Story 8.0 lines 865-907]
- localStorage persistence (reload test) [Story 8.0 lines 880-885]
- Unavailable controllers UI (disabled state) [Story 8.0 lines 886-892]
- Mobile responsiveness (DevTools responsive mode) [Story 8.0 lines 893-898]
- APC40 regression (LED patterns, button presses, no performance degradation) [Story 8.0 lines 900-907]

---

## Technical Specifications

### File Structure

```
src/
â”œâ”€â”€ hardware/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ types.ts                      (âœ… Existing)
â”‚   â”‚   â”œâ”€â”€ HardwareManager.tsx           (âœ… Existing)
â”‚   â”‚   â”œâ”€â”€ ControllerRegistry.ts         (ğŸ†• NEW - Story 8.0)
â”‚   â”‚   â””â”€â”€ useControllerSelection.ts     (ğŸ†• NEW - Story 8.0)
â”‚   â”œâ”€â”€ apc40/
â”‚   â”‚   â””â”€â”€ APC40Controller.ts            (âœ… Existing)
â”‚   â”œâ”€â”€ launchpad/                        (â³ Future - Epic 8)
â”‚   â”‚   â””â”€â”€ LaunchpadProController.ts
â”‚   â””â”€â”€ roli/                             (â³ Future - Epic 11)
â”‚       â””â”€â”€ ROLILumiController.ts
â”œâ”€â”€ components/
â”‚   â””â”€â”€ Hardware/
â”‚       â””â”€â”€ HardwareControllerSelector.tsx (ğŸ†• NEW - Story 8.0)
```

---

### 1. Controller Registry

**File:** `src/hardware/core/ControllerRegistry.ts`

```typescript
/**
 * Controller Registry - Factory pattern for hardware controllers
 *
 * Centralized registration system for all hardware controller types.
 * Uses feature flags (available) to enable/disable controllers.
 */

import { HardwareController } from './types';
import { APC40Controller } from '../apc40/APC40Controller';
// Future imports (enabled after respective epics complete):
// import { LaunchpadProController } from '../launchpad/LaunchpadProController';
// import { ROLILumiController } from '../roli/ROLILumiController';

export type ControllerType =
  | 'none'
  | 'apc40'
  | 'launchpad-pro-mk3'
  | 'launchpad-pro-2015'
  | 'roli-lumi';

export interface ControllerDefinition {
  id: ControllerType;
  name: string;
  description: string;
  manufacturer: string;
  available: boolean; // Feature flag
  gridSize: string; // Display grid dimensions
  create: (deviceId?: string) => HardwareController;
}

/**
 * Global controller registry
 */
export const CONTROLLER_REGISTRY: Record<ControllerType, ControllerDefinition> = {
  'none': {
    id: 'none',
    name: 'No Controller',
    description: 'Disable hardware integration',
    manufacturer: 'N/A',
    gridSize: 'N/A',
    available: true,
    create: () => {
      throw new Error('Cannot instantiate null controller');
    }
  },

  'apc40': {
    id: 'apc40',
    name: 'Akai APC40',
    description: '5Ã—8 grid with LED feedback',
    manufacturer: 'Akai',
    gridSize: '5Ã—8',
    available: true, // âœ… Available now
    create: (deviceId) => new APC40Controller(deviceId)
  },

  'launchpad-pro-mk3': {
    id: 'launchpad-pro-mk3',
    name: 'Launchpad Pro Mk3',
    description: '8Ã—8 RGB grid with velocity pads (USB-C)',
    manufacturer: 'Novation',
    gridSize: '8Ã—8',
    available: false, // â³ Enable after Epic 8 Story 8.1
    create: (deviceId) => {
      throw new Error('Launchpad Pro Mk3 integration not yet implemented (Epic 8)');
      // Future: return new LaunchpadProController('mk3', deviceId);
    }
  },

  'launchpad-pro-2015': {
    id: 'launchpad-pro-2015',
    name: 'Launchpad Pro (2015)',
    description: '8Ã—8 RGB grid with velocity pads',
    manufacturer: 'Novation',
    gridSize: '8Ã—8',
    available: false, // â³ Enable after Epic 8 Story 8.1
    create: (deviceId) => {
      throw new Error('Launchpad Pro 2015 integration not yet implemented (Epic 8)');
      // Future: return new LaunchpadProController('2015', deviceId);
    }
  },

  'roli-lumi': {
    id: 'roli-lumi',
    name: 'ROLI LUMI Keys / Piano M',
    description: 'LED keyboard with per-key lighting',
    manufacturer: 'ROLI',
    gridSize: '24-key',
    available: false, // â³ Enable after Epic 11
    create: (deviceId) => {
      throw new Error('ROLI LUMI integration not yet implemented (Epic 11)');
      // Future: return new ROLILumiController(deviceId);
    }
  }
};

/**
 * Get available controllers (filtered by feature flag)
 */
export const getAvailableControllers = (): ControllerDefinition[] => {
  return Object.values(CONTROLLER_REGISTRY).filter(def => def.available);
};

/**
 * Get all controllers (including unavailable)
 */
export const getAllControllers = (): ControllerDefinition[] => {
  return Object.values(CONTROLLER_REGISTRY);
};

/**
 * Create controller instance from type
 * Returns null if type is 'none' or controller not available
 */
export const createController = (
  type: ControllerType,
  deviceId?: string
): HardwareController | null => {
  if (type === 'none') {
    console.log('Hardware controller disabled (type: none)');
    return null;
  }

  const definition = CONTROLLER_REGISTRY[type];

  if (!definition.available) {
    console.warn(`Controller ${type} is not yet available. Check Epic 8/11 progress.`);
    return null;
  }

  try {
    console.log(`Creating controller: ${definition.name} (${type})`);
    return definition.create(deviceId);
  } catch (error) {
    console.error(`Failed to create controller ${type}:`, error);
    return null;
  }
};

/**
 * Get controller definition by type
 */
export const getControllerDefinition = (type: ControllerType): ControllerDefinition => {
  return CONTROLLER_REGISTRY[type];
};
```

**LOC:** ~150 lines

---

### 2. Controller Selection Hook

**File:** `src/hardware/core/useControllerSelection.ts`

```typescript
/**
 * useControllerSelection - React hook for dynamic controller switching
 *
 * Manages controller lifecycle:
 * - Loads saved preference from localStorage
 * - Switches between controllers
 * - Auto-connects to selected controller
 * - Persists selection across sessions
 */

import { useState, useEffect, useCallback } from 'react';
import { useHardwareContext } from './HardwareManager';
import {
  createController,
  getAllControllers,
  getControllerDefinition,
  type ControllerType
} from './ControllerRegistry';
import type { HardwareController } from './types';

const STORAGE_KEY = 'centaurus:hardware:selected-controller';

export interface UseControllerSelectionReturn {
  selectedType: ControllerType;
  activeController: HardwareController | undefined;
  allControllers: ReturnType<typeof getAllControllers>;
  switchController: (type: ControllerType) => Promise<void>;
  isConnecting: boolean;
  connectionError: string | null;
}

export const useControllerSelection = (): UseControllerSelectionReturn => {
  const { registerController, unregisterController, controllers } = useHardwareContext();
  const [selectedType, setSelectedType] = useState<ControllerType>('none');
  const [activeControllerId, setActiveControllerId] = useState<string | null>(null);
  const [isConnecting, setIsConnecting] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);

  // Load saved preference on mount
  useEffect(() => {
    const loadSavedPreference = () => {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const type = saved as ControllerType;
          const definition = getControllerDefinition(type);

          // Only restore if controller is available
          if (definition.available) {
            console.log(`Restoring saved controller preference: ${type}`);
            setSelectedType(type);
            // Auto-connect will happen in useEffect below
          } else {
            console.warn(`Saved controller ${type} not available yet, defaulting to 'none'`);
            localStorage.removeItem(STORAGE_KEY);
          }
        }
      } catch (error) {
        console.error('Failed to load controller preference:', error);
      }
    };

    loadSavedPreference();
  }, []);

  // Auto-connect when selectedType changes
  useEffect(() => {
    if (selectedType !== 'none') {
      switchController(selectedType).catch(error => {
        console.error(`Failed to auto-connect to ${selectedType}:`, error);
      });
    }
  }, []); // Only run on mount

  /**
   * Switch to a different controller
   */
  const switchController = useCallback(async (type: ControllerType) => {
    setIsConnecting(true);
    setConnectionError(null);

    try {
      // Step 1: Disconnect and unregister previous controller
      if (activeControllerId) {
        console.log(`Disconnecting previous controller: ${activeControllerId}`);
        await unregisterController(activeControllerId);
        setActiveControllerId(null);
      }

      // Step 2: Create and register new controller
      if (type !== 'none') {
        const controller = createController(type);

        if (controller) {
          console.log(`Registering new controller: ${controller.name} (${controller.id})`);
          registerController(controller);
          setActiveControllerId(controller.id);

          // Step 3: Auto-connect to hardware
          try {
            console.log(`Connecting to ${controller.name}...`);
            await controller.connect();
            console.log(`âœ… Connected to ${controller.name}`);
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown connection error';
            console.error(`Failed to connect to ${type}:`, error);
            setConnectionError(`Connection failed: ${errorMessage}`);
            // Controller remains registered but disconnected
          }
        } else {
          console.warn(`Failed to create controller for type: ${type}`);
          setConnectionError(`Controller ${type} is not available yet`);
        }
      }

      // Step 4: Save preference to localStorage
      setSelectedType(type);
      try {
        if (type === 'none') {
          localStorage.removeItem(STORAGE_KEY);
        } else {
          localStorage.setItem(STORAGE_KEY, type);
        }
      } catch (error) {
        console.error('Failed to save controller preference to localStorage:', error);
      }

    } catch (error) {
      console.error('Error during controller switch:', error);
      setConnectionError(error instanceof Error ? error.message : 'Unknown error');
    } finally {
      setIsConnecting(false);
    }
  }, [activeControllerId, registerController, unregisterController]);

  return {
    selectedType,
    activeController: controllers.find(c => c.id === activeControllerId),
    allControllers: getAllControllers(),
    switchController,
    isConnecting,
    connectionError
  };
};
```

**LOC:** ~130 lines

---

### 3. Controller Selection UI Component

**File:** `src/components/Hardware/HardwareControllerSelector.tsx`

```typescript
/**
 * HardwareControllerSelector - UI for switching hardware controllers
 *
 * Dropdown-based interface for selecting and connecting to hardware controllers.
 * Shows connection status, handles unavailable controllers, and persists selection.
 */

import React, { useState } from 'react';
import { ChevronDown, Plug, Settings as SettingsIcon, Lock } from 'lucide-react';
import { useControllerSelection } from '@/hardware/core/useControllerSelection';

export const HardwareControllerSelector: React.FC = () => {
  const {
    selectedType,
    activeController,
    allControllers,
    switchController,
    isConnecting,
    connectionError
  } = useControllerSelection();

  const [showDropdown, setShowDropdown] = useState(false);
  const dropdownRef = React.useRef<HTMLDivElement>(null);

  // Close dropdown when clicking outside
  React.useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target as Node)) {
        setShowDropdown(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const selectedDefinition = allControllers.find(c => c.id === selectedType);

  return (
    <div className="space-y-3">
      {/* Main Controller Selector */}
      <div className="flex items-center gap-2 p-4 bg-gray-800 rounded-lg border border-gray-700">
        <Plug className="w-5 h-5 text-gray-400" />

        {/* Controller Dropdown */}
        <div ref={dropdownRef} className="relative flex-1">
          <button
            onClick={() => setShowDropdown(!showDropdown)}
            disabled={isConnecting}
            className="w-full px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors flex items-center justify-between min-h-[44px] disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <div className="flex flex-col items-start">
              <span className="text-white font-medium">
                {selectedDefinition?.name || 'Select Controller'}
              </span>
              {selectedDefinition && selectedDefinition.id !== 'none' && (
                <span className="text-xs text-gray-400">
                  {selectedDefinition.manufacturer} â€¢ {selectedDefinition.gridSize}
                </span>
              )}
            </div>
            <ChevronDown className={`w-4 h-4 transition-transform ${showDropdown ? 'rotate-180' : ''}`} />
          </button>

          {/* Dropdown Menu */}
          {showDropdown && (
            <div className="absolute top-full left-0 right-0 mt-2 bg-gray-800 rounded-lg border border-gray-700 shadow-lg z-50 max-h-96 overflow-y-auto">
              <div className="p-2 space-y-1">
                {allControllers.map(definition => (
                  <button
                    key={definition.id}
                    onClick={() => {
                      if (definition.available) {
                        switchController(definition.id);
                        setShowDropdown(false);
                      }
                    }}
                    disabled={!definition.available}
                    className={`w-full px-4 py-3 text-left rounded-lg transition-colors min-h-[44px] flex items-center justify-between ${
                      definition.id === selectedType
                        ? 'bg-primary-600 text-white'
                        : definition.available
                        ? 'hover:bg-gray-700 text-gray-300'
                        : 'opacity-50 cursor-not-allowed text-gray-500'
                    }`}
                  >
                    <div className="flex flex-col">
                      <div className="flex items-center gap-2">
                        <span className="font-medium">{definition.name}</span>
                        {!definition.available && (
                          <Lock className="w-3 h-3 text-gray-500" />
                        )}
                      </div>
                      <span className="text-sm text-gray-400">
                        {definition.description}
                      </span>
                    </div>
                    {definition.id === selectedType && (
                      <span className="text-yellow-400 text-xl">âœ“</span>
                    )}
                  </button>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Connection Status */}
        {activeController && (
          <div className="flex items-center gap-2">
            <div className={`w-2 h-2 rounded-full ${
              isConnecting ? 'bg-yellow-500 animate-pulse' :
              activeController.connectionStatus === 'connected' ? 'bg-green-500' :
              activeController.connectionStatus === 'error' ? 'bg-red-500' :
              'bg-gray-500'
            }`} />
            <span className="text-sm text-gray-400 capitalize">
              {isConnecting ? 'Connecting...' : activeController.connectionStatus}
            </span>
          </div>
        )}

        {/* Settings Button (Future: Rotation, grid mapping, etc.) */}
        <button
          className="p-2 hover:bg-gray-700 rounded-lg transition-colors"
          title="Controller settings (coming soon)"
          disabled
        >
          <SettingsIcon className="w-5 h-5 text-gray-400" />
        </button>
      </div>

      {/* Connection Error */}
      {connectionError && (
        <div className="p-3 bg-red-900/20 border border-red-700 rounded-lg">
          <p className="text-sm text-red-400">
            âš ï¸ {connectionError}
          </p>
        </div>
      )}

      {/* Info Message for "None" */}
      {selectedType === 'none' && (
        <div className="p-3 bg-gray-700/50 rounded-lg">
          <p className="text-sm text-gray-400">
            ğŸ’¡ <strong>Tip:</strong> Select a hardware controller above to enable LED feedback and physical button control.
          </p>
        </div>
      )}
    </div>
  );
};
```

**LOC:** ~150 lines

---

### 4. IsometricSequencer Refactoring

**File:** `src/components/IsometricSequencer/IsometricSequencer.tsx`

**Changes Required:**

```typescript
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// REMOVE (Line 205-207):
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { APC40Controller } from '@/utils/APC40Controller'; // âŒ Remove
const [apc40Controller] = useState(() => new APC40Controller()); // âŒ Remove
const [apc40Connected, setAPC40Connected] = useState(false); // âŒ Remove
const [apc40Rotated, setAPC40Rotated] = useState(false); // âŒ Remove

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ADD (Top of component):
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import { useHardwareContext } from '@/hardware';
import { HardwareControllerSelector } from '@/components/Hardware/HardwareControllerSelector';

// Inside component:
const { controllers, broadcastSequencerState } = useHardwareContext();
const activeController = controllers.find(c => c.connectionStatus === 'connected');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// REPLACE hardware sync logic:
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BEFORE (manual APC40 sync):
useEffect(() => {
  if (apc40Connected) {
    apc40Controller.updateSequencerState({ /* ... */ });
  }
}, [/* dependencies */]);

// AFTER (abstracted sync):
useEffect(() => {
  if (activeController) {
    broadcastSequencerState({
      currentStep,
      isPlaying,
      tempo,
      pattern: matrix,
      trackCount: lanes
    });
  }
}, [currentStep, isPlaying, tempo, matrix, lanes, activeController, broadcastSequencerState]);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ADD UI component to settings panel:
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Find the settings panel rendering code (around line 800-900)
// Add new CollapsiblePanel:

<CollapsiblePanel
  title="Hardware Controller"
  defaultOpen={false}
  icon={<Plug className="w-5 h-5" />}
>
  <HardwareControllerSelector />
</CollapsiblePanel>
```

**Estimated Changes:**
- **Remove:** ~15 lines (hardcoded APC40 state)
- **Add:** ~30 lines (HardwareManager integration + UI)
- **Net Change:** +15 lines

---

## File Locations & Line Counts

**New Files:**
- `src/hardware/core/ControllerRegistry.ts` - ~150 lines
- `src/hardware/core/useControllerSelection.ts` - ~130 lines
- `src/components/Hardware/HardwareControllerSelector.tsx` - ~150 lines

**Modified Files:**
- `src/components/IsometricSequencer/IsometricSequencer.tsx` - ~15 line diff
- `src/hardware/index.ts` - +3 lines (export new modules)

**Total New Code:** ~430 lines
**Total Modified Code:** ~20 lines

---

## Success Metrics

### Functional Success
- [ ] User can switch from APC40 to "No Controller" without errors
- [ ] Selection persists after browser reload
- [ ] APC40 connects and functions identically to before refactoring
- [ ] Dropdown shows unavailable controllers as disabled
- [ ] Connection status indicator updates in real-time

### Performance Success
- [ ] Controller switching completes in <2 seconds
- [ ] No performance degradation in LED update rate
- [ ] HardwareManager overhead <0.8ms (5% of 16ms frame budget)

### Developer Experience Success
- [ ] Epic 8 developers can add Launchpad Pro by:
  1. Implementing `LaunchpadProController` class
  2. Setting `available: true` in registry
  3. Zero changes to IsometricSequencer
- [ ] Epic 11 developers follow same pattern for ROLI LUMI
- [ ] Future controllers follow same 3-step integration

---

## Testing Strategy

### Manual Testing Checklist

**Test 1: Controller Switching**
1. Open IsometricSequencer
2. Open settings panel â†’ Hardware Controller section
3. Select "Akai APC40" from dropdown
4. Verify: Connection status shows "ğŸŸ¢ Connected"
5. Create drum pattern
6. Verify: APC40 LEDs update correctly
7. Press APC40 button
8. Verify: Step toggles in UI
9. Select "No Controller" from dropdown
10. Verify: Disconnect successful, no errors in console

**Test 2: localStorage Persistence**
1. Select "Akai APC40" from dropdown
2. Reload page (F5)
3. Verify: Dropdown shows "Akai APC40" pre-selected
4. Verify: Auto-connection attempted (status indicator updates)

**Test 3: Unavailable Controllers**
1. Open dropdown
2. Verify: "Launchpad Pro Mk3" shows ğŸ”’ Lock icon
3. Verify: Button is disabled (cannot click)
4. Hover over disabled option
5. Verify: Tooltip or description mentions "Coming in Epic 8"

**Test 4: Mobile Responsiveness**
1. Open on mobile viewport (DevTools responsive mode)
2. Tap dropdown (verify 44px touch target)
3. Verify: Dropdown menu readable on mobile
4. Verify: Safe-area-inset respected (iOS notch)

### Regression Testing

**Verify APC40 Unchanged:**
- [ ] LED patterns render correctly
- [ ] Button presses trigger step toggles
- [ ] Rotation toggle works (if implemented)
- [ ] Connection error handling works
- [ ] No console errors during normal operation

---

## Dependencies & Blockers

### Dependencies
- âœ… `src/hardware/core/HardwareManager.tsx` - Already exists
- âœ… `src/hardware/core/types.ts` - Already exists
- âœ… `src/hardware/apc40/APC40Controller.ts` - Already exists

### Blocks
- âš ï¸ **Epic 8 Story 8.1** - Cannot implement LaunchpadProController until this is complete
- âš ï¸ **Epic 11** - Cannot implement ROLILumiController until this is complete

---

## Epic 8 & Epic 11 Integration Path

### Epic 8 Story 8.1: LaunchpadProController Implementation

**After Story 8.0 is complete:**

```typescript
// Step 1: Implement controller class
// src/hardware/launchpad/LaunchpadProController.ts
export class LaunchpadProController implements HardwareController {
  // ... implement interface methods
}

// Step 2: Enable in registry
// src/hardware/core/ControllerRegistry.ts
import { LaunchpadProController } from '../launchpad/LaunchpadProController';

'launchpad-pro-mk3': {
  id: 'launchpad-pro-mk3',
  name: 'Launchpad Pro Mk3',
  description: '8Ã—8 RGB grid with velocity pads (USB-C)',
  manufacturer: 'Novation',
  gridSize: '8Ã—8',
  available: true, // âœ… Changed from false
  create: (deviceId) => new LaunchpadProController('mk3', deviceId)
}

// Step 3: Done! Dropdown now shows Launchpad Pro as selectable
```

**Zero changes required to:**
- âŒ IsometricSequencer.tsx
- âŒ HardwareManager.tsx
- âŒ HardwareControllerSelector.tsx

---

## Definition of Done

- [ ] All 6 Acceptance Criteria met and verified
- [ ] ControllerRegistry.ts created with all controller types registered
- [ ] useControllerSelection.ts hook implemented with localStorage persistence
- [ ] HardwareControllerSelector.tsx UI component created and responsive
- [ ] IsometricSequencer.tsx refactored to use HardwareManager
- [ ] Manual testing checklist completed (4 tests passed)
- [ ] APC40 regression testing passed (no functionality lost)
- [ ] localStorage persistence verified (reload test passed)
- [ ] Mobile responsive design verified (44px touch targets)
- [ ] Code review completed
- [ ] No console errors during controller switching
- [ ] Epic 8 and Epic 11 teams notified of new integration pattern

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-21 | 1.0 | Initial story creation - Hardware Controller Selection Infrastructure | Winston (Architect) |
| 2025-10-21 | 1.1 | Added Tasks/Subtasks section and Dev Notes with architecture references. Story marked READY FOR IMPLEMENTATION. | Bob (Scrum Master) |

---

## Next Steps

1. **Implement Story 8.0** (this story) - 3-4 hours
2. **Verify APC40 regression testing** - 30 minutes
3. **Notify Epic 8 team** - Integration pattern ready
4. **Proceed with Epic 8 Story 8.1** - LaunchpadProController implementation

---

**Epic Status:** Story 8.0 (Prerequisite) â†’ Epic 8 Story 8.1 (LaunchpadProController)
**Estimated Implementation Time:** 3-4 hours for experienced React/TypeScript developer
**Priority:** CRITICAL - Blocks Epic 8 and Epic 11

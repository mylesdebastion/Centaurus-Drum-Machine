# Story 8.0: Hardware Controller Selection Infrastructure

**Epic:** Epic 8: Launchpad Pro Hardware Integration (Prerequisite)
**Status:** ✅ READY FOR IMPLEMENTATION
**Priority:** 🔥 **CRITICAL** (Blocks Epic 8 & Epic 11)
**Complexity:** Medium
**Prerequisites:**
- ✅ Story 1.x: APC40 Hardware Controller (existing implementation)
- ✅ Hardware Abstraction Layer exists (`src/hardware/core/`)

---

## Story

**As a** musician with multiple MIDI controllers (APC40, Launchpad Pro, ROLI LUMI),
**I want** to select which hardware controller to use from a dropdown menu,
**so that** I can switch between controllers without code changes and use whichever device I have available.

---

## Background / Context

### Current State: ❌ Hardcoded Controller

**Problem:**
```typescript
// src/components/IsometricSequencer/IsometricSequencer.tsx:205
const [apc40Controller] = useState(() => new APC40Controller());
const [apc40Connected, setAPC40Connected] = useState(false);
```

**Issues:**
1. ❌ **Hardcoded to APC40** - No way to use Launchpad Pro or ROLI LUMI
2. ❌ **NOT using HardwareManager** - Bypasses abstraction layer
3. ❌ **No controller switching** - Requires code changes to add new controllers
4. ❌ **Blocks Epic 8 & Epic 11** - Cannot integrate Launchpad Pro or ROLI LUMI

**What Exists (Good):**
- ✅ Well-designed `HardwareController` interface (src/hardware/core/types.ts)
- ✅ `HardwareManager` React Context with multi-controller support
- ✅ APC40Controller implements interface correctly
- ✅ Event-driven architecture (register/unregister controllers)

### User Pain Points

1. **Hardware Acquisition:** Users own different controllers (APC40 vs Launchpad vs ROLI)
2. **Setup Time:** Switching controllers requires developer intervention
3. **Workshop Flexibility:** Educators need to support whatever hardware students bring
4. **Feature Parity:** Launchpad Pro (Epic 8) and ROLI LUMI (Epic 11) blocked until this is fixed

---

## Acceptance Criteria

### AC 1: Controller Registry (Factory Pattern) ✅

**Given** multiple hardware controller types exist in the codebase
**When** the app initializes
**Then** a centralized registry lists all available controller types

**Requirements:**
- [ ] Create `src/hardware/core/ControllerRegistry.ts`
- [ ] Define `ControllerType` enum: `'none' | 'apc40' | 'launchpad-pro-mk3' | 'launchpad-pro-2015' | 'roli-lumi'`
- [ ] Each controller has metadata: `id`, `name`, `description`, `manufacturer`, `available` (feature flag)
- [ ] Factory method: `createController(type, deviceId?) => HardwareController | null`
- [ ] Helper: `getAvailableControllers() => ControllerDefinition[]` (filters by `available: true`)
- [ ] APC40 registered with `available: true`
- [ ] Launchpad Pro registered with `available: false` (enabled after Epic 8 Story 8.1)
- [ ] ROLI LUMI registered with `available: false` (enabled after Epic 11)

**Example:**
```typescript
const controller = createController('apc40');
if (controller) {
  registerController(controller);
  await controller.connect();
}
```

---

### AC 2: Controller Selection Hook ✅

**Given** user preferences should persist across sessions
**When** user selects a controller
**Then** the selection is saved to localStorage and restored on reload

**Requirements:**
- [ ] Create `src/hardware/core/useControllerSelection.ts`
- [ ] Hook API: `{ selectedType, activeController, availableControllers, switchController }`
- [ ] `switchController(type)` unregisters old controller and registers new one
- [ ] Auto-connect after switching
- [ ] Persist last selection to `localStorage` key: `centaurus:hardware:selected-controller`
- [ ] Restore saved selection on mount
- [ ] Handle connection errors gracefully (show error, don't crash)

**Switching Flow:**
```
User clicks "Launchpad Pro Mk3" dropdown option
  ↓
1. Unregister current controller (APC40)
2. Disconnect APC40
3. Create LaunchpadProController('mk3')
4. Register LaunchpadProController
5. Auto-connect to hardware
6. Save 'launchpad-pro-mk3' to localStorage
7. Update UI (connection status, controller name)
```

---

### AC 3: Controller Selection UI Component ✅

**Given** users need a visual interface to switch controllers
**When** user opens hardware settings
**Then** a dropdown shows all available controllers with connection status

**Requirements:**
- [ ] Create `src/components/Hardware/HardwareControllerSelector.tsx`
- [ ] Dropdown shows: Controller name, description (manufacturer + grid size)
- [ ] Current selection highlighted (primary color background)
- [ ] Connection status indicator: 🟢 Connected | 🟡 Disconnected | 🔴 Error
- [ ] "Settings" button for future rotation/grid mapping options
- [ ] Unavailable controllers disabled with tooltip: "Coming in Epic 8"
- [ ] Follows UX_STANDARDS.md: 44px touch targets, inline dropdown (no modal)
- [ ] Responsive: Mobile-friendly with safe-area-inset

**UI Mockup:**
```
┌──────────────────────────────────────────────────────┐
│ 🔌 Hardware Controller                               │
├──────────────────────────────────────────────────────┤
│ [Akai APC40                         ▾] 🟢 Connected │
│ [⚙️ Settings]                                         │
└──────────────────────────────────────────────────────┘

[Dropdown Open]:
┌──────────────────────────────────────────────────────┐
│ No Controller                                        │
│ Disable hardware integration                         │
├──────────────────────────────────────────────────────┤
│ ✓ Akai APC40                                    🟢  │ ← Selected
│ 5×8 grid with LED feedback                          │
├──────────────────────────────────────────────────────┤
│ Launchpad Pro Mk3                          [Locked] │ ← Unavailable
│ 8×8 RGB grid (USB-C) - Coming in Epic 8             │
├──────────────────────────────────────────────────────┤
│ ROLI LUMI Keys                             [Locked] │ ← Unavailable
│ LED keyboard - Coming in Epic 11                    │
└──────────────────────────────────────────────────────┘
```

---

### AC 4: Refactor IsometricSequencer to Use HardwareManager ✅

**Given** IsometricSequencer currently hardcodes APC40
**When** refactoring is complete
**Then** IsometricSequencer uses HardwareManager for dynamic controller access

**Requirements:**
- [ ] Remove hardcoded `new APC40Controller()` from line 205
- [ ] Import `useHardwareContext()` hook
- [ ] Access active controller via `controllers[0]` or selection hook
- [ ] Replace direct APC40 state sync with `broadcastSequencerState()`
- [ ] Add `<HardwareControllerSelector />` to settings panel
- [ ] Existing APC40 functionality works unchanged (no regressions)

**Code Changes:**
```typescript
// BEFORE (IsometricSequencer.tsx:205):
const [apc40Controller] = useState(() => new APC40Controller());
const [apc40Connected, setAPC40Connected] = useState(false);

// AFTER:
const { controllers, broadcastSequencerState } = useHardwareContext();
const activeController = controllers.find(c => c.connectionStatus === 'connected');

// Update hardware when pattern changes:
useEffect(() => {
  if (activeController) {
    broadcastSequencerState({
      currentStep,
      isPlaying,
      tempo,
      pattern: matrix,
      trackCount: lanes
    });
  }
}, [currentStep, isPlaying, tempo, matrix, lanes, activeController]);

// Add UI to settings panel:
<CollapsiblePanel title="Hardware Controller" defaultOpen={false}>
  <HardwareControllerSelector />
</CollapsiblePanel>
```

---

### AC 5: Backwards Compatibility & Regression Testing ✅

**Given** APC40 integration already works
**When** refactoring is complete
**Then** APC40 functionality remains unchanged

**Verification Steps:**
- [ ] APC40 connects successfully via new dropdown UI
- [ ] LED patterns display correctly on APC40
- [ ] Button presses trigger step toggles
- [ ] Pattern playback syncs with hardware
- [ ] Rotation toggle still works (if implemented)
- [ ] No performance regressions (LED update rate maintained)
- [ ] No console errors during controller switching

**Manual Test Plan:**
1. Open IsometricSequencer with APC40 connected
2. Select "Akai APC40" from dropdown → Verify auto-connect
3. Create drum pattern → Verify LEDs update
4. Press APC40 button → Verify step toggles
5. Switch to "No Controller" → Verify disconnect (no errors)
6. Switch back to "Akai APC40" → Verify reconnect works

---

### AC 6: localStorage Persistence ✅

**Given** user preferences should persist
**When** user reloads the page
**Then** last-selected controller auto-connects

**Requirements:**
- [ ] Save selected controller type to `localStorage` on change
- [ ] Restore selection on app load
- [ ] Auto-connect to restored controller
- [ ] Handle case where saved controller no longer available (fallback to 'none')
- [ ] Handle localStorage quota exceeded gracefully

**Test Cases:**
```javascript
// Scenario 1: First-time user
localStorage.getItem('centaurus:hardware:selected-controller') === null
→ Default to 'none' (no controller)

// Scenario 2: Returning user (APC40)
localStorage.getItem('centaurus:hardware:selected-controller') === 'apc40'
→ Auto-select APC40, attempt connection

// Scenario 3: Returning user (unavailable controller)
localStorage.getItem('centaurus:hardware:selected-controller') === 'launchpad-pro-mk3'
→ Check if available, fallback to 'none' if not
```

---

## Tasks / Subtasks

### Task 1: Create Controller Registry (AC 1)
**Estimated Effort:** 1.5 hours

**Subtasks:**
1. **Create ControllerRegistry.ts file** (30 min)
   - Create `src/hardware/core/ControllerRegistry.ts`
   - Define `ControllerType` type union: `'none' | 'apc40' | 'launchpad-pro-mk3' | 'launchpad-pro-2015' | 'roli-lumi'`
   - Define `ControllerDefinition` interface with feature flag (`available: boolean`)
   - Import APC40Controller from existing `src/hardware/apc40/APC40Controller.ts`

2. **Implement CONTROLLER_REGISTRY** (45 min)
   - Register 'none' controller (available: true)
   - Register 'apc40' controller with factory method `new APC40Controller(deviceId)` (available: true)
   - Register 'launchpad-pro-mk3' with placeholder (available: false)
   - Register 'launchpad-pro-2015' with placeholder (available: false)
   - Register 'roli-lumi' with placeholder (available: false)
   - Add metadata: name, description, manufacturer, gridSize

3. **Implement factory helpers** (15 min)
   - `createController(type, deviceId?)` - Returns HardwareController | null
   - `getAvailableControllers()` - Filters by `available: true`
   - `getAllControllers()` - Returns all definitions
   - `getControllerDefinition(type)` - Lookup by type
   - Add error handling for unavailable controllers

**References:**
- Architecture: `source-tree.md` lines 64-96 (hardware/ folder structure)
- Architecture: `coding-standards.md` lines 10-13 (Hardware Interface Consistency)
- Architecture: `data-models-and-schema-changes.md` lines 5-17 (HardwareController interface)

---

### Task 2: Create Controller Selection Hook (AC 2 & AC 6)
**Estimated Effort:** 1.5 hours

**Subtasks:**
1. **Create useControllerSelection.ts skeleton** (20 min)
   - Create `src/hardware/core/useControllerSelection.ts`
   - Define `UseControllerSelectionReturn` interface
   - Import `useHardwareContext` from HardwareManager
   - Import ControllerRegistry helpers
   - Define localStorage key: `'centaurus:hardware:selected-controller'`

2. **Implement localStorage persistence** (30 min)
   - `useEffect` on mount to load saved preference
   - Parse and validate stored ControllerType
   - Check if saved controller is still available (fallback to 'none' if not)
   - Auto-connect to restored controller
   - Handle localStorage quota exceeded error

3. **Implement switchController() function** (40 min)
   - Step 1: Unregister and disconnect previous controller
   - Step 2: Create new controller instance via `createController()`
   - Step 3: Register new controller with HardwareManager
   - Step 4: Auto-connect to hardware (handle connection errors)
   - Step 5: Save selection to localStorage (handle quota errors)
   - Add `isConnecting` loading state
   - Add `connectionError` error state

**References:**
- Architecture: `component-architecture.md` lines 5-17 (HardwareManager React Context)
- Architecture: `coding-standards.md` lines 16-19 (Error Handling, localStorage integration)
- Architecture: `data-models-and-schema-changes.md` lines 48-56 (localStorage storage strategy)

---

### Task 3: Create Hardware Controller Selector UI (AC 3)
**Estimated Effort:** 2 hours

**Subtasks:**
1. **Create HardwareControllerSelector.tsx skeleton** (20 min)
   - Create `src/components/Hardware/` directory (if not exists)
   - Create `src/components/Hardware/HardwareControllerSelector.tsx`
   - Import useControllerSelection hook
   - Import Lucide icons: `ChevronDown`, `Plug`, `Settings`, `Lock`
   - Setup dropdown state management with `useRef` for click-outside detection

2. **Implement main selector button** (30 min)
   - Display selected controller name and description
   - Show connection status indicator: 🟢 Connected | 🟡 Disconnected | 🔴 Error
   - Add chevron icon with rotation animation
   - Ensure 44px minimum touch target (mobile compliance)
   - Disable button during `isConnecting` state

3. **Implement dropdown menu** (40 min)
   - Render all controllers from `allControllers`
   - Highlight currently selected controller (primary color background)
   - Show unavailable controllers as disabled with 🔒 Lock icon
   - Add tooltips for unavailable controllers: "Coming in Epic 8/11"
   - Implement click handler to call `switchController(type)`
   - Close dropdown after selection

4. **Add error and info messages** (20 min)
   - Show connection error alert if `connectionError` exists
   - Show info message when "No Controller" selected
   - Follow UX_STANDARDS.md: Toast patterns, inline messaging (no modals)

5. **Responsive styling** (10 min)
   - Test mobile viewport (44px touch targets)
   - Verify safe-area-inset compliance (iOS notch)
   - Test tablet and desktop breakpoints
   - Ensure dropdown menu readable on small screens

**References:**
- Architecture: `component-architecture.md` lines 49-63 (HardwareSettingsPanel integration)
- Codebase: `CLAUDE.md` lines 13-21 (UX Design Standards - Tailwind CSS, Lucide icons)
- Codebase: `CLAUDE.md` lines 35-41 (Component Development Guidelines - responsive design)
- Epic: `epic-8-launchpad-pro-integration.md` lines 149-156 (44px touch targets from Story 5.1)

---

### Task 4: Refactor IsometricSequencer (AC 4)
**Estimated Effort:** 1 hour

**Subtasks:**
1. **Remove hardcoded APC40 imports and state** (15 min)
   - Remove `import { APC40Controller }` from line 205 area
   - Remove `const [apc40Controller] = useState(() => new APC40Controller())`
   - Remove `const [apc40Connected, setAPC40Connected] = useState(false)`
   - Remove `const [apc40Rotated, setAPC40Rotated] = useState(false)` (if exists)

2. **Add HardwareManager integration** (20 min)
   - Import `useHardwareContext` from `@/hardware`
   - Import `HardwareControllerSelector` component
   - Call `useHardwareContext()` to get `{ controllers, broadcastSequencerState }`
   - Derive `activeController` from `controllers.find(c => c.connectionStatus === 'connected')`

3. **Replace APC40 sync logic with broadcast** (15 min)
   - Find existing `useEffect` that syncs sequencer state to APC40
   - Replace with `broadcastSequencerState()` call
   - Include dependencies: `currentStep`, `isPlaying`, `tempo`, `matrix`, `lanes`, `activeController`
   - Remove conditional check for `apc40Connected` (use `activeController` instead)

4. **Add HardwareControllerSelector to settings panel** (10 min)
   - Find settings panel rendering code (around line 800-900)
   - Add new `<CollapsiblePanel>` with title="Hardware Controller"
   - Render `<HardwareControllerSelector />` inside panel
   - Add `<Plug>` icon from Lucide

**References:**
- Architecture: `component-architecture.md` lines 5-17 (HardwareManager usage pattern)
- Codebase: `IsometricSequencer.tsx` line 205 (current hardcoded implementation)
- Architecture: `source-tree.md` lines 12 (IsometricSequencer location)

---

### Task 5: Testing and Regression Verification (AC 5)
**Estimated Effort:** 1 hour

**Subtasks:**
1. **Manual Test 1: Controller Switching** (20 min)
   - Open IsometricSequencer in browser (localhost:5173)
   - Open settings panel → Hardware Controller section
   - Select "Akai APC40" from dropdown
   - Verify connection status indicator updates
   - Create drum pattern and verify APC40 LEDs update
   - Press APC40 button and verify step toggles in UI
   - Switch to "No Controller" and verify clean disconnect
   - Check browser console for errors

2. **Manual Test 2: localStorage Persistence** (10 min)
   - Select "Akai APC40" from dropdown
   - Reload page (F5)
   - Verify dropdown pre-selects "Akai APC40"
   - Verify auto-connection attempted (check console logs)

3. **Manual Test 3: Unavailable Controllers** (10 min)
   - Open dropdown menu
   - Verify "Launchpad Pro Mk3" shows Lock icon and is disabled
   - Verify description mentions "Coming in Epic 8"
   - Attempt to click disabled option (should do nothing)

4. **Manual Test 4: Mobile Responsiveness** (10 min)
   - Open DevTools responsive mode (mobile viewport)
   - Verify dropdown touch targets ≥44px
   - Verify dropdown menu readable on small screen
   - Test on iOS simulator if available (safe-area-inset)

5. **Regression Testing: APC40** (10 min)
   - Verify LED patterns render correctly (no visual changes)
   - Verify button presses work identically to before
   - Verify no performance degradation (LED update rate)
   - Verify rotation toggle works (if implemented)
   - Document any issues in Dev Agent Record

**References:**
- Architecture: `testing-strategy.md` lines 20-24 (Manual Testing Requirements)
- Codebase: `CLAUDE.md` lines 8-25 (Manual testing philosophy - browser-based verification)
- Story: Lines 865-907 (Testing Strategy section - detailed test cases)

---

## Dev Notes

### Technology Stack
[Source: `architecture/tech-stack.md`]

**Core Technologies:**
- **React**: 18.2.0 - Core UI framework for hardware components [tech-stack.md:7]
- **TypeScript**: 5.2.2 - Strict mode compliance required [tech-stack.md:8]
- **Vite**: 5.0.8 - Build pipeline (no additional config needed) [tech-stack.md:9]
- **Tailwind CSS**: 3.3.6 - Hardware UI component styling [tech-stack.md:10]
- **Lucide React**: 0.294.0 - Icons for hardware status indicators [tech-stack.md:12]
- **React Context**: 18.2.0 - Hardware module state management [tech-stack.md:13]

**Browser APIs:**
- **Web MIDI API**: Native browser API for MIDI device communication [tech-stack.md:19]
- **localStorage**: For controller selection persistence [data-models-and-schema-changes.md:53]

**Rationale**: No external dependencies added. Enhancement uses only browser-native APIs (Web MIDI, localStorage) that integrate cleanly with existing React patterns. [tech-stack.md:22]

---

### File Organization
[Source: `architecture/source-tree.md`]

**New Files Location:**
- `src/hardware/core/ControllerRegistry.ts` - Factory pattern for controller instantiation [source-tree.md:70]
- `src/hardware/core/useControllerSelection.ts` - React hook for controller switching [source-tree.md:71]
- `src/components/Hardware/HardwareControllerSelector.tsx` - UI dropdown component [source-tree.md:82]

**Existing Files to Modify:**
- `src/components/IsometricSequencer/IsometricSequencer.tsx` - Refactor hardcoded APC40 [source-tree.md:12]
- `src/hardware/index.ts` - Add barrel exports for new modules [existing]

**Integration Guidelines:**
- File naming: camelCase for utilities, PascalCase for components [source-tree.md:93]
- Hardware module self-contained in `src/hardware/` to prevent coupling [source-tree.md:94]
- Use barrel export pattern (`hardware/index.ts`) [source-tree.md:95]

---

### Coding Standards
[Source: `architecture/coding-standards.md`]

**TypeScript Requirements:**
- Strict mode compliance enforced [coding-standards.md:4]
- ESLint rules apply to hardware modules [coding-standards.md:5]
- JSDoc comments for hardware APIs [coding-standards.md:7]

**Enhancement-Specific Standards:**
- **Hardware Interface Consistency**: All controllers implement `HardwareController` interface [coding-standards.md:10]
- **Error Boundary Pattern**: Hardware components wrapped in error boundaries to prevent app crashes [coding-standards.md:11]
- **MIDI Message Validation**: All MIDI input/output validated and sanitized [coding-standards.md:13]

**Critical Integration Rules:**
- **Existing API Compatibility**: Zero modifications to existing component interfaces [coding-standards.md:16]
- **Database Integration**: All hardware state follows existing localStorage patterns [coding-standards.md:17]
- **Error Handling**: Hardware errors isolated using React error boundaries, don't propagate to audio engine [coding-standards.md:18]

---

### Component Architecture
[Source: `architecture/component-architecture.md`]

**HardwareManager (Existing):**
- Central orchestrator for all hardware controller lifecycle management [component-architecture.md:6]
- React context provider wrapping existing App component [component-architecture.md:7]
- Key methods:
  - `useHardware()` - React hook for accessing hardware state [component-architecture.md:10]
  - `registerController(controller)` - Plugin system for adding new hardware [component-architecture.md:11]
  - `broadcastSequencerState(state)` - Distributes sequencer changes to all connected hardware [component-architecture.md:12]

**HardwareControllerSelector (New):**
- Visual feedback for hardware connection status [component-architecture.md:36]
- Integration points: Composes into existing settings panels [component-architecture.md:37]
- Dependencies: Uses existing Lucide icons, follows Tailwind design patterns [component-architecture.md:45]
- Technology stack: React functional component, Tailwind CSS, Lucide React icons [component-architecture.md:48]

---

### Data Models
[Source: `architecture/data-models-and-schema-changes.md`]

**HardwareController Interface (Existing):**
- Abstract base interface for all hardware controllers [data-models-and-schema-changes.md:6]
- Key attributes:
  - `id: string` - Unique identifier for controller instance [data-models-and-schema-changes.md:10]
  - `name: string` - Human-readable controller name [data-models-and-schema-changes.md:11]
  - `connectionStatus: 'connected' | 'disconnected' | 'error'` - Real-time connection state [data-models-and-schema-changes.md:12]
  - `capabilities: ControllerCapabilities` - Features supported by this controller [data-models-and-schema-changes.md:13]

**ControllerType (New):**
- Type union for controller selection: `'none' | 'apc40' | 'launchpad-pro-mk3' | 'launchpad-pro-2015' | 'roli-lumi'`
- Used in ControllerRegistry for factory pattern

**Storage Strategy:**
- **Runtime State**: React useState/useContext for active hardware connections [data-models-and-schema-changes.md:52]
- **Persistent Settings**: localStorage for hardware preferences (controller selection) [data-models-and-schema-changes.md:53]
- **localStorage Key**: `'centaurus:hardware:selected-controller'` (defined in this story)
- **Session State**: All hardware state cleared on app reload [data-models-and-schema-changes.md:54]

**Backward Compatibility**: Complete - no database schema exists, all new state management follows existing client-side patterns [data-models-and-schema-changes.md:56]

---

### Testing
[Source: `architecture/testing-strategy.md` + `CLAUDE.md`]

**Testing Philosophy:**
- **Manual testing** with human-in-the-loop verification (NOT automated test suites) [CLAUDE.md:9]
- Browser DevTools for debugging and performance monitoring [CLAUDE.md:10]
- Visual/audio inspection of module behavior across views [CLAUDE.md:11]

**Manual Testing Approach:**
- Developer manually tests features in browser (localhost:5173) [CLAUDE.md:21]
- Hardware integration tested with physical devices when available [CLAUDE.md:24]
- Cross-browser testing for Web MIDI API compatibility [testing-strategy.md:24]

**Testing Requirements:**
- **Unit Tests**: Not required per project philosophy [CLAUDE.md:11]
- **Integration Tests**: Manual verification of hardware ↔ sequencer synchronization [testing-strategy.md:18]
- **Regression Tests**: Manual verification that existing APC40 functionality remains unchanged [testing-strategy.md:22]

**Test Coverage:**
- Controller switching (4 scenarios) [Story 8.0 lines 865-907]
- localStorage persistence (reload test) [Story 8.0 lines 880-885]
- Unavailable controllers UI (disabled state) [Story 8.0 lines 886-892]
- Mobile responsiveness (DevTools responsive mode) [Story 8.0 lines 893-898]
- APC40 regression (LED patterns, button presses, no performance degradation) [Story 8.0 lines 900-907]

---

## Technical Specifications

### File Structure

```
src/
├── hardware/
│   ├── core/
│   │   ├── types.ts                      (✅ Existing)
│   │   ├── HardwareManager.tsx           (✅ Existing)
│   │   ├── ControllerRegistry.ts         (🆕 NEW - Story 8.0)
│   │   └── useControllerSelection.ts     (🆕 NEW - Story 8.0)
│   ├── apc40/
│   │   └── APC40Controller.ts            (✅ Existing)
│   ├── launchpad/                        (⏳ Future - Epic 8)
│   │   └── LaunchpadProController.ts
│   └── roli/                             (⏳ Future - Epic 11)
│       └── ROLILumiController.ts
├── components/
│   └── Hardware/
│       └── HardwareControllerSelector.tsx (🆕 NEW - Story 8.0)
```

---

### 1. Controller Registry

**File:** `src/hardware/core/ControllerRegistry.ts`

```typescript
/**
 * Controller Registry - Factory pattern for hardware controllers
 *
 * Centralized registration system for all hardware controller types.
 * Uses feature flags (available) to enable/disable controllers.
 */

import { HardwareController } from './types';
import { APC40Controller } from '../apc40/APC40Controller';
// Future imports (enabled after respective epics complete):
// import { LaunchpadProController } from '../launchpad/LaunchpadProController';
// import { ROLILumiController } from '../roli/ROLILumiController';

export type ControllerType =
  | 'none'
  | 'apc40'
  | 'launchpad-pro-mk3'
  | 'launchpad-pro-2015'
  | 'roli-lumi';

export interface ControllerDefinition {
  id: ControllerType;
  name: string;
  description: string;
  manufacturer: string;
  available: boolean; // Feature flag
  gridSize: string; // Display grid dimensions
  create: (deviceId?: string) => HardwareController;
}

/**
 * Global controller registry
 */
export const CONTROLLER_REGISTRY: Record<ControllerType, ControllerDefinition> = {
  'none': {
    id: 'none',
    name: 'No Controller',
    description: 'Disable hardware integration',
    manufacturer: 'N/A',
    gridSize: 'N/A',
    available: true,
    create: () => {
      throw new Error('Cannot instantiate null controller');
    }
  },

  'apc40': {
    id: 'apc40',
    name: 'Akai APC40',
    description: '5×8 grid with LED feedback',
    manufacturer: 'Akai',
    gridSize: '5×8',
    available: true, // ✅ Available now
    create: (deviceId) => new APC40Controller(deviceId)
  },

  'launchpad-pro-mk3': {
    id: 'launchpad-pro-mk3',
    name: 'Launchpad Pro Mk3',
    description: '8×8 RGB grid with velocity pads (USB-C)',
    manufacturer: 'Novation',
    gridSize: '8×8',
    available: false, // ⏳ Enable after Epic 8 Story 8.1
    create: (deviceId) => {
      throw new Error('Launchpad Pro Mk3 integration not yet implemented (Epic 8)');
      // Future: return new LaunchpadProController('mk3', deviceId);
    }
  },

  'launchpad-pro-2015': {
    id: 'launchpad-pro-2015',
    name: 'Launchpad Pro (2015)',
    description: '8×8 RGB grid with velocity pads',
    manufacturer: 'Novation',
    gridSize: '8×8',
    available: false, // ⏳ Enable after Epic 8 Story 8.1
    create: (deviceId) => {
      throw new Error('Launchpad Pro 2015 integration not yet implemented (Epic 8)');
      // Future: return new LaunchpadProController('2015', deviceId);
    }
  },

  'roli-lumi': {
    id: 'roli-lumi',
    name: 'ROLI LUMI Keys / Piano M',
    description: 'LED keyboard with per-key lighting',
    manufacturer: 'ROLI',
    gridSize: '24-key',
    available: false, // ⏳ Enable after Epic 11
    create: (deviceId) => {
      throw new Error('ROLI LUMI integration not yet implemented (Epic 11)');
      // Future: return new ROLILumiController(deviceId);
    }
  }
};

/**
 * Get available controllers (filtered by feature flag)
 */
export const getAvailableControllers = (): ControllerDefinition[] => {
  return Object.values(CONTROLLER_REGISTRY).filter(def => def.available);
};

/**
 * Get all controllers (including unavailable)
 */
export const getAllControllers = (): ControllerDefinition[] => {
  return Object.values(CONTROLLER_REGISTRY);
};

/**
 * Create controller instance from type
 * Returns null if type is 'none' or controller not available
 */
export const createController = (
  type: ControllerType,
  deviceId?: string
): HardwareController | null => {
  if (type === 'none') {
    console.log('Hardware controller disabled (type: none)');
    return null;
  }

  const definition = CONTROLLER_REGISTRY[type];

  if (!definition.available) {
    console.warn(`Controller ${type} is not yet available. Check Epic 8/11 progress.`);
    return null;
  }

  try {
    console.log(`Creating controller: ${definition.name} (${type})`);
    return definition.create(deviceId);
  } catch (error) {
    console.error(`Failed to create controller ${type}:`, error);
    return null;
  }
};

/**
 * Get controller definition by type
 */
export const getControllerDefinition = (type: ControllerType): ControllerDefinition => {
  return CONTROLLER_REGISTRY[type];
};
```

**LOC:** ~150 lines

---

### 2. Controller Selection Hook

**File:** `src/hardware/core/useControllerSelection.ts`

```typescript
/**
 * useControllerSelection - React hook for dynamic controller switching
 *
 * Manages controller lifecycle:
 * - Loads saved preference from localStorage
 * - Switches between controllers
 * - Auto-connects to selected controller
 * - Persists selection across sessions
 */

import { useState, useEffect, useCallback } from 'react';
import { useHardwareContext } from './HardwareManager';
import {
  createController,
  getAllControllers,
  getControllerDefinition,
  type ControllerType
} from './ControllerRegistry';
import type { HardwareController } from './types';

const STORAGE_KEY = 'centaurus:hardware:selected-controller';

export interface UseControllerSelectionReturn {
  selectedType: ControllerType;
  activeController: HardwareController | undefined;
  allControllers: ReturnType<typeof getAllControllers>;
  switchController: (type: ControllerType) => Promise<void>;
  isConnecting: boolean;
  connectionError: string | null;
}

export const useControllerSelection = (): UseControllerSelectionReturn => {
  const { registerController, unregisterController, controllers } = useHardwareContext();
  const [selectedType, setSelectedType] = useState<ControllerType>('none');
  const [activeControllerId, setActiveControllerId] = useState<string | null>(null);
  const [isConnecting, setIsConnecting] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);

  // Load saved preference on mount
  useEffect(() => {
    const loadSavedPreference = () => {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const type = saved as ControllerType;
          const definition = getControllerDefinition(type);

          // Only restore if controller is available
          if (definition.available) {
            console.log(`Restoring saved controller preference: ${type}`);
            setSelectedType(type);
            // Auto-connect will happen in useEffect below
          } else {
            console.warn(`Saved controller ${type} not available yet, defaulting to 'none'`);
            localStorage.removeItem(STORAGE_KEY);
          }
        }
      } catch (error) {
        console.error('Failed to load controller preference:', error);
      }
    };

    loadSavedPreference();
  }, []);

  // Auto-connect when selectedType changes
  useEffect(() => {
    if (selectedType !== 'none') {
      switchController(selectedType).catch(error => {
        console.error(`Failed to auto-connect to ${selectedType}:`, error);
      });
    }
  }, []); // Only run on mount

  /**
   * Switch to a different controller
   */
  const switchController = useCallback(async (type: ControllerType) => {
    setIsConnecting(true);
    setConnectionError(null);

    try {
      // Step 1: Disconnect and unregister previous controller
      if (activeControllerId) {
        console.log(`Disconnecting previous controller: ${activeControllerId}`);
        await unregisterController(activeControllerId);
        setActiveControllerId(null);
      }

      // Step 2: Create and register new controller
      if (type !== 'none') {
        const controller = createController(type);

        if (controller) {
          console.log(`Registering new controller: ${controller.name} (${controller.id})`);
          registerController(controller);
          setActiveControllerId(controller.id);

          // Step 3: Auto-connect to hardware
          try {
            console.log(`Connecting to ${controller.name}...`);
            await controller.connect();
            console.log(`✅ Connected to ${controller.name}`);
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown connection error';
            console.error(`Failed to connect to ${type}:`, error);
            setConnectionError(`Connection failed: ${errorMessage}`);
            // Controller remains registered but disconnected
          }
        } else {
          console.warn(`Failed to create controller for type: ${type}`);
          setConnectionError(`Controller ${type} is not available yet`);
        }
      }

      // Step 4: Save preference to localStorage
      setSelectedType(type);
      try {
        if (type === 'none') {
          localStorage.removeItem(STORAGE_KEY);
        } else {
          localStorage.setItem(STORAGE_KEY, type);
        }
      } catch (error) {
        console.error('Failed to save controller preference to localStorage:', error);
      }

    } catch (error) {
      console.error('Error during controller switch:', error);
      setConnectionError(error instanceof Error ? error.message : 'Unknown error');
    } finally {
      setIsConnecting(false);
    }
  }, [activeControllerId, registerController, unregisterController]);

  return {
    selectedType,
    activeController: controllers.find(c => c.id === activeControllerId),
    allControllers: getAllControllers(),
    switchController,
    isConnecting,
    connectionError
  };
};
```

**LOC:** ~130 lines

---

### 3. Controller Selection UI Component

**File:** `src/components/Hardware/HardwareControllerSelector.tsx`

```typescript
/**
 * HardwareControllerSelector - UI for switching hardware controllers
 *
 * Dropdown-based interface for selecting and connecting to hardware controllers.
 * Shows connection status, handles unavailable controllers, and persists selection.
 */

import React, { useState } from 'react';
import { ChevronDown, Plug, Settings as SettingsIcon, Lock } from 'lucide-react';
import { useControllerSelection } from '@/hardware/core/useControllerSelection';

export const HardwareControllerSelector: React.FC = () => {
  const {
    selectedType,
    activeController,
    allControllers,
    switchController,
    isConnecting,
    connectionError
  } = useControllerSelection();

  const [showDropdown, setShowDropdown] = useState(false);
  const dropdownRef = React.useRef<HTMLDivElement>(null);

  // Close dropdown when clicking outside
  React.useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target as Node)) {
        setShowDropdown(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const selectedDefinition = allControllers.find(c => c.id === selectedType);

  return (
    <div className="space-y-3">
      {/* Main Controller Selector */}
      <div className="flex items-center gap-2 p-4 bg-gray-800 rounded-lg border border-gray-700">
        <Plug className="w-5 h-5 text-gray-400" />

        {/* Controller Dropdown */}
        <div ref={dropdownRef} className="relative flex-1">
          <button
            onClick={() => setShowDropdown(!showDropdown)}
            disabled={isConnecting}
            className="w-full px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors flex items-center justify-between min-h-[44px] disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <div className="flex flex-col items-start">
              <span className="text-white font-medium">
                {selectedDefinition?.name || 'Select Controller'}
              </span>
              {selectedDefinition && selectedDefinition.id !== 'none' && (
                <span className="text-xs text-gray-400">
                  {selectedDefinition.manufacturer} • {selectedDefinition.gridSize}
                </span>
              )}
            </div>
            <ChevronDown className={`w-4 h-4 transition-transform ${showDropdown ? 'rotate-180' : ''}`} />
          </button>

          {/* Dropdown Menu */}
          {showDropdown && (
            <div className="absolute top-full left-0 right-0 mt-2 bg-gray-800 rounded-lg border border-gray-700 shadow-lg z-50 max-h-96 overflow-y-auto">
              <div className="p-2 space-y-1">
                {allControllers.map(definition => (
                  <button
                    key={definition.id}
                    onClick={() => {
                      if (definition.available) {
                        switchController(definition.id);
                        setShowDropdown(false);
                      }
                    }}
                    disabled={!definition.available}
                    className={`w-full px-4 py-3 text-left rounded-lg transition-colors min-h-[44px] flex items-center justify-between ${
                      definition.id === selectedType
                        ? 'bg-primary-600 text-white'
                        : definition.available
                        ? 'hover:bg-gray-700 text-gray-300'
                        : 'opacity-50 cursor-not-allowed text-gray-500'
                    }`}
                  >
                    <div className="flex flex-col">
                      <div className="flex items-center gap-2">
                        <span className="font-medium">{definition.name}</span>
                        {!definition.available && (
                          <Lock className="w-3 h-3 text-gray-500" />
                        )}
                      </div>
                      <span className="text-sm text-gray-400">
                        {definition.description}
                      </span>
                    </div>
                    {definition.id === selectedType && (
                      <span className="text-yellow-400 text-xl">✓</span>
                    )}
                  </button>
                ))}
              </div>
            </div>
          )}
        </div>

        {/* Connection Status */}
        {activeController && (
          <div className="flex items-center gap-2">
            <div className={`w-2 h-2 rounded-full ${
              isConnecting ? 'bg-yellow-500 animate-pulse' :
              activeController.connectionStatus === 'connected' ? 'bg-green-500' :
              activeController.connectionStatus === 'error' ? 'bg-red-500' :
              'bg-gray-500'
            }`} />
            <span className="text-sm text-gray-400 capitalize">
              {isConnecting ? 'Connecting...' : activeController.connectionStatus}
            </span>
          </div>
        )}

        {/* Settings Button (Future: Rotation, grid mapping, etc.) */}
        <button
          className="p-2 hover:bg-gray-700 rounded-lg transition-colors"
          title="Controller settings (coming soon)"
          disabled
        >
          <SettingsIcon className="w-5 h-5 text-gray-400" />
        </button>
      </div>

      {/* Connection Error */}
      {connectionError && (
        <div className="p-3 bg-red-900/20 border border-red-700 rounded-lg">
          <p className="text-sm text-red-400">
            ⚠️ {connectionError}
          </p>
        </div>
      )}

      {/* Info Message for "None" */}
      {selectedType === 'none' && (
        <div className="p-3 bg-gray-700/50 rounded-lg">
          <p className="text-sm text-gray-400">
            💡 <strong>Tip:</strong> Select a hardware controller above to enable LED feedback and physical button control.
          </p>
        </div>
      )}
    </div>
  );
};
```

**LOC:** ~150 lines

---

### 4. IsometricSequencer Refactoring

**File:** `src/components/IsometricSequencer/IsometricSequencer.tsx`

**Changes Required:**

```typescript
// ──────────────────────────────────────────────────────
// REMOVE (Line 205-207):
// ──────────────────────────────────────────────────────
import { APC40Controller } from '@/utils/APC40Controller'; // ❌ Remove
const [apc40Controller] = useState(() => new APC40Controller()); // ❌ Remove
const [apc40Connected, setAPC40Connected] = useState(false); // ❌ Remove
const [apc40Rotated, setAPC40Rotated] = useState(false); // ❌ Remove

// ──────────────────────────────────────────────────────
// ADD (Top of component):
// ──────────────────────────────────────────────────────
import { useHardwareContext } from '@/hardware';
import { HardwareControllerSelector } from '@/components/Hardware/HardwareControllerSelector';

// Inside component:
const { controllers, broadcastSequencerState } = useHardwareContext();
const activeController = controllers.find(c => c.connectionStatus === 'connected');

// ──────────────────────────────────────────────────────
// REPLACE hardware sync logic:
// ──────────────────────────────────────────────────────
// BEFORE (manual APC40 sync):
useEffect(() => {
  if (apc40Connected) {
    apc40Controller.updateSequencerState({ /* ... */ });
  }
}, [/* dependencies */]);

// AFTER (abstracted sync):
useEffect(() => {
  if (activeController) {
    broadcastSequencerState({
      currentStep,
      isPlaying,
      tempo,
      pattern: matrix,
      trackCount: lanes
    });
  }
}, [currentStep, isPlaying, tempo, matrix, lanes, activeController, broadcastSequencerState]);

// ──────────────────────────────────────────────────────
// ADD UI component to settings panel:
// ──────────────────────────────────────────────────────
// Find the settings panel rendering code (around line 800-900)
// Add new CollapsiblePanel:

<CollapsiblePanel
  title="Hardware Controller"
  defaultOpen={false}
  icon={<Plug className="w-5 h-5" />}
>
  <HardwareControllerSelector />
</CollapsiblePanel>
```

**Estimated Changes:**
- **Remove:** ~15 lines (hardcoded APC40 state)
- **Add:** ~30 lines (HardwareManager integration + UI)
- **Net Change:** +15 lines

---

## File Locations & Line Counts

**New Files:**
- `src/hardware/core/ControllerRegistry.ts` - ~150 lines
- `src/hardware/core/useControllerSelection.ts` - ~130 lines
- `src/components/Hardware/HardwareControllerSelector.tsx` - ~150 lines

**Modified Files:**
- `src/components/IsometricSequencer/IsometricSequencer.tsx` - ~15 line diff
- `src/hardware/index.ts` - +3 lines (export new modules)

**Total New Code:** ~430 lines
**Total Modified Code:** ~20 lines

---

## Success Metrics

### Functional Success
- [ ] User can switch from APC40 to "No Controller" without errors
- [ ] Selection persists after browser reload
- [ ] APC40 connects and functions identically to before refactoring
- [ ] Dropdown shows unavailable controllers as disabled
- [ ] Connection status indicator updates in real-time

### Performance Success
- [ ] Controller switching completes in <2 seconds
- [ ] No performance degradation in LED update rate
- [ ] HardwareManager overhead <0.8ms (5% of 16ms frame budget)

### Developer Experience Success
- [ ] Epic 8 developers can add Launchpad Pro by:
  1. Implementing `LaunchpadProController` class
  2. Setting `available: true` in registry
  3. Zero changes to IsometricSequencer
- [ ] Epic 11 developers follow same pattern for ROLI LUMI
- [ ] Future controllers follow same 3-step integration

---

## Testing Strategy

### Manual Testing Checklist

**Test 1: Controller Switching**
1. Open IsometricSequencer
2. Open settings panel → Hardware Controller section
3. Select "Akai APC40" from dropdown
4. Verify: Connection status shows "🟢 Connected"
5. Create drum pattern
6. Verify: APC40 LEDs update correctly
7. Press APC40 button
8. Verify: Step toggles in UI
9. Select "No Controller" from dropdown
10. Verify: Disconnect successful, no errors in console

**Test 2: localStorage Persistence**
1. Select "Akai APC40" from dropdown
2. Reload page (F5)
3. Verify: Dropdown shows "Akai APC40" pre-selected
4. Verify: Auto-connection attempted (status indicator updates)

**Test 3: Unavailable Controllers**
1. Open dropdown
2. Verify: "Launchpad Pro Mk3" shows 🔒 Lock icon
3. Verify: Button is disabled (cannot click)
4. Hover over disabled option
5. Verify: Tooltip or description mentions "Coming in Epic 8"

**Test 4: Mobile Responsiveness**
1. Open on mobile viewport (DevTools responsive mode)
2. Tap dropdown (verify 44px touch target)
3. Verify: Dropdown menu readable on mobile
4. Verify: Safe-area-inset respected (iOS notch)

### Regression Testing

**Verify APC40 Unchanged:**
- [ ] LED patterns render correctly
- [ ] Button presses trigger step toggles
- [ ] Rotation toggle works (if implemented)
- [ ] Connection error handling works
- [ ] No console errors during normal operation

---

## Dependencies & Blockers

### Dependencies
- ✅ `src/hardware/core/HardwareManager.tsx` - Already exists
- ✅ `src/hardware/core/types.ts` - Already exists
- ✅ `src/hardware/apc40/APC40Controller.ts` - Already exists

### Blocks
- ⚠️ **Epic 8 Story 8.1** - Cannot implement LaunchpadProController until this is complete
- ⚠️ **Epic 11** - Cannot implement ROLILumiController until this is complete

---

## Epic 8 & Epic 11 Integration Path

### Epic 8 Story 8.1: LaunchpadProController Implementation

**After Story 8.0 is complete:**

```typescript
// Step 1: Implement controller class
// src/hardware/launchpad/LaunchpadProController.ts
export class LaunchpadProController implements HardwareController {
  // ... implement interface methods
}

// Step 2: Enable in registry
// src/hardware/core/ControllerRegistry.ts
import { LaunchpadProController } from '../launchpad/LaunchpadProController';

'launchpad-pro-mk3': {
  id: 'launchpad-pro-mk3',
  name: 'Launchpad Pro Mk3',
  description: '8×8 RGB grid with velocity pads (USB-C)',
  manufacturer: 'Novation',
  gridSize: '8×8',
  available: true, // ✅ Changed from false
  create: (deviceId) => new LaunchpadProController('mk3', deviceId)
}

// Step 3: Done! Dropdown now shows Launchpad Pro as selectable
```

**Zero changes required to:**
- ❌ IsometricSequencer.tsx
- ❌ HardwareManager.tsx
- ❌ HardwareControllerSelector.tsx

---

## Definition of Done

- [ ] All 6 Acceptance Criteria met and verified
- [ ] ControllerRegistry.ts created with all controller types registered
- [ ] useControllerSelection.ts hook implemented with localStorage persistence
- [ ] HardwareControllerSelector.tsx UI component created and responsive
- [ ] IsometricSequencer.tsx refactored to use HardwareManager
- [ ] Manual testing checklist completed (4 tests passed)
- [ ] APC40 regression testing passed (no functionality lost)
- [ ] localStorage persistence verified (reload test passed)
- [ ] Mobile responsive design verified (44px touch targets)
- [ ] Code review completed
- [ ] No console errors during controller switching
- [ ] Epic 8 and Epic 11 teams notified of new integration pattern

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-21 | 1.0 | Initial story creation - Hardware Controller Selection Infrastructure | Winston (Architect) |
| 2025-10-21 | 1.1 | Added Tasks/Subtasks section and Dev Notes with architecture references. Story marked READY FOR IMPLEMENTATION. | Bob (Scrum Master) |

---

## Next Steps

1. **Implement Story 8.0** (this story) - 3-4 hours
2. **Verify APC40 regression testing** - 30 minutes
3. **Notify Epic 8 team** - Integration pattern ready
4. **Proceed with Epic 8 Story 8.1** - LaunchpadProController implementation

---

**Epic Status:** Story 8.0 (Prerequisite) → Epic 8 Story 8.1 (LaunchpadProController)
**Estimated Implementation Time:** 3-4 hours for experienced React/TypeScript developer
**Priority:** CRITICAL - Blocks Epic 8 and Epic 11

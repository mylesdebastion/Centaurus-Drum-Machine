# Story 7.7: State Synchronization (Non-Audio)

**Epic:** Epic 7 - Jam Session Backend Infrastructure (Hybrid: Supabase + WebRTC P2P)
**Status:** ðŸ“ READY FOR DEVELOPMENT
**Priority:** ðŸŸ¡ MEDIUM
**Complexity:** Low
**Time Estimate:** 2-3 hours
**Prerequisites:** Story 7.5

---

## User Story

As a **participant in a jam session**,
I want **tempo, key, scale, and playback control to sync across all users**,
So that **everyone plays in the same musical context**.

---

## Story Context

**Existing System Integration:**
- Integrates with: SupabaseSessionService (Broadcast), GlobalMusicContext, JamSession UI
- Technology: Supabase Broadcast, React Context API, TypeScript
- Follows pattern: State synchronization via Broadcast events
- Touch points: GlobalMusicHeader, playback controls, tempo slider

**Why This Story:**
State synchronization ensures all participants share the same musical parameters (tempo, key, scale). This is essential for coordinated jamming - if one user changes tempo, everyone needs to hear it. This story focuses on non-audio state (audio handled by WebRTC in Story 7.5).

---

## Acceptance Criteria

### Functional Requirements

1. **Broadcast Event Handlers in SupabaseSessionService**
   - Add methods to SupabaseSessionService:
     ```typescript
     // Listen for state changes
     channel
       .on('broadcast', { event: 'tempo-change' }, ({ payload }) => {
         // Update GlobalMusicContext
       })
       .on('broadcast', { event: 'playback-control' }, ({ payload }) => {
         // Update playback state
       })
       .on('broadcast', { event: 'key-change' }, ({ payload }) => {
         // Update key/scale
       });
     ```

2. **GlobalMusicContext Integration**
   - When user changes tempo in header â†’ broadcast to channel:
     ```typescript
     const handleTempoChange = (newTempo: number) => {
       setTempo(newTempo);
       sessionService.broadcastTempo(newTempo);
     };
     ```
   - When receiving tempo change â†’ update GlobalMusicContext:
     ```typescript
     sessionService.onTempoChange((tempo) => {
       setTempo(tempo);
     });
     ```

3. **Debounced State Updates**
   - Debounce rapid changes (100ms) to avoid message spam:
     ```typescript
     const debouncedTempoChange = useMemo(
       () => debounce((tempo: number) => {
         sessionService.broadcastTempo(tempo);
       }, 100),
       []
     );
     ```

4. **Playback Synchronization**
   - Broadcast play/stop commands:
     ```typescript
     const handlePlayPause = () => {
       const newState = !isPlaying;
       setIsPlaying(newState);
       sessionService.broadcastPlayback(newState);
     };
     ```
   - All participants receive and update:
     ```typescript
     sessionService.onPlaybackChange((isPlaying) => {
       setIsPlaying(isPlaying);
       if (isPlaying) audioEngine.start();
       else audioEngine.stop();
     });
     ```

5. **Key/Scale Synchronization**
   - Broadcast key and scale changes:
     ```typescript
     sessionService.broadcastKeyScale({ key: 'C', scale: 'major' });
     ```
   - Update GlobalMusicContext on receive:
     ```typescript
     sessionService.onKeyScaleChange(({ key, scale }) => {
       setKey(key);
       setScale(scale);
     });
     ```

6. **State Reconciliation on Join**
   - New joiner requests current state via broadcast:
     ```typescript
     // New user broadcasts request
     channel.send({
       type: 'broadcast',
       event: 'state-request',
       payload: { requesterId: myPeerId }
     });

     // Host responds with current state
     channel.on('broadcast', { event: 'state-request' }, ({ payload }) => {
       if (isHost) {
         channel.send({
           type: 'broadcast',
           event: 'state-response',
           payload: { tempo, isPlaying, key, scale }
         });
       }
     });
     ```
   - Fallback: Use default values (tempo=120, isPlaying=false, key='C', scale='major')

### Integration Requirements

7. **SupabaseSessionService Updates**
   - Add broadcast methods:
     - `broadcastTempo(tempo: number)`
     - `broadcastPlayback(isPlaying: boolean)`
     - `broadcastKeyScale({ key, scale })`
   - Add callback subscriptions:
     - `onTempoChange(callback)`
     - `onPlaybackChange(callback)`
     - `onKeyScaleChange(callback)`

8. **GlobalMusicContext Session Awareness**
   - Detect if in session (via context prop or hook)
   - If in session â†’ broadcast state changes
   - If not in session â†’ local state only

9. **Error Handling**
   - Handle broadcast failures gracefully
   - Don't block local state updates if broadcast fails
   - Log errors for debugging

### Quality Requirements

10. **User Experience**
    - State changes feel instant (<200ms propagation)
    - No UI flicker or lag when receiving updates
    - Debouncing prevents message spam

11. **Code Quality**
    - Clear separation between local and broadcast state
    - TypeScript types for all broadcast payloads
    - Proper cleanup on unmount

12. **Performance**
    - Debounce rapid changes to avoid network spam
    - Minimal impact on UI responsiveness

---

## Technical Notes

**Integration Approach:**
- Extend SupabaseSessionService with state broadcast methods
- GlobalMusicContext checks if in session before broadcasting
- Debounce rapid slider changes (tempo) to reduce messages

**Existing Pattern Reference:**
- Broadcast pattern similar to Story 7.2
- Context integration similar to Epic 4 GlobalMusicContext
- Debounce pattern similar to existing input handlers

**Key Constraints:**
- Supabase Broadcast is ephemeral (no persistence)
- Message order not guaranteed (use timestamps if needed)
- 100 messages/second limit (debouncing prevents hitting this)

---

## Definition of Done

- [ ] Broadcast event handlers added to SupabaseSessionService
- [ ] Tempo synchronization implemented
- [ ] Playback synchronization implemented
- [ ] Key/scale synchronization implemented
- [ ] Debouncing prevents message spam
- [ ] State reconciliation on join implemented
- [ ] GlobalMusicContext session-aware
- [ ] Error handling for broadcast failures
- [ ] Manual testing completed (see Testing Strategy)

---

## Testing Strategy

### Manual Testing (Per CLAUDE.md Guidelines)

**Test 1: Tempo Synchronization**
1. Two users in same session (Alice, Bob)
2. Alice changes tempo from 120 to 140
3. Verify on Bob's device:
   - âœ… Tempo updates to 140 within 200ms
   - âœ… UI slider reflects new tempo
   - âœ… Audio playback adjusts to new tempo

**Test 2: Playback Synchronization**
1. Alice clicks "Play" button
2. Verify on Bob's device:
   - âœ… Playback starts within 200ms
   - âœ… Play button shows "Pause" state
3. Alice clicks "Pause" button
4. Verify on Bob's device:
   - âœ… Playback stops within 200ms

**Test 3: Key/Scale Synchronization**
1. Alice changes key to "D" and scale to "minor"
2. Verify on Bob's device:
   - âœ… Key updates to "D minor"
   - âœ… UI reflects new key/scale
   - âœ… Audio respects new musical context

**Test 4: State Reconciliation on Join**
1. Alice creates session with tempo=140, key=D, scale=minor
2. Bob joins session
3. Verify on Bob's device:
   - âœ… Tempo shows 140 (not default 120)
   - âœ… Key shows "D minor"
   - âœ… Playback state matches Alice's

**Test 5: Debounce Prevents Spam**
1. Alice rapidly drags tempo slider (120â†’180 over 1 second)
2. Monitor network tab in DevTools
3. Verify:
   - âœ… <10 broadcast messages sent (not 60+)
   - âœ… Final tempo (180) received correctly

### Verification Checklist

- âœ… Host changing tempo updates all participants within 200ms
- âœ… Any participant changing tempo syncs to everyone
- âœ… Play/stop commands synchronize across all participants
- âœ… Key/scale changes synchronize correctly
- âœ… New joiner receives current session state
- âœ… Rapid tempo changes debounced (not spamming messages)

---

## Risk and Compatibility Check

### Minimal Risk Assessment

**Primary Risk:** State desync due to network latency or message loss
**Mitigation:**
- State reconciliation on join ensures new users get current state
- Broadcast is reliable within Supabase Realtime
- If critical desync occurs, users can leave and rejoin
- Future: Add periodic state sync heartbeat if needed

**Secondary Risk:** Message spam from rapid slider changes
**Mitigation:**
- Debounce slider changes (100ms)
- Monitor Supabase dashboard for message rate
- 100 messages/second limit provides safety margin

### Compatibility Verification

- [x] **No breaking changes** - Extends existing services and contexts
- [x] **Database changes** - None
- [x] **UI changes** - None (reuse existing GlobalMusicHeader)
- [x] **Performance impact** - Negligible

---

## Scope Validation

- [x] Story can be completed in **2-3 hours** (one short session)
- [x] Integration approach is straightforward (extend existing service)
- [x] Follows existing patterns (Broadcast, Context API)
- [x] No design work required (reuse existing UI)

---

## Deliverables

1. **Updated SupabaseSessionService**
   - `src/services/supabaseSession.ts` (modified, ~80 lines added)
   - State broadcast methods and callbacks

2. **Updated GlobalMusicContext**
   - `src/contexts/GlobalMusicContext.tsx` (modified, ~50 lines added)
   - Session awareness and broadcast integration

3. **Debounce Utility**
   - Reuse existing debounce utility or create if missing
   - Used for tempo slider changes

---

## Next Steps After Story 7.7

Once this story is complete, proceed to:
- **Story 7.8:** Error Handling & Connection Resilience (3-4 hours)
  - Add comprehensive error handling for Supabase and WebRTC

---

## References

- **Epic 7:** `docs/epics/epic-7-jam-session-backend.md`
- **Story 7.2:** `docs/stories/7.2-supabase-realtime-service.md`
- **Story 7.5:** `docs/stories/7.5-webrtc-p2p-audio.md`
- **Epic 4:** GlobalMusicContext (existing state management)

---

**Story Created:** 2025-10-13
**Story Owner:** Product Manager (John)
**Estimated Completion:** 2-3 hours after start

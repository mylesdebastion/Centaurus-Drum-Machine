# Story 10.3: Controller Profile Library (Popular Controllers)

## Status
Draft

## Story
**As a** music producer,
**I want** native support for my Novation Launchpad / Akai MPK Mini / Arturia BeatStep,
**so that** I can use my preferred hardware controller without complex manual configuration.

## Acceptance Criteria
1. Implement Novation Launchpad Mini MK3 profile (8x8 grid, RGB LEDs, SysEx)
2. Implement Akai MPK Mini MK3 profile (25 keys, 8 pads, 8 knobs)
3. Implement Arturia BeatStep profile (16 pads, 16 encoders, transport controls)
4. Create consistent UI for controller-specific settings (brightness, color modes, button mapping)
5. Build automated testing suite for controller profiles using virtual MIDI devices
6. Document controller profile creation API for community contributions

## Integration Verification
- **IV1**: All three new controllers work simultaneously with existing APC40 without conflicts
- **IV2**: LED feedback latency remains <50ms for all controllers under typical load
- **IV3**: Controller hot-swap (connect/disconnect) doesn't affect audio playback or sequencer state

## Tasks / Subtasks

- [ ] **Task 1: Implement Novation Launchpad Mini MK3 Profile** (AC: 1)
  - [ ] Create `src/hardware/controllers/launchpad-mini-mk3/LaunchpadMiniMK3Controller.ts`
  - [ ] Implement 8x8 grid → 16-step sequencer mapping (use multiple pages/banks)
  - [ ] Add RGB LED support with 128 color palette
  - [ ] Implement SysEx mode switching (Programmer Mode for LED control)
  - [ ] Map transport controls (play, stop, record) to Launchpad buttons
  - [ ] Handle velocity-sensitive pads for pattern input
  - [ ] Create Launchpad-specific settings UI (LED brightness, button modes)
  - [ ] Document MIDI implementation reference from Novation spec

- [ ] **Task 2: Implement Akai MPK Mini MK3 Profile** (AC: 2)
  - [ ] Create `src/hardware/controllers/mpk-mini-mk3/MPKMiniMK3Controller.ts`
  - [ ] Map 25 mini-keys to chromatic note input
  - [ ] Map 8 velocity-sensitive pads to drum triggers
  - [ ] Implement 8 rotary knobs for parameter control (tempo, swing, filter)
  - [ ] Add joystick support for pitch bend and modulation
  - [ ] Implement arpeggiator mode using MPK's built-in arpeggiator
  - [ ] Map transport buttons (play, stop, record) to sequencer controls
  - [ ] Create MPK-specific settings (pad sensitivity, knob assignments)

- [ ] **Task 3: Implement Arturia BeatStep Profile** (AC: 3)
  - [ ] Create `src/hardware/controllers/beatstep/BeatStepController.ts`
  - [ ] Map 16 velocity-sensitive pads to 16-step sequencer
  - [ ] Implement 16 rotary encoders for per-step parameter control
  - [ ] Add transport controls (play, stop, record, tap tempo)
  - [ ] Implement BeatStep's CV/Gate mode (if supported via MIDI)
  - [ ] Map sequencer sync controls (internal/external clock)
  - [ ] Handle BeatStep's step sequencing modes (forward, reverse, ping-pong)
  - [ ] Create BeatStep-specific settings (pad velocity curve, encoder sensitivity)

- [ ] **Task 4: Create Unified Controller Settings UI** (AC: 4)
  - [ ] Design `ControllerSettingsPanel.tsx` component
  - [ ] Implement brightness slider (applies to all LED-capable controllers)
  - [ ] Create color mode selector (chromatic, velocity-based, custom)
  - [ ] Add button mapping editor (drag-and-drop or select mode)
  - [ ] Implement per-controller preset save/load
  - [ ] Design controller-specific advanced settings (collapsible sections)
  - [ ] Test settings persistence across browser sessions

- [ ] **Task 5: Build Automated Testing Suite** (AC: 5)
  - [ ] Create `tests/controllers/` directory for controller-specific tests
  - [ ] Implement virtual MIDI device simulator for testing
  - [ ] Write unit tests for each controller's MIDI message handling
  - [ ] Create integration tests for multi-controller scenarios
  - [ ] Add LED feedback timing tests (verify <50ms latency)
  - [ ] Implement snapshot testing for controller profile schemas
  - [ ] Create regression test suite for APC40 backward compatibility

- [ ] **Task 6: Document Controller Profile Creation API** (AC: 6)
  - [ ] Write comprehensive developer guide: `docs/controller-api.md`
  - [ ] Document ControllerProfile interface with TypeScript types
  - [ ] Provide example controller implementation (minimal viable controller)
  - [ ] Explain MIDI message mapping patterns and best practices
  - [ ] Document LED control patterns and color mapping utilities
  - [ ] Create troubleshooting guide for common integration issues
  - [ ] Add contribution guidelines for community controller submissions

- [ ] **Task 7: Multi-Controller Coordination Testing** (IV: 1)
  - [ ] Test Launchpad + APC40 simultaneous operation
  - [ ] Test MPK Mini + BeatStep simultaneous operation
  - [ ] Verify all four controllers work together without MIDI conflicts
  - [ ] Test rapid controller switching (connect/disconnect all four)
  - [ ] Validate state synchronization across all controllers
  - [ ] Check for memory leaks with multiple controllers loaded

- [ ] **Task 8: LED Feedback Performance Optimization** (IV: 2)
  - [ ] Profile LED update performance for each controller
  - [ ] Implement LED update batching for multiple controllers
  - [ ] Optimize MIDI message throttling (avoid flooding USB)
  - [ ] Add performance monitoring dashboard in dev tools
  - [ ] Test LED latency under high sequencer tempo (200+ BPM)
  - [ ] Verify <50ms latency across all controllers

- [ ] **Task 9: Hot-Swap Resilience Testing** (IV: 3)
  - [ ] Test controller disconnect during active playback (audio shouldn't glitch)
  - [ ] Test controller reconnect during playback (should resume LED feedback)
  - [ ] Verify sequencer state preserved when controller disconnected
  - [ ] Test rapid connect/disconnect cycles (prevent race conditions)
  - [ ] Validate error recovery when controller enters fault state
  - [ ] Test USB port switching (same controller, different port)

## Dev Notes

### Relevant Architecture Context

**Hardware Abstraction Layer** (from Story 10.1):
- ControllerRegistry provides plugin registration
- ControllerProfile schema defines structure for all controllers
- Hot-swap mechanism handles runtime loading/unloading
- Feature gating enforces Pro tier requirement for new controllers

**MIDI Message Patterns**:
- **Note On/Off**: Use for pad triggers, key presses
- **Control Change (CC)**: Use for knobs, faders, buttons
- **SysEx**: Use for LED control, mode switching, device initialization
- **Clock**: Use for transport sync, tempo tracking

**LED Control Strategies**:
- **Launchpad**: SysEx RGB LED commands (fast, flexible)
- **APC40**: Note On velocity for LED color (legacy pattern)
- **MPK Mini**: Limited LED feedback (pad LEDs only)
- **BeatStep**: Note On for pad LEDs, no encoder LEDs

**Performance Constraints**:
- USB MIDI bandwidth: ~3125 bytes/sec (31.25 kbaud)
- Throttle LED updates to 60fps max (16ms intervals)
- Batch LED commands when possible (reduce message overhead)
- Use delta compression (only send changed LEDs)

### Source Tree Context

```
src/
├── hardware/
│   ├── controllers/
│   │   ├── apc40/                        # Existing (Epic 1)
│   │   │   └── APC40Controller.ts
│   │   ├── launchpad-mini-mk3/          # NEW - This story
│   │   │   ├── LaunchpadMiniMK3Controller.ts
│   │   │   ├── LaunchpadMiniMK3Profile.json
│   │   │   └── LaunchpadLEDUtils.ts
│   │   ├── mpk-mini-mk3/                # NEW - This story
│   │   │   ├── MPKMiniMK3Controller.ts
│   │   │   ├── MPKMiniMK3Profile.json
│   │   │   └── MPKMidiMap.ts
│   │   ├── beatstep/                    # NEW - This story
│   │   │   ├── BeatStepController.ts
│   │   │   ├── BeatStepProfile.json
│   │   │   └── BeatStepSequencer.ts
│   │   └── shared/                      # NEW - Shared utilities
│   │       ├── LEDColorUtils.ts
│   │       ├── MIDIMessageBuilder.ts
│   │       └── VelocityCurve.ts
│   └── registry/
│       └── ControllerRegistry.ts         # From Story 10.1
├── components/
│   └── hardware/
│       ├── ControllerSettingsPanel.tsx  # NEW - This story
│       └── ControllerPresetManager.tsx  # NEW - This story
└── tests/
    ├── controllers/                     # NEW - This story
    │   ├── launchpad.test.ts
    │   ├── mpk-mini.test.ts
    │   ├── beatstep.test.ts
    │   └── multi-controller.test.ts
    └── utils/
        └── VirtualMIDIDevice.ts          # NEW - Testing utility
```

### Controller Specifications

**Novation Launchpad Mini MK3**:
- 8x8 RGB LED pad grid (64 pads total)
- Additional control buttons (Scene Launch, Stop/Solo/Mute)
- USB MIDI class-compliant
- Programmer Mode via SysEx for RGB LED control
- 128-color palette (7-bit RGB: 3R, 3G, 2B)
- Reference: [Novation Launchpad Mini MK3 Programmer's Reference](https://fael-downloads-prod.focusrite.com/customer/prod/s3fs-public/downloads/Launchpad%20Mini%20MK3%20Programmers%20Reference%20Manual.pdf)

**Akai MPK Mini MK3**:
- 25 velocity-sensitive mini-keys
- 8 backlit velocity-sensitive MPC pads
- 8 assignable knobs with LED rings
- 4-way joystick (pitch bend, modulation)
- Built-in arpeggiator
- USB MIDI + USB-C power
- Reference: [MPK Mini MK3 MIDI Implementation](https://www.akaipro.com/mpk-mini-mk3)

**Arturia BeatStep**:
- 16 velocity-sensitive RGB pads
- 16 rotary encoders with LED rings
- Transport controls (play, stop, record)
- Step sequencer modes (forward, reverse, random, ping-pong)
- CV/Gate outputs (not directly accessible via MIDI)
- USB MIDI + MIDI DIN ports
- Reference: [BeatStep User Manual](https://www.arturia.com/support/manuals)

### Key Design Decisions

**Controller Priority**: Launchpad > MPK Mini > BeatStep based on market research and user requests.

**MIDI Implementation**: Each controller gets dedicated TypeScript class implementing `HardwareController` interface. Keeps controller logic isolated and testable.

**LED Feedback**: Prioritize Launchpad (best LED support). MPK Mini has limited LEDs. BeatStep has good pad LEDs.

**Settings Persistence**: Store per-controller settings in localStorage with controller ID namespace. Allows different brightness/color modes per device.

**Virtual MIDI Testing**: Use WebMIDI API shim to create virtual devices. Enables automated testing without physical hardware.

### Testing

**Unit Tests** (`tests/controllers/*.test.ts`):
- MIDI message parsing for each controller
- LED command generation
- Button mapping logic
- Settings save/load

**Integration Tests** (`tests/integration/multi-controller.test.ts`):
- Multi-controller scenarios (2-4 controllers)
- Hot-swap during playback
- LED synchronization across controllers
- State consistency

**Performance Tests**:
- LED update latency benchmarks (<50ms requirement)
- USB MIDI bandwidth utilization
- Memory usage with multiple controllers
- CPU profiling during high-tempo playback

**Testing Standards**:
- Use Vitest for unit tests
- Mock Web MIDI API for deterministic tests
- Create virtual MIDI device simulator
- Minimum 75% code coverage per controller
- Snapshot testing for controller profiles

### Community Contribution Guidelines

**Controller Profile Submission Process**:
1. Fork `centaurus-controller-lib` repo (future Story 10.5)
2. Create controller profile following template
3. Implement controller class extending `BaseController`
4. Add unit tests (minimum 70% coverage)
5. Submit PR with demo video showing controller in action
6. Community review + maintainer approval
7. Published to npm as part of library

**Profile Quality Requirements**:
- Complete MIDI implementation documentation
- LED feedback for all supported features
- Settings UI integration
- Automated tests included
- No proprietary/licensed assets (icons, logos)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-10 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_

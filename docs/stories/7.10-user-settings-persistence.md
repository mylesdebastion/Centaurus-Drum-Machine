# Story 7.10: User Settings Persistence (Supabase Backend)

**Epic:** Epic 7 - Jam Session Backend Infrastructure
**Status:** üìù PLANNING
**Priority:** üü° MEDIUM
**Complexity:** Medium
**Time Estimate:** 4-6 hours
**Prerequisites:** Story 7.1 (Supabase Setup), Story 18.0 (User Authentication)

---

## User Story

As an **authenticated user**,
I want **my app settings automatically saved to the cloud and applied on startup**,
So that **I have a consistent workspace experience across all devices and sessions**.

---

## Story Context

### Why This Story

**Primary Motivation:** Workshop instructor use case (from workshop planning)
- Educator configures 6 WLED tubes once (IP addresses, colors, layout)
- Opens app on any device ‚Üí settings automatically applied
- **Zero setup time** on workshop day

**Secondary Benefits:**
- Pro users: Hardware controller mappings sync across devices
- Jam session hosts: Preferred tempo/key/audio settings persist
- All users: Seamless upgrade from anonymous ‚Üí authenticated (settings migrate)

**Current State:**
- ‚úÖ Settings stored in localStorage (device-specific, volatile)
- ‚úÖ User authentication working (Story 18.0)
- ‚ùå No cloud settings sync
- ‚ùå No cross-device settings persistence

**Desired State:**
- ‚úÖ Authenticated users: Settings sync to Supabase
- ‚úÖ Anonymous users: Continue using localStorage (backward compatible)
- ‚úÖ Settings auto-load on app startup (<300ms latency)
- ‚úÖ Auto-save with 30-second debounce (prevent excessive writes)

---

## Acceptance Criteria

### Functional Requirements

1. **Database Schema**
   - `user_settings` table created in Supabase:
     ```sql
     CREATE TABLE user_settings (
       id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
       user_id UUID REFERENCES auth.users(id) NOT NULL,
       settings_category TEXT NOT NULL,
       settings_data JSONB NOT NULL DEFAULT '{}'::jsonb,
       created_at TIMESTAMPTZ DEFAULT NOW(),
       updated_at TIMESTAMPTZ DEFAULT NOW(),
       UNIQUE(user_id, settings_category)
     );
     ```
   - RLS policies enforced (users can only access own settings)
   - Indexes created for fast queries (`user_id`, `settings_category`)

2. **Settings Categories**
   Settings organized into discrete categories:
   - `audio`: Tempo, key, scale, metronome, volume
   - `wled`: WLED device registry, visualization mode, brightness
   - `hardware`: Controller mappings (APC40, future controllers)
   - `ui`: Theme, tooltips, compact mode, default view
   - `jam`: Default username, room size, audio input device
   - `license`: Read-only license status (managed by Epic 3)

3. **SettingsService Implementation**
   - `SettingsService.loadFromSupabase(userId)` - Load all settings
   - `SettingsService.saveToSupabase(userId, category, data)` - Save specific category
   - `SettingsService.loadFromLocalStorage()` - Fallback for anonymous users
   - `SettingsService.saveToLocalStorage(category, data)` - Backup storage
   - `SettingsService.migrateToSupabase(userId, localSettings)` - Migration helper
   - `SettingsService.getDefaultSettings()` - Factory defaults

4. **useSettings Hook**
   ```typescript
   function useSettings() {
     const { user, isAuthenticated } = useAuth();
     const [settings, setSettings] = useState<AllUserSettings>({});
     const [loading, setLoading] = useState(true);
     const [syncing, setSyncing] = useState(false);

     // Load settings on auth state change
     useEffect(() => {
       if (isAuthenticated) {
         loadFromSupabase(user.id);
       } else {
         loadFromLocalStorage();
       }
     }, [user, isAuthenticated]);

     // Debounced save (30s)
     const saveSettings = useDebouncedCallback((category, data) => {
       if (isAuthenticated) {
         saveToSupabase(user.id, category, data);
       } else {
         saveToLocalStorage(category, data);
       }
     }, 30000);

     return { settings, loading, syncing, saveSettings };
   }
   ```

5. **GlobalMusicContext Integration**
   - Add settings state to context:
     ```typescript
     interface GlobalMusicState {
       // ... existing fields
       settings: AllUserSettings;
       settingsLoading: boolean;
       settingsSyncing: boolean;
       updateAudioSettings: (settings: Partial<AudioSettings>) => void;
       updateWLEDSettings: (settings: Partial<WLEDSettings>) => void;
       updateUISettings: (settings: Partial<UISettings>) => void;
       resetSettings: () => void;
     }
     ```
   - Apply settings on load (tempo, key, scale auto-set from settings)
   - Sync settings changes back to backend (debounced)

6. **Startup Settings Load**
   - On app initialization:
     1. Check auth status (useAuth)
     2. Load settings (useSettings)
     3. Apply to GlobalMusicContext state
     4. Render app with user settings applied
   - **Latency Target:**
     - Anonymous users: <10ms (localStorage, synchronous)
     - Authenticated users: <300ms (Supabase fetch, async)
   - **Loading UX:**
     - Show skeleton screens during load
     - Never block rendering (show defaults, then hydrate)

7. **Auto-Save with Debounce**
   - When user changes setting (e.g., tempo 120 ‚Üí 140):
     - Update state immediately (optimistic update)
     - Start 30-second debounce timer
     - If no more changes in 30s ‚Üí save to backend
     - If user makes another change ‚Üí reset timer
   - Show "Syncing..." indicator when saving
   - Show "Synced" checkmark when complete

8. **Offline Fallback**
   - If Supabase unavailable (network error):
     - Fall back to localStorage automatically
     - Show warning: "Offline mode - settings saved locally"
     - When network reconnects ‚Üí auto-sync to Supabase

### Integration Requirements

9. **Backward Compatibility**
   - Anonymous users continue using localStorage (no breaking changes)
   - Existing localStorage keys preserved:
     - `wled-devices`
     - `global-tempo`
     - `global-key`
     - `jam-username`
   - Migration helper reads these keys when user signs up

10. **TypeScript Type Safety**
    - `AllUserSettings` interface (union of all category settings)
    - Category-specific interfaces:
      - `AudioSettings`
      - `WLEDSettings`
      - `HardwareSettings`
      - `UISettings`
      - `JamSettings`
      - `LicenseSettings` (read-only)
    - Validation functions for each category

### Quality Requirements

11. **Performance**
    - Settings load completes <300ms (authenticated users)
    - No UI blocking during load (show loading state)
    - Auto-save doesn't impact UX (background operation)

12. **Security**
    - RLS policies prevent cross-user access
    - Settings data validated before save (prevent malicious injection)
    - Max size per category: 100 KB (prevent storage abuse)

13. **Error Handling**
    - Network errors ‚Üí fallback to localStorage
    - Invalid settings data ‚Üí use factory defaults
    - Supabase errors ‚Üí show user-friendly message
    - Failed migration ‚Üí preserve localStorage, show warning

---

## Technical Approach

### Phase 1: Database Migration (1 hour)

**Create Migration File:**
```sql
-- supabase/migrations/003_create_user_settings.sql

CREATE TABLE user_settings (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  settings_category TEXT NOT NULL,
  settings_data JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(user_id, settings_category)
);

-- RLS Policies
ALTER TABLE user_settings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own settings"
  ON user_settings FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own settings"
  ON user_settings FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own settings"
  ON user_settings FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own settings"
  ON user_settings FOR DELETE
  USING (auth.uid() = user_id);

-- Indexes
CREATE INDEX idx_user_settings_user_id ON user_settings(user_id);
CREATE INDEX idx_user_settings_category ON user_settings(user_id, settings_category);

-- Auto-update timestamp
CREATE TRIGGER update_user_settings_updated_at
  BEFORE UPDATE ON user_settings
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

**Apply Migration:**
```bash
# Local development
supabase db push

# Production
# Apply via Supabase Dashboard ‚Üí SQL Editor
```

### Phase 2: TypeScript Types (30 min)

**Create Type Definitions:**
```typescript
// src/types/settings.ts

export type SettingsCategory =
  | 'wled'
  | 'audio'
  | 'hardware'
  | 'ui'
  | 'jam'
  | 'license';

export interface UserSettings {
  id: string;
  user_id: string;
  settings_category: SettingsCategory;
  settings_data: Record<string, unknown>;
  created_at: string;
  updated_at: string;
}

export interface AudioSettings {
  tempo: number;
  key: string;
  scale: string;
  metronomeEnabled: boolean;
  metronomeVolume: number;
  masterVolume: number;
}

export interface WLEDSettings {
  devices: Array<{
    id: string;
    ipAddress: string;
    name: string;
    enabled: boolean;
    color: string;
    ledCount: number;
  }>;
  defaultVisualizationMode: 'spectrum' | 'waveform' | 'matrix';
  defaultBrightness: number;
}

export interface UISettings {
  theme: 'dark' | 'light';
  compactMode: boolean;
  showTooltips: boolean;
  defaultView: 'drum-machine' | 'jam-session' | 'studio';
}

export interface JamSettings {
  defaultRoomSize: number;
  audioInputDevice: 'microphone' | 'line-in';
  defaultUsername: string;
  autoJoinLastSession: boolean;
}

export interface AllUserSettings {
  wled?: WLEDSettings;
  audio?: AudioSettings;
  hardware?: Record<string, unknown>;
  ui?: UISettings;
  jam?: JamSettings;
  license?: Record<string, unknown>;
}
```

### Phase 3: SettingsService (2 hours)

**Implementation:**
```typescript
// src/services/SettingsService.ts

import { supabase } from '@/lib/supabase';
import { SettingsCategory, AllUserSettings } from '@/types/settings';

export class SettingsService {
  static async loadFromSupabase(userId: string): Promise<AllUserSettings> {
    const { data, error } = await supabase
      .from('user_settings')
      .select('*')
      .eq('user_id', userId);

    if (error) {
      console.error('Failed to load settings:', error);
      return this.getDefaultSettings();
    }

    const settingsMap: AllUserSettings = {};
    data?.forEach(row => {
      settingsMap[row.settings_category] = row.settings_data;
    });

    return settingsMap;
  }

  static async saveToSupabase(
    userId: string,
    category: SettingsCategory,
    data: Record<string, unknown>
  ): Promise<void> {
    // Validate settings before save
    if (!this.validateSettings(category, data)) {
      throw new Error(`Invalid settings for category: ${category}`);
    }

    const { error } = await supabase
      .from('user_settings')
      .upsert({
        user_id: userId,
        settings_category: category,
        settings_data: data,
      }, {
        onConflict: 'user_id,settings_category'
      });

    if (error) {
      console.error(`Failed to save ${category} settings:`, error);
      throw error;
    }
  }

  static loadFromLocalStorage(): AllUserSettings {
    const settings: AllUserSettings = {};

    try {
      const wledDevices = localStorage.getItem('wled-devices');
      if (wledDevices) settings.wled = JSON.parse(wledDevices);

      const tempo = localStorage.getItem('global-tempo');
      const key = localStorage.getItem('global-key');
      if (tempo || key) {
        settings.audio = {
          tempo: tempo ? parseInt(tempo) : 120,
          key: key || 'C',
          scale: localStorage.getItem('global-scale') || 'major',
          metronomeEnabled: false,
          metronomeVolume: 0.5,
          masterVolume: 1.0,
        };
      }

      const jamUsername = localStorage.getItem('jam-username');
      if (jamUsername) {
        settings.jam = {
          defaultRoomSize: 4,
          audioInputDevice: 'microphone',
          defaultUsername: jamUsername,
          autoJoinLastSession: false,
        };
      }
    } catch (error) {
      console.error('Failed to load from localStorage:', error);
    }

    return settings;
  }

  static saveToLocalStorage(category: SettingsCategory, data: Record<string, unknown>): void {
    try {
      if (category === 'wled') {
        localStorage.setItem('wled-devices', JSON.stringify(data));
      } else if (category === 'audio') {
        localStorage.setItem('global-tempo', String(data.tempo));
        localStorage.setItem('global-key', String(data.key));
        localStorage.setItem('global-scale', String(data.scale));
      } else if (category === 'jam') {
        localStorage.setItem('jam-username', String(data.defaultUsername));
      }
    } catch (error) {
      console.error(`Failed to save to localStorage:`, error);
    }
  }

  static async migrateToSupabase(userId: string, localSettings: AllUserSettings): Promise<void> {
    const categories = Object.keys(localSettings) as SettingsCategory[];

    for (const category of categories) {
      const data = localSettings[category];
      if (data) {
        await this.saveToSupabase(userId, category, data);
      }
    }
  }

  static validateSettings(category: SettingsCategory, data: unknown): boolean {
    // Size validation
    const jsonSize = JSON.stringify(data).length;
    if (jsonSize > 100000) return false; // Max 100 KB

    // Category-specific validation
    if (category === 'audio') {
      const audio = data as AudioSettings;
      if (audio.tempo < 40 || audio.tempo > 300) return false;
    }

    return true;
  }

  static getDefaultSettings(): AllUserSettings {
    return {
      audio: {
        tempo: 120,
        key: 'C',
        scale: 'major',
        metronomeEnabled: false,
        metronomeVolume: 0.5,
        masterVolume: 1.0,
      },
      ui: {
        theme: 'dark',
        compactMode: false,
        showTooltips: true,
        defaultView: 'drum-machine',
      },
      jam: {
        defaultRoomSize: 4,
        audioInputDevice: 'microphone',
        defaultUsername: '',
        autoJoinLastSession: false,
      },
    };
  }
}
```

### Phase 4: useSettings Hook (1 hour)

**Implementation:**
```typescript
// src/hooks/useSettings.ts

import { useEffect, useState, useCallback } from 'react';
import { useAuth } from './useAuth';
import { SettingsService } from '@/services/SettingsService';
import { AllUserSettings, SettingsCategory } from '@/types/settings';
import { useDebouncedCallback } from 'use-debounce';

export function useSettings() {
  const { user, isAuthenticated } = useAuth();
  const [settings, setSettings] = useState<AllUserSettings>({});
  const [loading, setLoading] = useState(true);
  const [syncing, setSyncing] = useState(false);

  // Load settings on auth state change
  useEffect(() => {
    async function loadSettings() {
      setLoading(true);

      if (isAuthenticated && user) {
        const cloudSettings = await SettingsService.loadFromSupabase(user.id);
        setSettings(cloudSettings);
      } else {
        const localSettings = SettingsService.loadFromLocalStorage();
        setSettings(localSettings);
      }

      setLoading(false);
    }

    loadSettings();
  }, [user, isAuthenticated]);

  // Debounced save (30 seconds)
  const saveSettings = useDebouncedCallback(
    async (category: SettingsCategory, data: Record<string, unknown>) => {
      setSyncing(true);

      try {
        if (isAuthenticated && user) {
          await SettingsService.saveToSupabase(user.id, category, data);
        } else {
          SettingsService.saveToLocalStorage(category, data);
        }
      } catch (error) {
        console.error('Failed to save settings:', error);
        // Fallback to localStorage on error
        SettingsService.saveToLocalStorage(category, data);
      }

      setSyncing(false);
    },
    30000 // 30 seconds
  );

  const migrateSettings = useCallback(async () => {
    if (!user) return;

    const localSettings = SettingsService.loadFromLocalStorage();
    await SettingsService.migrateToSupabase(user.id, localSettings);
  }, [user]);

  return {
    settings,
    loading,
    syncing,
    saveSettings,
    migrateSettings,
  };
}
```

### Phase 5: GlobalMusicContext Integration (1 hour)

**Extend Context:**
```typescript
// src/contexts/GlobalMusicContext.tsx

import { useSettings } from '@/hooks/useSettings';

export interface GlobalMusicState {
  // ... existing fields
  settings: AllUserSettings;
  settingsLoading: boolean;
  settingsSyncing: boolean;
  updateAudioSettings: (settings: Partial<AudioSettings>) => void;
}

export const GlobalMusicProvider: React.FC = ({ children }) => {
  const { settings, loading, syncing, saveSettings } = useSettings();

  // Apply settings on load
  useEffect(() => {
    if (!loading && settings.audio) {
      setTempo(settings.audio.tempo);
      setKey(settings.audio.key);
      setScale(settings.audio.scale);
    }
  }, [loading, settings]);

  // Update audio settings
  const updateAudioSettings = useCallback((newSettings: Partial<AudioSettings>) => {
    const updated = { ...settings.audio, ...newSettings };
    saveSettings('audio', updated);

    // Optimistic update
    if (newSettings.tempo) setTempo(newSettings.tempo);
    if (newSettings.key) setKey(newSettings.key);
  }, [settings, saveSettings]);

  const contextValue = useMemo(() => ({
    // ... existing values
    settings,
    settingsLoading: loading,
    settingsSyncing: syncing,
    updateAudioSettings,
  }), [settings, loading, syncing]);

  return (
    <GlobalMusicContext.Provider value={contextValue}>
      {children}
    </GlobalMusicContext.Provider>
  );
};
```

---

## Integration Verification

### Manual Testing Steps

**Test 1: Anonymous User Settings (Backward Compatibility)**
1. Open app in incognito mode (no auth)
2. Change tempo to 140 BPM
3. Reload page
4. Verify tempo = 140 (loaded from localStorage)
5. **Expected:** No Supabase calls, localStorage-only operation

**Test 2: Authenticated User Settings Sync**
1. Sign in with test account
2. Change tempo to 160 BPM
3. Wait 30 seconds (auto-save debounce)
4. Check Supabase database:
   ```sql
   SELECT * FROM user_settings WHERE user_id = '<user-id>';
   ```
5. Verify `audio` settings row exists with tempo = 160
6. **Expected:** Settings saved to Supabase

**Test 3: Cross-Device Sync**
1. Sign in on Device A
2. Change tempo to 100 BPM, key to "D"
3. Wait 30 seconds (auto-save)
4. Sign in on Device B (same account)
5. Verify tempo = 100, key = "D" on startup
6. **Expected:** Settings auto-applied from Supabase

**Test 4: Anonymous ‚Üí Authenticated Migration**
1. Use app anonymously
2. Set tempo to 130 BPM (saved to localStorage)
3. Sign up for account
4. Run migration: `useSettings().migrateSettings()`
5. Check database: `SELECT * FROM user_settings WHERE user_id = '<user-id>'`
6. Verify tempo = 130 (migrated from localStorage)
7. **Expected:** localStorage settings transferred to Supabase

**Test 5: Offline Fallback**
1. Sign in (authenticated)
2. Disconnect network
3. Change tempo to 150 BPM
4. Verify saved to localStorage (fallback)
5. Reconnect network
6. Wait 30 seconds
7. Verify synced to Supabase
8. **Expected:** Graceful offline ‚Üí online transition

**Test 6: RLS Policy Enforcement**
```sql
-- Create User A and User B via Supabase Auth

-- As User A, insert settings
INSERT INTO user_settings (user_id, settings_category, settings_data)
VALUES ('<user-a-id>', 'audio', '{"tempo": 120}');

-- As User B, attempt to read User A's settings
SELECT * FROM user_settings WHERE user_id = '<user-a-id>';
-- Expected: 0 rows (RLS blocks access)
```

---

## Dependencies

### Prerequisites
- ‚úÖ **Story 7.1 Complete:** Supabase project setup
- ‚úÖ **Story 18.0 Complete:** User authentication (user_profiles table)

### Blocks These Stories
- ‚è≥ **Story 18.11:** Settings Migration UI (uses `migrateSettings()`)
- ‚è≥ **Story 10.7:** License Settings Auto-Load (depends on settings infrastructure)

---

## Deliverables

1. **Database Migration**
   - `supabase/migrations/003_create_user_settings.sql` (~60 lines)

2. **TypeScript Types**
   - `src/types/settings.ts` (~120 lines)

3. **Service Layer**
   - `src/services/SettingsService.ts` (~250 lines)

4. **React Hooks**
   - `src/hooks/useSettings.ts` (~100 lines)
   - Updated `src/hooks/index.ts` (export useSettings)

5. **Context Updates**
   - Modified `src/contexts/GlobalMusicContext.tsx` (+80 lines)

6. **Documentation**
   - `docs/architecture/admin-settings-startup.md` (already created)

---

## Definition of Done

- [ ] `user_settings` table created with RLS policies
- [ ] Indexes created for performance
- [ ] TypeScript interfaces defined for all settings categories
- [ ] `SettingsService` implemented (load, save, migrate, validate)
- [ ] `useSettings` hook created with 30-second debounce
- [ ] GlobalMusicContext extended with settings state
- [ ] Settings auto-load on app startup (<300ms for authenticated users)
- [ ] Auto-save working (30s debounce verified)
- [ ] Offline fallback tested (localStorage backup)
- [ ] RLS policies verified (users can't access other users' settings)
- [ ] Anonymous users still work (localStorage-only, backward compatible)
- [ ] Migration helper tested (localStorage ‚Üí Supabase)
- [ ] All manual tests passing (Tests 1-6)
- [ ] No TypeScript errors (strict mode)
- [ ] Documentation updated

---

## Next Steps After Story 7.10

Once this story is complete, proceed to:
- **Story 18.11:** Settings Migration UI (show "Synced" notification, migration button)
- **Story 10.7:** License Settings Auto-Load (Epic 3 integration)

---

## References

- **Epic 7:** Jam Session Backend (`docs/epics/epic-7-jam-session-backend.md`)
- **Story 18.0:** User Authentication (`docs/stories/18.0-user-accounts-mvp.md`)
- **Architecture Doc:** Admin Settings Startup (`docs/architecture/admin-settings-startup.md`)
- **Supabase RLS:** https://supabase.com/docs/guides/auth/row-level-security
- **Supabase JSONB:** https://supabase.com/docs/guides/database/json

---

**Story Created:** 2025-10-20
**Story Owner:** Dev Agent
**Estimated Completion:** 4-6 hours after start
**Blocks:** Story 18.11, Story 10.7

Directory structure:
└── cymaspace-audiolux/
    ├── README.md
    ├── animation.cpp
    ├── animation.h
    ├── audioshield.cpp
    ├── audioshield.h
    ├── circle.cpp
    ├── circle.h
    ├── curtain.cpp
    ├── curtain.h
    ├── disco.cpp
    ├── disco.h
    ├── fft.cpp
    ├── fft.h
    ├── fire.cpp
    ├── fire.h
    ├── input.h
    ├── leds.cpp
    ├── leds.h
    ├── looper.cpp
    ├── looper.h
    ├── march.cpp
    ├── march.h
    ├── msgeq7.cpp
    ├── msgeq7.h
    ├── onoff.cpp
    ├── onoff.h
    ├── pixl.cpp
    ├── pixl.h
    ├── ripple.cpp
    ├── ripple.h
    ├── spokes.cpp
    ├── spokes.h
    ├── TODO.md
    ├── triangle.cpp
    ├── triangle.h
    ├── twinkle.cpp
    ├── twinkle.h
    ├── util.h
    ├── visualization.cpp
    ├── visualization.h
    └── examples/
        ├── curtains-x2/
        │   └── curtains-x2.ino
        ├── curtains-x3/
        │   └── curtains-1x3.ino
        ├── curtains-x4-switchable/
        │   ├── curtains-x4-switchable.ino
        │   └── switchableController.ino
        └── pyramids-pam/
            └── pyramids-pam.ino

================================================
FILE: README.md
================================================
# Intro
Audiolux is a library to make sound-reactive LED mapping and animations more modular and easier to
setup.

# Install
Download one of the release zips and add it to your project using the Arduino
IDE.  The cymatic-triangles example in the `examples/` folder is a good starting
point for starting a new project.

# Dependencies
You will also need to also install FastLED, a Logging Library and Teensyduino (if you are using a Teensy): 
* Logging Library: https://github.com/CymaSpace/Arduino-logging-library (if throws compiling error, see Troubleshooting below)
* Teensyduino: https://www.pjrc.com/teensy/td_download.html
* FastLED: http://fastled.io/ (Install this if you are not running Teensyduino).

# Concepts
Below are the concepts used in the Library with examples of how to use them.

## LED Strips
A physical strip of LEDs. Right now, it's just a class that holds a color array
that will be given to FastLED for management.  Instatiate with the length of
the strip and give to FastLED in setup().

```cpp
LEDStrip strip = LEDStrip(50);

void setup() {
  FastLED.addLeds<WS2811, 6, RGB>(strip.leds, 50);
}
```

## LEDs
A group of one or more LED strip segments that will be considered one long
strip by visualizations.  Visualizations expect an LEDs object to be passed in,
so even if no addressing adjustments are needed, a "pass through" LEDs object
will still need to be made.

### Passthrough
If just using one strip, pass in the strip object, the starting LED number
(0-based) and the length.

```cpp
LEDStrip strip = LEDStrip(50);
LEDs leds = LEDs(&strip, 0, 50);

void setup() {
  FastLED.addLeds<WS2811, 6, RGB>(strip.leds, 50);
}
```

### String together physical strips
The LEDs object can be used to turn multiple physical LED strips into one long
virtual one.  If used in this way, pass in the number of strips, an array of
strip objects, an array of start LED numbers for each strip and an array of
lengths for each strip.  The following example takes 3 15-LED strips on ports
6, 7, and 8 and makes one virtual one with 45.

```cpp
LEDStrip strip1 = LEDStrip(15);
LEDStrip strip2 = LEDStrip(15);
LEDStrip strip3 = LEDStrip(15);

LEDstrip* strips[] = {&strip1, &strip2, &strip3};
int starts[] = {0, 0, 0};
int lengths[] = {15, 15, 15};

LEDs leds = LEDs(3, strips, starts, lengths);

void setup() {
  FastLED.addLeds<WS2811, 6, RGB>(strip1.leds, 15);
  FastLED.addLeds<WS2811, 7, RGB>(strip2.leds, 15);
  FastLED.addLeds<WS2811, 8, RGB>(strip3.leds, 15);
}
```

### Rearrange LEDs in a strip
The LEDs class can also be used to take sections of LEDs within one physical
strip and rearrange them.  The following example rearranges a strip so that it
starts at 0, goes to 14, jumps to 30, goes to 44, jumps to 15, and goes to 29.

```cpp
LEDStrip strip = LEDStrip(45);
LEDstrip* strips[] = {&strip, &strip, &strip};
int starts[] = {0, 30, 15};
int lengths[] = {15, 15, 15};

LEDs leds = LEDs(3, strips, starts, lengths);

void setup() {
  FastLED.addLeds<WS2811, 6, RGB>(strip.leds, 45);
}
```

### Reverse addressing
It can also reverse the order of the LEDs if needed.  Simply add 'true' as the
last argument:

```cpp
LEDStrip strip = LEDStrip(50);
LEDs leds = LEDs(&strip, 0, 50, true);

void setup() {
  FastLED.addLeds<WS2811, 6, RGB>(strip.leds, 50);
}
```

## Inputs
Something that produces a decimal number between 0 and 1.  It can be audio
data, a random number generator, a wave function, whatever.  Inputs are given
to visualizations to generat color based on the input.  Here is an example that
creates a RandomInput:

```cpp
LEDStrip strip = LEDStrip(50);
LEDs leds = LEDs(&strip, 0, 50);
Input* input;

void setup() {
  FastLED.addLeds<WS2811, 6, RGB>(strip.leds, 50);
  input = new RandomInput();
}
```

## Visualizations
Visualizations turn inputs into color.  Right now, all visualizations are
one-dimensional arrays of color.  In the future, this could be two-, or even
three-dimensional.

```cpp
#define NUM_LEDS 50

LEDStrip strip = LEDStrip(NUM_LEDS);
LEDs leds = LEDs(&strip, 0, NUM_LEDS);
Input* input;
Visualization* viz;

void setup() {
  FastLED.addLeds<WS2811, 6, RGB>(strip.leds, NUM_LEDS);
  input = new RandomInput();
  viz = new TwinkleVisualization(&input, NUM_LEDS);
}
```

## Animations
This takes a visualization and maps it to LEDs. For example, this could take a
one-dimensional array of color from a visualization and map it to a grid of
LEDs to produce a plane.  Here is an example that takes a one-dimensional
ripple visualization and maps it to a triangle using a TriangleAnimation:

```cpp
#define NUM_LEDS 50

LEDStrip strip = LEDStrip(NUM_LEDS);
LEDs leds = LEDs(&strip, 0, NUM_LEDS);
Input* input;
Visualization* viz;
TriangleAnimation* anim;

void setup() {
  FastLED.addLeds<WS2811, 6, RGB>(strip.leds, NUM_LEDS);
  input = new RandomInput();
  viz = new TwinkleVisualization(&input, NUM_LEDS);
  anim = new TriangleAnimation(viz, leds);
  // TriangleAnimation an init() that does the mapping calculations. The
  // argument is what percentage of the visualization is mapped to the triangle.
  anim->init(0.4);
}
```

## Looper
The Looper controls updating and drawing of all the components.  It can be
used to control frames per second as well.

```cpp
#define NUM_LEDS 50

LEDStrip strip = LEDStrip(NUM_LEDS);
LEDs leds = LEDs(&strip, 0, NUM_LEDS);
Input* input;
Visualization* viz;
TriangleAnimation* anim;

void setup() {
  FastLED.addLeds<WS2811, 6, RGB>(strip.leds, NUM_LEDS);
  input = new RandomInput();
  viz = new RippleVisualization(&input, NUM_LEDS);
  anim = new TriangleAnimation(viz, leds);

  // TriangleAnimation an init() that does the mapping calculations. The
  // argument is what percentage of the visualization is mapped to the triangle.
  anim->init(0.4);

  // Add all the components to the looper so they update every frame
  Looper* looper = Looper::instance();
  looper->addInput(input);
  looper->addVisualization(viz);
  looper->addAnimation(anim);
  looper->setUpdatesPerSecond(30);
}

void loop() {
  // Call the looper's loop function to update all the components
  Looper::instance()->loop();
}
```

# Troubleshooting
If Logging Library throws an error during compiling; make sure the following fix (remove line 11 in red and add line 12 highlighted in in green) is implemented in the Logging.cpp file: https://github.com/CymaSpace/Arduino-logging-library/commit/3fccfead3330ecf184322f0114fcaaf57fc86eab



================================================
FILE: animation.cpp
================================================
#include <Assert.h>
#include "animation.h"

using namespace pixl;

PassThroughAnimation::PassThroughAnimation(Visualization* viz, LEDs& leds)
  : leds_(leds),
    viz_(viz) {}

void PassThroughAnimation::init() {}
void PassThroughAnimation::update() {}

void PassThroughAnimation::draw(float interpolation) {
  for(int i = 0; i < leds_.length(); i++) {
    // TODO: tried by ratio to support different led length and viz length but
    // got rounding errors and color spilled over to two pixels
    leds_[i] = viz_->getColorByIndex(i);
  }
}

ScaledAnimation::ScaledAnimation(Visualization* viz, LEDs& leds)
  : leds_(leds),
    viz_(viz) {}

void ScaledAnimation::init() {}
void ScaledAnimation::update() {}

// Linear upscale
void ScaledAnimation::upscale() {
  int led_length = leds_.length();
  int viz_length = viz_->getSize();

  // Subtract one from the lengths to get scale because of fencepost problem
  //
  // Example: If there are 5 LEDs and 3 viz colors, the first color will be
  // at 0, the last color at 4, and the other should be at 2.  0, 2, 4.
  // Every 2 LEDs. (5 - 1) / (3 - 1) = 2
  // LEDs:   | | | | |
  // Viz:    +   +   +
  //
  // Example: If there are 10 LEDs and 4 viz colors, the first color will be
  // at 0, the last color at 9, leaving the other two at 3 and 6. 0, 3, 6, 9.
  // Every 3 LEDs. (10 - 1) / (4 - 1) = 3
  // LEDs:   | | | | | | | | | |
  // Viz:    +     +     +     +
  float scale = ((float)led_length - 1.0) / ((float)viz_length - 1.0);

  // Set up start and end fence posts
  leds_[0] = viz_->getColorByIndex(0);
  leds_[led_length - 1] = viz_->getColorByIndex(viz_length - 1);

  // Fill in the middle
  for (int i = 1; i < led_length - 1; i++) {
    // Where along the viz array this LED should get its color (decimal)
    float index = (float)i / scale;

    // Get the indices of the two viz colors this LED will blend
    int index1 = (int)floor(index);
    int index2 = index1 + 1;

    // Get the two viz colors this LED is between
    CRGB color1 = viz_->getColorByIndex(index1);
    CRGB color2 = viz_->getColorByIndex(index2);

    // Find how much of each viz color this LED should get
    int ratio1 = 1.0 - fmod(index, 1.0);
    int ratio2 = 1.0 - ratio1;

    // Blend the two colors this LED is between
    CRGB color = CRGB(
      (color1.r * ratio1) + (color2.r * ratio2),
      (color1.g * ratio1) + (color2.g * ratio2),
      (color1.b * ratio1) + (color2.b * ratio2)
    );

    leds_[i] = color;
  }
}

// Example: If there are 5 LEDs and 3 viz colors, the first color will be
// at 0, the last color at 4, and the other should be at 2.  0, 2, 4.
// Every 2 LEDs. (5 - 1) / (3 - 1) = 2
// LEDs:   | | | | |
// Viz:    +   +   +
//
// Example: If there are 10 LEDs and 4 viz colors, the first color will be
// at 0, the last color at 9, leaving the other two at 3 and 6. 0, 3, 6, 9.
// Every 3 LEDs. (10 - 1) / (4 - 1) = 3
// LEDs:   | | | | | | | | | |
// Viz:    +     +     +     +
void ScaledAnimation::downscale() {
  int led_length = leds_.length();
  int viz_length = viz_->getSize();

  float scale = ((float)viz_length - 1) / ((float)led_length - 1);

  for(int i = 0; i < led_length; i++) {
    leds_[i] = viz_->getColorByIndex((int)(i * scale));
  }
}

void ScaledAnimation::draw(float interpolation) {
  int led_length = leds_.length();
  int viz_length = viz_->getSize();

  // Upscale
  if (led_length > viz_length) {
    upscale();
  }

  // Downscale
  if (led_length < viz_length) {
    downscale();
  }

  // Pass through
  for(int i = 0; i < led_length; i++) {
    leds_[i] = viz_->getColorByIndex(i);
  }
}



================================================
FILE: animation.h
================================================
#pragma once
#include "leds.h"
#include "visualization.h"

namespace pixl {

/* An Animation takes a visualization and maps it to LED segments */
class Animation {
  public:
    virtual void init()=0;
    virtual void update()=0;
    virtual void draw(float interpolation)=0;
};

class ScaledAnimation : public Animation {
  public:
    ScaledAnimation(Visualization* viz, LEDs& leds);
    void init();
    void update();
    void draw(float interpolation);
    void upscale();
    void downscale();

  private:
    LEDs& leds_;
    Visualization* viz_;
};

class PassThroughAnimation : public Animation {
  public:
    PassThroughAnimation(Visualization* viz, LEDs& leds);
    void init();
    void update();
    void draw(float interpolation);

  private:
    LEDs& leds_;
    Visualization* viz_;
};

} // end namespace pixl



================================================
FILE: audioshield.cpp
================================================
#if defined(__MK20DX256__) || defined(__MK20DX128__) || defined(__MK66FX1M0__)

#include "audioshield.h"
#include <Logging.h>
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

using namespace pixl;

namespace pixl {

AudioShieldInput::AudioShieldInput(AudioAnalyzePeak* peak, AudioAnalyzeNoteFrequency* note)
  : peak_(peak), note_(note), amp_(0.0), freq_(0.0) {}

void AudioShieldInput::update() {
  if (peak_->available()) {
    amp_ = peak_->read();
  }

  if (note_->available()) {
    float nt = note_->read();
    freq_ = nt / 1000.0;
    freq_ = min(1.0, freq_);
    freq_ = max(0.0, freq_);
  }
}

float AudioShieldInput::getInput(int index) {
  if (index == 0) {
    return amp_;
  } else if (index == 1) {
    return freq_;
  } else {
    return 0.0;
  }
}

} // end namespace pixl

#endif



================================================
FILE: audioshield.h
================================================
#pragma once
#include "input.h"
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

namespace pixl {

class AudioShieldInput : public Input {
  public:
    AudioShieldInput(AudioAnalyzePeak* peak, AudioAnalyzeNoteFrequency* note);
    void update();
    float getInput(int index = 0);
  private:
    AudioAnalyzePeak* peak_;
    AudioAnalyzeNoteFrequency* note_;
    float amp_;
    float freq_;
};

} // end namespace pixl



================================================
FILE: circle.cpp
================================================
#include "circle.h"
#include <Logging.h>

using namespace pixl;

CircleAnimation::CircleAnimation(Visualization* viz, LEDs** leds, int num_leds)
    : leds_(leds),
      num_leds_(num_leds),
      viz_(viz) {}

CircleAnimation::~CircleAnimation() {
  delete[] mapping_;
}

void CircleAnimation::init() {}
void CircleAnimation::init(float scale) {
  Log.Info("Setting up Circle animation\n");

  int length = leds_[0]->length();
  mapping_ = new float[length];

  float radius = (float)length / (2.0 * 3.1415);
  Log.Debug("Radius: %d (x1000)\n", (int)(radius * 1000.0));

  float viz_scaled = viz_->getSize() * scale;

  for (int i = 0; i < length; i++) {
    float radians = ((float)i / ((float)length - 1.0)) * (2.0 * 3.1415);
    float a = sin(radians) * radius;
    float b = cos(radians) * radius;
    float y = radius - b;
    float x = sqrt(a * a + y * y);
    float map = x / viz_scaled;
    mapping_[i] = x / viz_scaled;
    Log.Debug("Mapping of %d: %d (x1000)\n", i, (int)(map * 1000.0));
  }

  Log.Info("Finished setting up Circle animation\n");
}

void CircleAnimation::update() {}

void CircleAnimation::draw(float interpolation) {
  for (int i = 0; i < num_leds_; i++) {
    LEDs* leds = leds_[i];
    for (int j = 0; j < leds->length(); j++) {
      (*leds)[j] = viz_->getColorByRatio(mapping_[j]);
    }
  }
}




================================================
FILE: circle.h
================================================
#pragma once
#include "animation.h"
#include "leds.h"
#include "visualization.h"

namespace pixl {

class CircleAnimation : public Animation {
  public:
    CircleAnimation(Visualization* viz, LEDs* leds[], int num_leds);
    ~CircleAnimation();
    void init();
    void init(float scale);
    void update();
    void draw(float interpolation);

  private:
    LEDs** leds_;
    int num_leds_;
    Visualization* viz_;
    float* mapping_;
};

} // end namespace pixl



================================================
FILE: curtain.cpp
================================================
#include "curtain.h"
#include <Assert.h>
#include <Logging.h>
#include <Math.h>

using namespace pixl;

CurtainAnimation::CurtainAnimation(Visualization* viz, LEDs& leds)
  : leds_(leds),
    viz_(viz)
{ }

CurtainAnimation::~CurtainAnimation() {
  delete[] mapping_;
}

void CurtainAnimation::init() {}
void CurtainAnimation::init(int height_px, int width_px,
                            double height_r, double width_r,
                            double rotation_rad,
                            double x_r, double y_r, double z_r)
{
  Log.Info("Setting up Curtain animation\n");
  int llen = leds_.length();
  Log.Info("LED count %d\n", (int)llen);
  assert( (height_px * width_px) <= llen );

  Log.Info("%d %d\n", height_px, width_px);
  mapping_ = new double[llen];
  //Log.Info("Mapped");
  for (int i = 0; i < llen; i++) {
    //Log.Info("LED # %d\n", (int)i);
    mapping_[i] = 0.0;
  }

  // Assumes LEDs start at the top right corner and then go down, left, back
  // up, left back down, etc.
  int x = width_px - 1;
  int y = 0;
  int y_inc = 1;

  for (int i = 0; i < llen; i++) {
    //Log.Info("LED # %d\n", (int)i);
    // Find distance from top left corner (0,0)
    double x_distance = width_r * ((double)(x + 1) / (double)width_px);
    double y_distance = height_r * ((double)(y + 1) / (double)height_px);

    // Find distance from start of visualization
    x_distance += x_r;
    y_distance += y_r;

    double distance = sqrt( pow(x_distance, 2) + pow(y_distance, 2) );

    // Verify it's between 0 and 1
    distance = max(0.0, distance);
    distance = min(1.0, distance);

    // Add the mapping
    mapping_[i] = distance;

    // Calculate new x,y coordinates
    y += y_inc;
    if (y == height_px) {
      x--;
      y = height_px - 1;
      y_inc = -1;
    } else if (y < 0) {
      x--;
      y = 0;
      y_inc = 1;
    }
  }
}

void CurtainAnimation::setVisualization(Visualization* viz) {
  viz_ = viz;
}

void CurtainAnimation::update() {}

void CurtainAnimation::draw(float interpolation) {
  for (int i = 0; i < leds_.length(); i++) {
    leds_[i] = viz_->getColorByRatio(mapping_[i]);
  }
}



================================================
FILE: curtain.h
================================================
#pragma once
#include "animation.h"
#include "leds.h"
#include "visualization.h"

namespace pixl {

class CurtainAnimation : public Animation {
  public:
    CurtainAnimation(Visualization* viz, LEDs& leds);
    ~CurtainAnimation();
    void init();
    void init(int height_px, int width_px,
              double height_r, double width_r,
              double rotation_rad, double x_r, double y_r, double z_r);
    void update();
    void draw(float interpolation);
    void setVisualization(Visualization* viz);

  private:
    LEDs& leds_;
    Visualization* viz_;
    double* mapping_;
};

} // end namespace pixl



================================================
FILE: disco.cpp
================================================
#include <FastLED.h>
#include "disco.h"

using namespace pixl;

void DiscoAnimation::draw(float interp) {
  // First, we black out all the LEDs
  leds_.fillSolid(CRGB::Black);

  // To achive the strobe effect, we actually only draw lit pixels
  // every Nth frame (e.g. every 4th frame).
  // sStrobePhase is a counter that runs from zero to kStrobeCycleLength-1,
  // and then resets to zero.
  const uint8_t kStrobeCycleLength = 4; // light every Nth frame
  static uint8_t sStrobePhase = 0;
  sStrobePhase = sStrobePhase + 1;
  if (sStrobePhase >= kStrobeCycleLength ) {
    sStrobePhase = 0;
  }

  // We only draw lit pixels when we're in strobe phase zero;
  // in all the other phases we leave the LEDs all black.
  if (sStrobePhase == 0 ) {

    // The dash spacing cycles from 4 to 9 and back, 8x/min (about every 7.5 sec)
    uint8_t dashperiod= beatsin8( 8/*cycles per minute*/, 4,10);
    // The width of the dashes is a fraction of the dashperiod, with a minimum of one pixel
    uint8_t dashwidth = (dashperiod / 4) + 1;

    // The distance that the dashes move each cycles varies
    // between 1 pixel/cycle and half-the-dashperiod/cycle.
    // At the maximum speed, it's impossible to visually distinguish
    // whether the dashes are moving left or right, and the code takes
    // advantage of that moment to reverse the direction of the dashes.
    // So it looks like they're speeding up faster and faster to the
    // right, and then they start slowing down, but as they do it becomes
    // visible that they're no longer moving right; they've been
    // moving left.  Easier to see than t o explain.
    //
    // The dashes zoom back and forth at a speed that 'goes well' with
    // most dance music, a little faster than 120 Beats Per Minute.  You
    // can adjust this for faster or slower 'zooming' back and forth.
    uint8_t zoomBPM = 120;
    int8_t  dashmotionspeed = beatsin8( (zoomBPM /2), 1,dashperiod);
    // This is where we reverse the direction under cover of high speed
    // visual aliasing.
    if( dashmotionspeed >= (dashperiod/2)) {
      dashmotionspeed = 0 - (dashperiod - dashmotionspeed );
    }


    // The hueShift controls how much the hue of each dash varies from
    // the adjacent dash.  If hueShift is zero, all the dashes are the
    // same color. If hueShift is 128, alterating dashes will be two
    // different colors.  And if hueShift is range of 10..40, the
    // dashes will make rainbows.
    // Initially, I just had hueShift cycle from 0..130 using beatsin8.
    // It looked great with very low values, and with high values, but
    // a bit 'busy' in the middle, which I didnt like.
    //   uint8_t hueShift = beatsin8(2,0,130);
    //
    // So instead I layered in a bunch of 'cubic easings'
    // (see http://easings.net/#easeInOutCubic )
    // so that the resultant wave cycle spends a great deal of time
    // "at the bottom" (solid color dashes), and at the top ("two
    // color stripes"), and makes quick transitions between them.
    uint8_t cycle = beat8(2); // two cycles per minute
    uint8_t easedcycle = ease8InOutCubic( ease8InOutCubic( cycle));
    uint8_t wavecycle = cubicwave8( easedcycle);
    uint8_t hueShift = scale8( wavecycle,130);


    // Each frame of the animation can be repeated multiple times.
    // This slows down the apparent motion, and gives a more static
    // strobe effect.  After experimentation, I set the default to 1.
    uint8_t strobesPerPosition = 1; // try 1..4


    // Now that all the parameters for this frame are calculated,
    // we call the 'worker' function that does the next part of the work.
    discoWorker( dashperiod, dashwidth, dashmotionspeed, strobesPerPosition, hueShift);
  }
}


// discoWorker updates the positions of the dashes, and calls the draw function
//
void DiscoAnimation::discoWorker(
    uint8_t dashperiod, uint8_t dashwidth, int8_t  dashmotionspeed,
    uint8_t stroberepeats,
    uint8_t huedelta)
 {
  static uint8_t sRepeatCounter = 0;
  static int8_t sStartPosition = 0;
  static uint8_t sStartHue = 0;

  // Always keep the hue shifting a little
  sStartHue += 1;

  // Increment the strobe repeat counter, and
  // move the dash starting position when needed.
  sRepeatCounter = sRepeatCounter + 1;
  if( sRepeatCounter>= stroberepeats) {
    sRepeatCounter = 0;

    sStartPosition = sStartPosition + dashmotionspeed;

    // These adjustments take care of making sure that the
    // starting hue is adjusted to keep the apparent color of
    // each dash the same, even when the state position wraps around.
    if( sStartPosition >= dashperiod ) {
      while( sStartPosition >= dashperiod) { sStartPosition -= dashperiod; }
      sStartHue  -= huedelta;
    } else if( sStartPosition < 0) {
      while( sStartPosition < 0) { sStartPosition += dashperiod; }
      sStartHue  += huedelta;
    }
  }

  // draw dashes with full brightness (value), and somewhat
  // desaturated (whitened) so that the LEDs actually throw more light.
  const uint8_t kSaturation = 208;
  const uint8_t kValue = 255;

  // call the function that actually just draws the dashes now
  drawRainbowDashes( sStartPosition, leds_.length()-1,
                     dashperiod, dashwidth,
                     sStartHue, huedelta,
                     kSaturation, kValue);
}


// drawRainbowDashes - draw rainbow-colored 'dashes' of light along the led strip:
//   starting from 'startpos', up to and including 'lastpos'
//   with a given 'period' and 'width'
//   starting from a given hue, which changes for each successive dash by a 'huedelta'
//   at a given saturation and value.
//
//   period = 5, width = 2 would be  _ _ _ X X _ _ _ Y Y _ _ _ Z Z _ _ _ A A _ _ _
//                                   \-------/       \-/
//                                   period 5      width 2
//
void DiscoAnimation::drawRainbowDashes(
  uint8_t startpos, uint16_t lastpos, uint8_t period, uint8_t width,
  uint8_t huestart, uint8_t huedelta, uint8_t saturation, uint8_t value)
{
  uint8_t hue = huestart;
  for (uint16_t i = startpos; i <= lastpos; i += period) {
    CRGB color = CHSV(hue, saturation, value);

    // draw one dash
    uint16_t pos = i;
    for (uint8_t w = 0; w < width; w++) {
      leds_[pos] = color;
      pos++;
      if (pos >= leds_.length()) {
        break;
      }
    }

    hue += huedelta;
  }
}

DiscoAnimation::DiscoAnimation(Visualization* viz, LEDs& leds)
  : leds_(leds),
    viz_(viz) {}

void DiscoAnimation::init() {}
void DiscoAnimation::update() {}



================================================
FILE: disco.h
================================================
#pragma once
#include "animation.h"
#include "leds.h"

namespace pixl {

class DiscoAnimation : public Animation {
  public:
    DiscoAnimation(Visualization* viz, LEDs& leds);
    void init();
    void update();
    void draw(float interpolation);
    void drawRainbowDashes(
      uint8_t startpos, uint16_t lastpos, uint8_t period, uint8_t width,
      uint8_t huestart, uint8_t huedelta, uint8_t saturation, uint8_t value);
    void discoWorker(
        uint8_t dashperiod, uint8_t dashwidth, int8_t  dashmotionspeed,
        uint8_t stroberepeats,
        uint8_t huedelta);

  private:
    LEDs& leds_;
    Visualization* viz_;
    float wave_;
    float amplitude_;
};

} // end namespace pixl



================================================
FILE: fft.cpp
================================================
#if defined(__MK20DX256__) || defined(__MK20DX128__) || defined(__MK66FX1M0__)

#include "fft.h"
#include <Logging.h>
#include <Audio.h>

using namespace pixl;

namespace pixl {

FFTInput::FFTInput(AudioAnalyzeFFT1024* fft, int start, int range)
  : fft_(fft), amp_(0.0), freq_(0.0),
    start_(start), range_(range) {}

void FFTInput::update() {
  if (fft_->available()) {
    float max_delta = 0.0;
    int max_value = 0;
    int max_index = 0;

    for (int i = start_; i < range_; i++) {
      int value = fft_->output[i];
      float delta = (float)value / (float)max_[i];

      // Decay max
      max_[i] = max_[i] * 0.993;

      // Track max
      if (value > max_[i]) {
        max_[i] = value;
      }

      // Find max amplitude
      if (value > max_value) {
        max_value = value;
      }

      // Track the freq that changed the most
      if (delta > max_delta) {
        max_delta = delta;
        max_index = i;
      }
    }

    Log.Debug("max index: %d\n", max_index);
    Log.Debug("max value: %d\n", max_value);

    freq_ = (float)max_index / (range_ - 1);
    freq_ = min(1.0, freq_);

    amp_ = (float)max_value / 6000.0;
    amp_ = min(1.0, amp_);
  }
}

float FFTInput::getInput(int index) {
  if (index == 0) {
    return amp_;
  } else if (index == 1) {
    return freq_;
  } else {
    return 0.0;
  }
}

} // end namespace pixl

#endif



================================================
FILE: fft.h
================================================
#pragma once
#include "input.h"
#include <Audio.h>

namespace pixl {

class FFTInput : public Input {
  public:
    FFTInput(AudioAnalyzeFFT1024* fft, int start=0, int range=512);
    void update();
    float getInput(int index = 0);
  private:
    AudioAnalyzeFFT1024* fft_;
    uint16_t max_[512] = {0};
    float start_;
    float range_;
    float amp_;
    float freq_;
};

} // end namespace pixl



================================================
FILE: fire.cpp
================================================
#include "fire.h"

// Fire2012 by Mark Kriegsman, July 2012
// as part of "Five Elements" shown here: http://youtu.be/knWiGsmgycY
////
// This basic one-dimensional 'fire' simulation works roughly as follows:
// There's a underlying array of 'heat' cells, that model the temperature
// at each point along the line.  Every cycle through the simulation,
// four steps are performed:
//  1) All cells cool down a little bit, losing heat to the air
//  2) The heat from each cell drifts 'up' and diffuses a little
//  3) Sometimes randomly new 'sparks' of heat are added at the bottom
//  4) The heat from each cell is rendered as a color into the leds array
//     The heat-to-color mapping uses a black-body radiation approximation.
//
// Temperature is in arbitrary units from 0 (cold black) to 255 (white hot).
//
// This simulation scales it self a bit depending on size_; it should look
// "OK" on anywhere from 20 to 100 LEDs without too much tweaking.
//
// I recommend running this simulation at anywhere from 30-100 frames per second,
// meaning an interframe delay of about 10-35 milliseconds.
//
// Looks best on a high-density LED setup (60+ pixels/meter).
//
//
// There are two main parameters you can play with to control the look and
// feel of your fire: COOLING (used in step 1 above), and SPARKING (used
// in step 3 above).
//
// COOLING: How much does the air cool as it rises?
// Less cooling = taller flames.  More cooling = shorter flames.
// Default 50, suggested range 20-100
#define COOLING  100

// SPARKING: What chance (out of 255) is there that a new spark will be lit?
// Higher chance = more roaring fire.  Lower chance = more flickery fire.
// Default 120, suggested range 50-200.
#define SPARKING 175

namespace pixl {

FireVisualization::FireVisualization(Input* input, int size)
  : Visualization(input, size)
  {
    // Array of temperature readings at each simulation cell
    heat_ = new byte[size];
  }

FireVisualization::~FireVisualization() {
  delete[] heat_;
}

void FireVisualization::update() {

  // Step 1.  Cool down every cell a little
  for (int i = 0; i < size_; i++) {
    heat_[i] = qsub8( heat_[i],  random8(0, ((COOLING * 10) / size_) + 2));
  }

  // Step 2.  Heat from each cell drifts 'up' and diffuses a little
  for (int i = size_ - 1; i >= 2; i--) {
    heat_[i] = (heat_[i - 1] + heat_[i - 2] + heat_[i - 2] ) / 3;
  }

  // Step 3.  Randomly ignite new 'sparks' of heat near the bottom
  if ( (int)(255.0 * input_->getInput()) < SPARKING ) {
    int i = random8(7);
    heat_[i] = qadd8( heat_[i], random8(160,255) );
  }

  // Step 4.  Map from heat cells to LED colors
  for (int i = 0; i < size_; i++) {
    CRGB color = HeatColor(heat_[i]);
    viz_[i] = color;
  }
}

} // end namespace pixl



================================================
FILE: fire.h
================================================
#pragma once
#include "animation.h"
#include "leds.h"
#include "visualization.h"

namespace pixl {

class FireVisualization : public Visualization {
  public:
    FireVisualization(Input* input, int size = 1);
    ~FireVisualization();
    void update();
  private:
    byte* heat_;
};

} // end namespace pixl



================================================
FILE: input.h
================================================
#pragma once
#include <Arduino.h>

namespace pixl {

/* An Input is an interface for Visualizations to use. getInput() returns a
   float between 0 and 1. */
class Input {
  public:
    Input(){};
    virtual void update()=0;
    virtual float getInput(int index = 0)=0;
};

class NullInput : public Input {
  public:
    NullInput(){};
    void update() {};
    float getInput(int index = 0) { return 0.0; }
};

class FullInput : public Input {
  public:
    FullInput(){};
    void update() {};
    float getInput(int index = 0) { return 1.0; }
};

class ConstantInput : public Input {
  public:
    ConstantInput(float value) : value_(value) {};
    void update() {};
    float getInput(int index = 0) { return value_; }
  private:
    float value_;
};

class WaveInput : public Input {
  public:
    WaveInput(float seconds = 1.0) : millis_(seconds * 1000.0) {};
    void update() {};
    float getInput(int index = 0) {
      return
        (sin(2.0 * 3.14 * (millis() % millis_) / (float)millis_) + 1.0)
        / 2.0;
    }
  private:
    int millis_;
};

class RandomInput : public Input {
  public:
    RandomInput(){};
    void update() {};
    float getInput(int index = 0) { return (float) rand() / (float) RAND_MAX; }
};

class SwitchInput : public Input {
  public:
    SwitchInput(int pin) : pin_(pin) { pinMode(pin_, INPUT); };
    void update() {};
    float getInput(int index = 0) { return digitalRead(pin_) == HIGH; }
  private:
    int pin_;
    bool released_;
};

// This will return 1.0 only once per press by keeping track of when the button
// is released
class ButtonInput : public Input {
  public:
    ButtonInput(int pin) : pin_(pin), released_(true) {};
    void update() {};
    float getInput(int index = 0) {
      if (digitalRead(pin_) == HIGH) {
        if (released_ == true) {
          released_ = false;
          return 1.0;
        }
      } else if (released_ == false) {
        released_ = true;
      }
      return 0.0;
    }
  private:
    int pin_;
    bool released_;
};

} // end namespace pixl



================================================
FILE: leds.cpp
================================================
#include "assert.h"
#include "leds.h"

namespace pixl {

LEDStrip::LEDStrip(int length)
  : length(length)
{
  // Initialze one array to hold LED data for all the strips
  leds = new CRGB[length];

  for (int i = 0; i < length; i++) {
    leds[i] = CRGB::Red;
  }
}

LEDStrip::~LEDStrip() {
  delete[] leds;
}

LEDs::LEDs(LEDStrip* strip, int start, int length, bool reverse) {
  LEDStrip* strips[] = {strip};
  int starts[] = {start};
  int lengths[] = {length};
  init(1, strips, starts, lengths, reverse);
}

LEDs::LEDs(int num_strips, LEDStrip* strips[], int* starts, int* lengths,
           bool reverse) {
  init(num_strips, strips, starts, lengths, reverse);
}

void LEDs::init(int num_strips, LEDStrip* strips[], int* starts, int* lengths,
                bool reverse) {
  strips_ = new LEDStrip*[num_strips];
  starts_ = new int[num_strips];
  lengths_ = new int[num_strips];
  num_strips_ = num_strips;
  length_ = 0;
  reverse_ = reverse;

  for (int i = 0; i < num_strips; i++) {
    LEDStrip* strip = strips[i];
    int start = starts[i];
    int length = lengths[i];
    assert(start >= 0 && start < strip->length);
    assert(start + length - 1 < strip->length);

    strips_[i] = strip;
    starts_[i] = start;
    lengths_[i] = length;

    length_ += length;
  }
}

LEDs::~LEDs() {
  delete[] strips_;
  delete[] starts_;
  delete[] lengths_;
}

CRGB& LEDs::operator[](int index) {
  assert(index >= 0 && index < length_);

  for (int i = 0; i < num_strips_; i++) {
    if (index < lengths_[i]) {
      if (reverse_) {
        index = starts_[i] + lengths_[i] - 1 - index;
      } else {
        index = starts_[i] + index;
      }
      return strips_[i]->leds[index];
    }

    index -= lengths_[i];
  }
}

void LEDs::fillSolid(CRGB color) {
  for (int i = 0; i < num_strips_; i++) {
    for (int j = starts_[i]; j < lengths_[i]; j++) {
      strips_[i]->leds[j] = color;
    }
  }
}

} // end namespace pixl



================================================
FILE: leds.h
================================================
#pragma once
#include <FastLED.h>

namespace pixl {

/* LEDStrip represents a FastLED-compatible LED strip. */
class LEDStrip {
  public:
    LEDStrip(int length);
    ~LEDStrip();
    void AssignPin(int pin);
    int length;
    CRGB* leds;
};

/* LEDs represents a section of an LED strip. */
class LEDs {
  public:
    LEDs(LEDStrip* strip, int start, int length, bool reverse = false);
    LEDs(int num_strips, LEDStrip* strips[], int* starts, int* lengths,
         bool reverse = false);
    ~LEDs();
    CRGB& operator[](int index);
    int length() { return length_; }
    void fillSolid(CRGB color);
  private:
    void init(int num_strips, LEDStrip* strips[], int* starts, int* lengths,
              bool reverse);
    int length_;
    int num_strips_;
    LEDStrip** strips_;
    int* starts_;
    int* lengths_;
    int reverse_;
};

} // end namespace pixl



================================================
FILE: looper.cpp
================================================
#include "looper.h"

namespace pixl {

Looper* Looper::looper_ = 0;

void Looper::addAnimation(Animation* animation) {
  Log.Info("Adding animation\n");
  animations_[num_anim_++] = animation;
}

void Looper::addInput(Input* input) {
  Log.Info("Adding input\n");
  inputs_[num_input_++] = input;
}

void Looper::addVisualization(Visualization* visualization) {
  Log.Info("Adding visualization\n");
  visualizations_[num_viz_++] = visualization;
}

void Looper::clearAll() {
  Log.Info("Clearing animations, inputs, and visualizations\n");
  num_anim_ = 0;
  num_input_ = 0;
  num_viz_ = 0;
}

void Looper::clearVisualizations() {
  Log.Info("Clearing visualizations\n");
  num_viz_ = 0;
}

void Looper::loop() {
  Log.Debug("Looping..\n");

  unsigned long current_time = millis();

  if (current_time > next_update_tick_) {
    next_update_tick_ = current_time + update_millis_per_tick_;
    update_();
  }

  if (current_time > next_draw_tick_) {
    next_draw_tick_ = current_time + draw_millis_per_tick_;
    draw_(draw_millis_per_tick_);
  }

  FastLED.show();
}

void Looper::setUpdatesPerSecond(int updates) {
  update_millis_per_tick_ = 1000.0 / updates;
}

void Looper::setFramesPerSecond(int frames) {
  draw_millis_per_tick_ = 1000.0 / frames;
}

void Looper::update_() {
  Log.Debug("Updating..\n");

  for (int i = 0; i < num_anim_; i++) {
    animations_[i]->update();
  }

  for (int i = 0; i < num_input_; i++) {
    inputs_[i]->update();
  }

  for (int i = 0; i < num_viz_; i++) {
    visualizations_[i]->update();
  }
}

void Looper::draw_(float interp) {
  Log.Debug("Drawing..\n");

  for (int i = 0; i < num_anim_; i++) {
    animations_[i]->draw(interp);
  }
}

} // end namespace pixl



================================================
FILE: looper.h
================================================
#pragma once
#include <Logging.h>
#include "animation.h"
#include "input.h"
#include "visualization.h"

namespace pixl {

/* The Looper is a singleton that is responsible for calling update() and
   draw() on Inputs, Visualizations, and Animations */
class Looper {
  public:
    static Looper* instance() {
      if (!looper_) {
        looper_ = new Looper;
      }
      return looper_;
    }
    void loop();
    void addAnimation(Animation* animation);
    void addInput(Input* input);
    void addVisualization(Visualization* visualization);
    void clearAll();
    void clearVisualizations();
    void setUpdatesPerSecond(int updates);
    void setFramesPerSecond(int frames);

  private:
    Looper()
      : num_anim_(0),
        num_input_(0),
        num_viz_(0),
        next_update_tick_(0),
        next_draw_tick_(0),
        draw_millis_per_tick_(0),
        update_millis_per_tick_(0)
    {
      Log.Info("Looper instantiated\n");
    }
    void update_();
    void draw_(float interpolation);
    static Looper* looper_;
    int updates_per_second_;
    unsigned long next_update_tick_;
    unsigned long next_draw_tick_;
    float draw_millis_per_tick_;
    float update_millis_per_tick_;
    int num_anim_;
    int num_input_;
    int num_viz_;
    Animation* animations_[10];
    Visualization* visualizations_[10];
    Input* inputs_[10];
};

} // end namespace pixl



================================================
FILE: march.cpp
================================================
#include "march.h"

using namespace pixl;

MarchAnimation::MarchAnimation(Visualization* viz, LEDs& leds)
  : leds_(leds),
    viz_(viz) {}

void MarchAnimation::init() {}
void MarchAnimation::update() {}

void MarchAnimation::draw(float interpolation) {
  for (int i = leds_.length() - 1; i > 0; i--) {
    leds_[i] = leds_[i - 1];
  }

  leds_[0] = viz_->getColorByIndex(0);
}



================================================
FILE: march.h
================================================
#pragma once
#include "animation.h"
#include "leds.h"
#include "visualization.h"

namespace pixl {

class MarchAnimation : public Animation {
  public:
    MarchAnimation(Visualization* viz, LEDs& leds);
    void init();
    void update();
    void draw(float interpolation);

  private:
    LEDs& leds_;
    Visualization* viz_;
};

} // end namespace pixl



================================================
FILE: msgeq7.cpp
================================================
#include "msgeq7.h"
#include <Logging.h>

using namespace pixl;

namespace pixl {

MSGEQ7Input::MSGEQ7Input(int left_pin, int right_pin,
                         int strobe_pin, int reset_pin,
                         float min_amp, float max_amp,
                         float min_freq, float max_freq,
                         bool amplitude, bool mono)
    : left_pin_(left_pin), right_pin_(right_pin),
      strobe_pin_(strobe_pin), reset_pin_(reset_pin),
      min_amp_(min_amp), max_amp_(max_amp),
      min_freq_(min_freq), max_freq_(max_freq),
      amplitude_(amplitude), mono_(mono) {
  pinMode(left_pin_, INPUT);
  pinMode(right_pin_, INPUT);
  pinMode(strobe_pin_, OUTPUT);
  pinMode(reset_pin_, OUTPUT);

  digitalWrite(reset_pin_, LOW);
  digitalWrite(strobe_pin_, HIGH);
}

float scaleValue(float value, float value_min, float value_max) {
  // Subtract min so lowest value is 0
  value -= value_min;
  value_max = (value_max - value_min);
  value = (value / value_max);

  value = min(1.0, value);
  value = max(0.0, value);

  return value;
}

void MSGEQ7Input::update() {
  if (amplitude_) {
    updateAmplitude();
  } else {
    updateFrequency();
    freq_ = scaleValue(freq_, min_freq_, max_freq_);
  }
  amp_ = scaleValue(amp_, min_amp_, max_amp_);
}

void MSGEQ7Input::updateAmplitude() {
  // Reset EQ7 chip
  digitalWrite(reset_pin_, HIGH);
  digitalWrite(reset_pin_, LOW);

  float total = 0.0;

  // Get readings from chip, sum freq values
  for (int i = 0; i < 7; i++) {
    digitalWrite(strobe_pin_, LOW);
    delayMicroseconds(30); // to allow the output to settle

    int left  = analogRead(left_pin_);
    int right = analogRead(right_pin_);
    if (mono_) {
      left = right;
    }

    total += left;
    total += right;

    // strobe to the next frequency
    digitalWrite(strobe_pin_, HIGH);
  }

  float avg = total / 14.0;
  amp_ = avg;
}

// This assumes that one instrument is playing one note.  To identify the
// frequency, it uses the frequency response chart in the documentation and
// assumes that there will be a rise in amplitude as the target frequency is
// approached and then a decent.
// https://www.sparkfun.com/datasheets/Components/General/MSGEQ7.pdf
// Complete shot on the dark on the start and end frequencies of each channel.
// As the graph in the documentation is inaccurate and hints at inaccuracies in
// trying to find the frequency using this method.  Also, there seems to be a
// curve to the peak and I'm just using linear interpolation.
//
// THIS IN NO WAY GUARANTEES ANY ACCURACY IN THE FREQUENCY RETURNED!
//
// Just an attempt to see what this chip spits out when I play a midi keyboard
// plugged into an AudioLux One while backstage at a deaf theatre production of
// The Wizard of Oz, putting something together for a presentation that takes
// place in 3 hours.  Definitely off the beaten path here.  On the beating
// path? #fmuf Which means I'm on the Right Path. :blessed: :smiling_imp:
void MSGEQ7Input::updateFrequency() {
  // Reset EQ7 chip
  digitalWrite(reset_pin_, HIGH);
  digitalWrite(reset_pin_, LOW);

  // Get readings from chip
  float channel_values[7] = {0};
  float max_value = 0.0;  // to be used below for relative scaling

  for (int i = 0; i < 7; i++) {
    digitalWrite(strobe_pin_, LOW);
    delayMicroseconds(30); // to allow the output to settle

    // Get this channel's value on a scale from 0 to 1
    float left  = analogRead(left_pin_)  / 1023.0;
    float right = analogRead(right_pin_) / 1023.0;
    if (mono_) {
      left = right;
    }
    float avg = (left + right) / 2.0;
    channel_values[i] = avg;

    // TODO: I hate working on a really tight timeline, makes me do stupid shit
    max_value = max(max_value, avg);

    // strobe to the next frequency
    digitalWrite(strobe_pin_, HIGH);
  }

  // When going left to right on the frequency response graphs of the lowest to
  // highest frequencies, assume the signal will rise on the descending side of
  // the frequency response graphs until it peaks, and then drops on the
  // ascending side of the curve.
  bool ascending = false;

  bool channel_ascending[7];

  // Determine which frequencies are on the descending side
  for (int i = 0; i < 7; i++) {
    if (// we've already switched to the ascending side
        ascending == true ||
        // we've reached the last frequency
        i == 6 ||
        // the next frequency is lower than this one
        channel_values[i + 1] < channel_values[i]) {
      // this channel is ascending
      ascending = true;
    }

    channel_ascending[i] = ascending;
  }

  // The start, peak, and end frequencies for each channel
  int freq_start[] = {  0,  60,  125,  300,  600,  1250,  2500};
  int freq_peak[]  = { 63, 160,  400, 1000, 2500,  6250, 16000};
  int freq_end[]   = {200, 400, 1000, 2500, 6250, 16000, 32000};

  // Approximate frequency
  float total = 0.0;
  for (int i = 0; i < 7; i++) {
    float channel_frequency = 0.0;

    // Scale this down to be between 0 and 1 where 1 is the maximum value
    float relative_scale = channel_values[i] / max_value;

    // ascending side
    if (channel_ascending[i]) {
      channel_frequency = (freq_peak[i] - freq_start[i]) * relative_scale;

    // descending side
    } else {
      channel_frequency = freq_end[i] - ((freq_end[i] - freq_start[i]) * relative_scale);
    }

    total += channel_frequency;
  }

  float freq = total / 7.0;
  freq_ = freq;
  Log.Debug("Detected Frequency: %d\n", (int)freq);
  amp_ = max_value * 1023.0;
}

float MSGEQ7Input::getInput(int index) {
  if (index == 0) {
    return amp_;
  } else if (index == 1) {
    return freq_;
  } else {
    return 0.0;
  }
}

} // end namespace pixl



================================================
FILE: msgeq7.h
================================================
#pragma once
#include "input.h"

namespace pixl {

class MSGEQ7Input : public Input {
  public:
    MSGEQ7Input(int left_pin, int right_pin,
                int strobe_pin, int reset_pin,
                float min_amp, float max_amp,
                float min_freq = 0, float max_freq = 0,
                bool amplitude = true, bool mono = true);
    void update();
    float getInput(int index = 0);
  private:
    void updateAmplitude();
    void updateFrequency();
    int strobe_pin_;
    int reset_pin_;
    int left_pin_;
    int right_pin_;
    float min_amp_;
    float max_amp_;
    float min_freq_;
    float max_freq_;
    int amplitude_;
    int mono_;
    float amp_;
    float freq_;
};

} // end namespace pixl



================================================
FILE: onoff.cpp
================================================
#include "pixl.h"

using namespace pixl;

namespace pixl {

OnOffVisualization::OnOffVisualization(Input* input, int smoothing)
    : Visualization(input, 1),
      smoothing_length_(smoothing) {
  smoothing_ = new double[smoothing_length_];

  for (int i = 0; i < smoothing_length_; i++) {
    smoothing_[i] = 0.0;
  }
}

OnOffVisualization::~OnOffVisualization() {
  delete[] smoothing_;
}

void OnOffVisualization::update() {
  double value = input_->getInput();

  double sum = 0.0;
  for (int i = 0; i < smoothing_length_; i++) {
    sum += smoothing_[i];
  }
  sum += value;
  value = sum / (double)(smoothing_length_ + 1);

  PushQueue(smoothing_, smoothing_length_, value);

  CRGB color = CRGB::Blue;
  color.fadeToBlackBy(255 - (255 * value));
  viz_[0] = color;
}

} // end namespace pixl



================================================
FILE: onoff.h
================================================
#pragma once
#include "input.h"
#include "visualization.h"

namespace pixl {

class OnOffVisualization : public Visualization {
  public:
    OnOffVisualization(Input* input, int smoothing);
    ~OnOffVisualization();
    void update();
  private:
    double* smoothing_;
    int smoothing_length_;
};

} // end namespace pixl



================================================
FILE: pixl.cpp
================================================
[Empty file]


================================================
FILE: pixl.h
================================================
#pragma once
#include "animation.h"
#include "circle.h"
#include "curtain.h"
#include "disco.h"
#include "fire.h"
#include "input.h"
#include "leds.h"
#include "looper.h"
#include "march.h"
#include "msgeq7.h"
#include "onoff.h"
#include "ripple.h"
#include "spokes.h"
#include "triangle.h"
#include "twinkle.h"
#include "util.h"
#include "visualization.h"

#if defined(__MK20DX256__) || defined(__MK20DX128__) || defined(__MK66FX1M0__)
#include "audioshield.h"
#include "fft.h"
#endif



================================================
FILE: ripple.cpp
================================================
#include "pixl.h"

using namespace pixl;

namespace pixl {

RippleVisualization::RippleVisualization(Input* input, int size, int smoothing, bool freq)
    : Visualization(input, size),
      smoothing_length_(smoothing),
      freq_(freq) {
  smoothing_amp_ = new float[smoothing_length_];
  smoothing_freq_ = new float[smoothing_length_];

  for (int i = 0; i < smoothing_length_; i++) {
    smoothing_amp_[i] = 0.0;
    smoothing_freq_[i] = 0.0;
  }
}

RippleVisualization::~RippleVisualization() {
  delete[] smoothing_amp_;
  delete[] smoothing_freq_;
}

template <typename Type>
Type smooth(Type* smoothing, int length, Type value) {
  Type sum = 0.0;
  for (int i = 0; i < length; i++) {
    sum += smoothing[i];
  }
  sum += value;
  value = sum / (float)(length + 1);

  PushQueue(smoothing, length, value);

  return value;
}

void RippleVisualization::update_amp() {
  float value = input_->getInput();

  value = smooth(smoothing_amp_, smoothing_length_, value);

  int hue = 192 + (-value * 192);
  int val = 255;
  if (value < 0.1) { val = 0; }
  CRGB color = CHSV(hue, 255, val);
  PushQueue(viz_, size_, color);
}

void RippleVisualization::update_freq() {
  float amp = input_->getInput(0);
  float freq = input_->getInput(1);

  amp = smooth(smoothing_amp_, smoothing_length_, amp);
  freq = smooth(smoothing_freq_, smoothing_length_, freq);

  int hue = 192 * freq;
  int val = 255.0 * amp;
  if (val < 10) { val = 0; }
  CRGB color = CHSV(hue, 255, val);
  PushQueue(viz_, size_, color);
}

void RippleVisualization::update() {
  if (freq_) {
    update_freq();
  } else {
    update_amp();
  }
}

} // end namespace pixl



================================================
FILE: ripple.h
================================================
#pragma once
#include "input.h"
#include "visualization.h"

namespace pixl {

template <typename Type>
void PushStack(Type* array, int length, Type value);

class RippleVisualization : public Visualization {
  public:
    RippleVisualization(Input* input, int size = 1, int smoothing = 1, bool freq = false);
    ~RippleVisualization();
    void update();
  private:
    void update_freq();
    void update_amp();
    void pushRipples(float value);
    float* smoothing_amp_;
    float* smoothing_freq_;
    int smoothing_length_;
    bool freq_;
};

} // end namespace pixl



================================================
FILE: spokes.cpp
================================================
#include "spokes.h"
#include <Assert.h>
#include <Logging.h>
#include <Math.h>

using namespace pixl;

SpokesAnimation::SpokesAnimation(Visualization* viz, LEDs& leds)
  : leds_(leds),
    viz_(viz)
{ }

SpokesAnimation::~SpokesAnimation() {
  delete[] mapping_;
}

void SpokesAnimation::init() {}
void SpokesAnimation::init(float scale)
{
  Log.Info("Setting up Spokes animation\n");
  
  int spokes = 12;
  int angle = 360 / spokes;
  int perStrip = 60;
  int llen = leds_.length();
  Log.Info("LED count %i\n", llen);

  mapping_ = new double[llen];
  for (int i = 0; i < llen; i++) {
    //Log.Info("LED # %d\n", (int)i);
    mapping_[i] = 0.0;
  }

  // Assume 60 LEDs per spoke, all start from the hub. Starting at 12 o'clock
  // each spoke is offset 30 degrees from the last.
  // 12 - 0-59      1 - 60 - 119        2 - 120 - 179
  //  3 - 180-239   4 - 240 - 299       5 - 300 - 359
  //  6 - 360-410   7 - 420 - 479       8 - 480 - 539
  //  9 - 540-599   10 - 600 - 659      11 - 660 - 719
  for (int iX = 0; iX < spokes; iX++) {
    for (int iY = 0; iY < perStrip; iY++) {
      //Log.Info("LED # %d %d\n", (int)iX, iY);
      mapping_[iX*perStrip+iY] = (float)iY/(float)perStrip * scale;
      //Log.Info("%i calc %s\n", iX*perStrip+iY, (float)iY/(float)perStrip * scale);
    }
  }
}

void SpokesAnimation::setVisualization(Visualization* viz) {
  viz_ = viz;
}

void SpokesAnimation::update() {}

void SpokesAnimation::draw(float interpolation) {
  int spokes = 12;
  int perStrip = 60;
  for (int iY = 0; iY < perStrip; iY++) {
    leds_[iY] = viz_->getColorByRatio(mapping_[iY]);
    for (int iX = 0; iX < spokes; iX++) {
      //Log.Info("LED # %d %d\n", (int)iX, iY);
      leds_[iX*perStrip+iY] = leds_[iY];
      //Log.Info("%i calc %s\n", iX*perStrip+iY, (float)iY/(float)perStrip * scale);
    }
  }
}



================================================
FILE: spokes.h
================================================
#pragma once
#include "animation.h"
#include "leds.h"
#include "visualization.h"

namespace pixl {

class SpokesAnimation : public Animation {
  public:
    SpokesAnimation(Visualization* viz, LEDs& leds);
    ~SpokesAnimation();
    void init();
    void init(float scale);
    void update();
    void draw(float interpolation);
    void setVisualization(Visualization* viz);

  private:
    LEDs& leds_;
    Visualization* viz_;
    double* mapping_;
};

} // end namespace pixl



================================================
FILE: TODO.md
================================================
* Arduino memory limits are being hit. Look into replacing FastLED color arrays
  with code that will calculate color based on mapping and visualizations on
  the fly.
* Sending the same colors to multiple strips or strip segments is being done in
  Triangle because of last minute hackiness.



================================================
FILE: triangle.cpp
================================================
#include "triangle.h"
#include <Logging.h>

using namespace pixl;

TriangleAnimation::TriangleAnimation(Visualization* viz, LEDs** leds, int num_leds)
    : leds_(leds),
      num_leds_(num_leds),
      viz_(viz) {}

TriangleAnimation::~TriangleAnimation() {
  delete[] mapping_;
}

void TriangleAnimation::init() {}
void TriangleAnimation::init(float scale, bool outer) {
  Log.Info("Setting up Triangle animation\n");

  if (outer) {
    init_outer(scale);
  } else {
    init_inner(scale);
  }

  Log.Info("Finished setting up Triangle animation\n");
}

void TriangleAnimation::init_outer(float scale) {
  float viz_scaled = viz_->getSize() * scale;
  int length = leds_[0]->length();
  int side = length / 3;
  int half_side = length / 6;
  float sin_60 = 0.866;
  float sin_30 = 0.5;
  float cos_30 = 0.866;
  float height = sin_60 * side;

  Log.Debug("Initializing outer triangle\n");
  Log.Debug("Length: %d\n", length);
  Log.Debug("Side: %d\n", side);
  Log.Debug("Half Side: %d\n", half_side);

  mapping_ = new float[length];

  // For the top side of the outer triangle
  for (int i = 0; i <= half_side; i++) {
    // Doesn't matter left vs right, they get the same values
    int left_side = side + i;
    int right_side = (2 * side) - i;
    float a_squared = pow(height + 5, 2);
    float b_squared = pow(half_side - i, 2);
    float top_mapping =  sqrt(a_squared + b_squared) / viz_scaled;

    mapping_[left_side] = top_mapping;
    mapping_[right_side] = top_mapping;
  }

  // For the bottom sides of the outer triangle
  for (int i = 0; i <= side; i++) {
    int left_side = i;
    int right_side = length - 1 - i;

    float from_bottom = (float)i * cos_30;
    float from_viz_start = (2.0 * (float)height) + 5.0 - from_bottom;
    float from_midline = (float)i * sin_30;
    float a_squared = pow(from_viz_start, 2);
    float b_squared = pow(from_midline, 2);
    float bottom_mapping = sqrt(a_squared + b_squared) / viz_scaled;

    mapping_[left_side] = bottom_mapping;
    mapping_[right_side] = bottom_mapping;
  }
}

void TriangleAnimation::init_inner(float scale) {

  float viz_scaled = viz_->getSize() * scale;
  int length = leds_[0]->length();
  int side = length / 3;
  int half_side = length / 6;
  float sin_60 = 0.866;
  float height = sin_60 * side;
  float square_height = pow(height, 2);

  Log.Debug("Initializing inner triangle\n");
  Log.Debug("Length: %d\n", length);
  Log.Debug("Side: %d\n", side);
  Log.Debug("Half Side: %d\n", half_side);

  mapping_ = new float[length];

  // For side coming from the center
  for (int i = 0; i <= side; i++) {
    float side_mapping = (float)i / viz_scaled;
    mapping_[i] = side_mapping;
    mapping_[length - 1 - i] = side_mapping;
  }

  // For the bottom side of the inner triangle
  for (int i = 0; i <= half_side; i++) {
    // A^2 + B^2 = C^2
    // A = HEIGHT
    // B = HALF_SIDE
    // C = HYPOTONUSE -- where on the sound wave array to pull values from

    // Doesn't matter left vs right, they get the same values
    int left_side = side + i;
    int right_side = 2 * side - i;
    float bottom_mapping = sqrt(square_height + pow(half_side - i, 2)) / viz_scaled;

    mapping_[right_side] = bottom_mapping;
    mapping_[left_side] = bottom_mapping;
  }
}

void TriangleAnimation::update() {}

void TriangleAnimation::draw(float interpolation) {
  for (int i = 0; i < num_leds_; i++) {
    LEDs* leds = leds_[i];
    for (int j = 0; j < leds->length(); j++) {
      (*leds)[j] = viz_->getColorByRatio(mapping_[j]);
    }
  }
}




================================================
FILE: triangle.h
================================================
#pragma once
#include "animation.h"
#include "leds.h"
#include "visualization.h"

namespace pixl {

class TriangleAnimation : public Animation {
  public:
    TriangleAnimation(Visualization* viz, LEDs* leds[], int num_leds);
    ~TriangleAnimation();
    void init();
    void init(float scale, bool outer = false);
    void init_inner(float scale);
    void init_outer(float scale);
    void update();
    void draw(float interpolation);

  private:
    LEDs** leds_;
    int num_leds_;
    Visualization* viz_;
    float* mapping_;
};

} // end namespace pixl



================================================
FILE: twinkle.cpp
================================================
#include "pixl.h"

using namespace pixl;

namespace pixl {

TwinkleVisualization::TwinkleVisualization(Input* input, int size)
    : Visualization(input, size) {

  // Set up positions array
  positions_ = new bool[size_];
  for (int i = 0; i < size_; i++) {
    positions_[i] = false;
  }

  // Setup up particles array
  randomSeed(micros());
  num_particles_ = size / 3;
  particles_ = new Particle[num_particles_];
  for (int i = 0; i < num_particles_; i++) {
    int brightness = random(0, 255);
    bool direction = random(0, 255) < 128 ? false : true;
    int position = randomFreePosition(0);

    particles_[i] = Particle {
      brightness,
      direction,
      position
    };
  }
}

TwinkleVisualization::~TwinkleVisualization() {
  delete[] positions_;
  delete[] particles_;
}

int TwinkleVisualization::randomFreePosition(int position) {
  positions_[position] = false;

  bool found = false;
  while (!found) {
    position = random(0, size_ - 1);
    if (positions_[position] == false) {
      found = true;
    }
  }

  positions_[position] = true;

  return position;
}

void TwinkleVisualization::update() {
  // Update particles
  for (int i = 0; i < num_particles_; i++) {
    Particle* p = &particles_[i];

    if (p->direction) {
      p->brightness += 4;
      if (p->brightness > 255) {
        p->brightness = 255;
        p->direction = false;
      }
    } else {
      p->brightness -= 4;

      if (p->brightness <= 0) {
        int new_position = randomFreePosition(p->position);

        p->brightness = 0;
        p->direction = true;
        randomSeed(micros());
        p->position = new_position;
      }
    }
  }

  // Blank the viz
  for (int i = 0; i < size_; i++) {
    viz_[i] = CRGB::Black;
  }

  // Apply particles to visualization
  for (int i = 0; i < num_particles_; i++) {
    Particle p = particles_[i];
    viz_[p.position] = CRGB::White;
    viz_[p.position].fadeToBlackBy(255 - p.brightness);
  }
}

} // end namespace pixl



================================================
FILE: twinkle.h
================================================
#pragma once
#include "input.h"
#include "visualization.h"

namespace pixl {

struct Particle {
  int brightness;
  bool direction;
  int position;
};

class TwinkleVisualization : public Visualization {
  public:
    TwinkleVisualization(Input* input, int size = 1);
    ~TwinkleVisualization();
    void update();
  private:
    int randomFreePosition(int position);
    bool* positions_;
    Particle* particles_;
    int num_particles_;
};

} // end namespace pixl



================================================
FILE: util.h
================================================
#pragma once

using namespace pixl;

namespace pixl {

template <typename Type>
Type PushQueue(Type* array, int length, Type value) {
  Type rtrn = array[length - 1];
  for (int i = (length - 1); i > 0; i--) {
    array[i] = array[i - 1];
  }
  array[0] = value;
  return rtrn;
}

} // end namespace pixl



================================================
FILE: visualization.cpp
================================================
#include <assert.h>
#include "pixl.h"

using namespace pixl;

namespace pixl {

CRGB Visualization::getColorByRatio(float ratio) {
  assert(ratio >= 0);
  assert(ratio <= 1);
  float viz_index = (float)(size_ - 1.0) * ratio;
  return getColorByIndex(viz_index);
}

CRGB Visualization::getColorByIndex(float index) {
  assert(index >= 0);
  assert(index < size_);
  CRGB color1 = viz_[(int)floor(index)];
  CRGB color2 = viz_[(int)ceil(index)];
  color1 /= 2;
  color2 /= 2;
  return color1 + color2;
}

CRGB Visualization::getColorByIndex(int index) {
  assert(index >= 0);
  assert(index < size_);
  return viz_[index];
}

HueVisualization::HueVisualization(Input* input, int size)
  : Visualization(input, size) {}

void HueVisualization::update() {
  float val = input_->getInput();
  viz_[0] = CHSV(val * 255, 255, 255);
}

} // end namespace pixl



================================================
FILE: visualization.h
================================================
#pragma once
#include <FastLED.h>
#include "input.h"

namespace pixl {

/* A Visualization is an interface to an n-dimensional set of colors to be used
   in Animations.  Colors are stored as FastLED's CHSV class to make it easier
   for animations to map the colors to a set of LEDs */
class Visualization {
  public:
    Visualization(Input* input, int size = 1)
      : input_(input),
        size_(size)
    {
      viz_ = new CRGB[size];
    };
    ~Visualization() { delete[] viz_; }

    virtual void update()=0;
    int getSize() { return size_; };
    void setInput(Input* input) { input_ = input; }
    CRGB getColorByRatio(float ratio);
    CRGB getColorByIndex(float index);
    CRGB getColorByIndex(int index);
  protected:
    CRGB* viz_;
    Input* input_;
    int size_;
};

class HueVisualization : public Visualization {
  public:
    HueVisualization(Input* input, int size = 1);
    void update();
};

class NullVisualization : public Visualization {
  public:
    NullVisualization(Input* input, int size = 1) :
      Visualization(input, size) {}
    void update() {};
};

} // end namespace pixl



================================================
FILE: examples/curtains-x2/curtains-x2.ino
================================================
#include <pixl.h>
#include <FastLED.h>
#include <Logging.h>

// Uncomment to turn off assertions
#define NDEBUG

// Weird thing I had to do to get the Logging library working with teensy
extern "C"{
  int _getpid(){ return -1;}
  int _kill(int pid, int sig){ return -1; }
  int _write(){return -1;}
}

#define LOGLEVEL LOG_LEVEL_INFOS

using namespace pixl;

Input* input;

// Curtains
LEDStrip strip1 = LEDStrip(150);
LEDStrip strip2 = LEDStrip(150);

// Curtain LEDs
LEDs leds1 = LEDs(&strip1, 0, 150);
LEDs leds2 = LEDs(&strip2, 0, 150);

Visualization* viz;
CurtainAnimation* anim1;
CurtainAnimation* anim2;

// Audio shield setup
AudioInputI2S audio;
//AudioAnalyzePeak peak;
//AudioAnalyzeNoteFrequency note;
//AudioConnection patchCord1(audio, peak);
//AudioConnection patchCord2(audio, note);
AudioControlSGTL5000 audioShield;
AudioAnalyzeFFT1024 fft;
AudioConnection patchCord1(audio, 0, fft, 0);

void setup() {
  Log.Init(LOGLEVEL, 9600);
  delay(1000);
  Log.Info("Starting setup()\n");
  Serial.flush();
  delay(1000);

  AudioMemory(12);
  audioShield.enable();
  audioShield.inputSelect(AUDIO_INPUT_LINEIN);
  audioShield.lineInLevel(15);
  //audioShield.inputSelect(AUDIO_INPUT_MIC);
  //audioShield.micGain(100);
  //note.begin(.99);

  fft.windowFunction(AudioWindowHanning1024);

  //input = new AudioShieldInput(&peak, &note);
  input = new FFTInput(&fft);

  viz = new RippleVisualization(input, 35, 1, true);

  anim1 = new CurtainAnimation(viz, leds1);
  anim2 = new CurtainAnimation(viz, leds2);

  // Inner right  curtain
  anim1->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.17,  // width in ratio of visualiation
     0.0,   // rotation in radians
     0.25,   // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "

  // Inner left curtain
  anim2->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.17,  // width in ratio of visualiation
     0.0,   // rotation in radians
    -0.50,  // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "

  FastLED.addLeds<WS2811,  7, RGB>(strip1.leds, 150);
  FastLED.addLeds<WS2811, 14, RGB>(strip2.leds, 150);

  FastLED.setBrightness(255);

  Looper* looper = Looper::instance();
  looper->addInput(input);
  looper->addVisualization(viz);
  looper->addAnimation(anim1);
  looper->addAnimation(anim2);
  looper->setUpdatesPerSecond(30);

  Log.Info("Finished setup()\n");
  delay(100);
}

void loop() {
  AudioNoInterrupts();
  Looper::instance()->loop();
  AudioInterrupts();
}



================================================
FILE: examples/curtains-x3/curtains-1x3.ino
================================================
#include <pixl.h>
#include <FastLED.h>
#include <Logging.h>

// Uncomment to turn off assertions
#define NDEBUG

// Weird thing I had to do to get the Logging library working with teensy
extern "C"{
  int _getpid(){ return -1;}
  int _kill(int pid, int sig){ return -1; }
  int _write(){return -1;}
}

#define LOGLEVEL LOG_LEVEL_INFOS

using namespace pixl;

Input* input;

// Curtains
LEDStrip strip1 = LEDStrip(150);
LEDStrip strip2 = LEDStrip(150);
LEDStrip strip3 = LEDStrip(150);
//LEDStrip strip4 = LEDStrip(150);
//LEDStrip strip5 = LEDStrip(150);

// Curtain LEDs
LEDs leds1 = LEDs(&strip1, 0, 150);
LEDs leds2 = LEDs(&strip2, 0, 150);
LEDs leds3 = LEDs(&strip3, 0, 150);
//LEDs leds4 = LEDs(&strip4, 0, 150);
//LEDs leds5 = LEDs(&strip5, 0, 150);

Visualization* viz;
CurtainAnimation* anim1;
CurtainAnimation* anim2;
CurtainAnimation* anim3;
CurtainAnimation* anim4;
//CurtainAnimation* anim5;
//CurtainAnimation* anim6;

// Audio shield setup
AudioInputI2S audio;
//AudioAnalyzePeak peak;
//AudioAnalyzeNoteFrequency note;
//AudioConnection patchCord1(audio, peak);
//AudioConnection patchCord2(audio, note);
AudioControlSGTL5000 audioShield;
AudioAnalyzeFFT1024 fft;
AudioConnection patchCord1(audio, 0, fft, 0);

void setup() {
  Log.Init(LOGLEVEL, 9600);
  delay(1000);
  Log.Info("Starting setup()\n");
  Serial.flush();
  delay(1000);

  AudioMemory(12);
  audioShield.enable();
  //audioShield.inputSelect(AUDIO_INPUT_LINEIN);
  audioShield.lineInLevel(15);
  audioShield.inputSelect(AUDIO_INPUT_MIC);
  audioShield.micGain(100);
  //note.begin(.99);

  fft.windowFunction(AudioWindowHanning1024);

//input = new FFTInput(&fft);
input = new WaveInput();
//input = new RandomInput();

  viz = new RippleVisualization(input, 45, 2, true);

  anim1 = new CurtainAnimation(viz, leds1);
  anim2 = new CurtainAnimation(viz, leds2);
  anim3 = new CurtainAnimation(viz, leds3);
  //anim4 = new CurtainAnimation(viz, leds4);
  //anim5 = new CurtainAnimation(viz, leds5);

  // Front center curtain
  anim1->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.33,  // width in ratio of visualiation
     0.0,   // rotation in radians
    -0.17,  // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "

  // Center Inner right curtain
  anim2->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.33,  // width in ratio of visualiation
     0.0,   // rotation in radians
     0.17,  // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "

  // Back Far right curtain
  anim3->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.33,  // width in ratio of visualiation
     0.0,   // rotation in radians
     0.50,  // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "

  FastLED.addLeds<WS2811, 20, RGB>(strip1.leds, 150);
  FastLED.addLeds<WS2811,  14, RGB>(strip2.leds, 150);
  FastLED.addLeds<WS2811, 7, RGB>(strip3.leds, 150);
//  FastLED.addLeds<WS2811, 20, RGB>(strip4.leds, 150);
//  FastLED.addLeds<WS2811,  6, RGB>(strip5.leds, 150);

  FastLED.setBrightness(150);

  Looper* looper = Looper::instance();
  looper->addInput(input);
  looper->addVisualization(viz);
  looper->addAnimation(anim1);
  looper->addAnimation(anim2);
  looper->addAnimation(anim3);
//  looper->addAnimation(anim4);
//  looper->addAnimation(anim5);
  looper->setUpdatesPerSecond(30);

  Log.Info("Finished setup()\n");
  delay(100);
}

void loop() {
  AudioNoInterrupts();
  Looper::instance()->loop();
  AudioInterrupts();
}



================================================
FILE: examples/curtains-x4-switchable/curtains-x4-switchable.ino
================================================
#include <pixl.h>
#include <FastLED.h>
#include <Logging.h>

// Uncomment to turn off assertions
#define NDEBUG

// Weird thing I had to do to get the Logging library working with teensy
extern "C"{
  int _getpid(){ return -1;}
  int _kill(int pid, int sig){ return -1; }
  int _write(){return -1;}
}

#define LOGLEVEL LOG_LEVEL_ERRORS

using namespace pixl;

Input* input;

// Curtains
LEDStrip strip1 = LEDStrip(150);
LEDStrip strip2 = LEDStrip(150);
LEDStrip strip3 = LEDStrip(150);
LEDStrip strip4 = LEDStrip(150);
LEDStrip strip5 = LEDStrip(150);

// Curtain LEDs
LEDs leds1 = LEDs(&strip1, 0, 150);
LEDs leds2 = LEDs(&strip2, 0, 150);
LEDs leds3 = LEDs(&strip3, 0, 150);
LEDs leds4 = LEDs(&strip4, 0, 150);
LEDs leds5 = LEDs(&strip5, 0, 150);

Visualization* viz;
CurtainAnimation* anim1;
CurtainAnimation* anim2;
CurtainAnimation* anim3;
CurtainAnimation* anim4;
CurtainAnimation* anim5;
CurtainAnimation* anim6;

Looper* looper;

// Audio shield setup
AudioInputI2S audio;
//AudioAnalyzePeak peak;
//AudioAnalyzeNoteFrequency note;
//AudioConnection patchCord1(audio, peak);
//AudioConnection patchCord2(audio, note);
AudioControlSGTL5000 audioShield;
AudioAnalyzeFFT1024 fft;
AudioConnection patchCord1(audio, 0, fft, 0);

void setup() {
  Log.Init(LOGLEVEL, 115200);
  delay(1000);
  Log.Info("Starting setup()\n");
  Serial.flush();
  delay(1000);

  AudioMemory(12);
  audioShield.enable();
  //audioShield.inputSelect(AUDIO_INPUT_LINEIN);
  audioShield.inputSelect(AUDIO_INPUT_MIC);
  audioShield.micGain(45);

  fft.windowFunction(AudioWindowHanning1024);

  input = new FFTInput(&fft);

  FastLED.addLeds<WS2811,  2, RGB>(strip1.leds, 150);
  FastLED.addLeds<WS2811,  8, RGB>(strip2.leds, 150);
  FastLED.addLeds<WS2811,  6, RGB>(strip3.leds, 150);
  FastLED.addLeds<WS2811,  7, RGB>(strip4.leds, 150);
  FastLED.addLeds<WS2811,  14, RGB>(strip5.leds, 150);

  FastLED.setBrightness(255);
  viz = new RippleVisualization(input, 35, 1, true);
  anim1 = new CurtainAnimation(viz, leds1);
  anim2 = new CurtainAnimation(viz, leds2);
  anim3 = new CurtainAnimation(viz, leds3);
  anim4 = new CurtainAnimation(viz, leds4);
  anim5 = new CurtainAnimation(viz, leds5);

  // Far right curtain
  anim1->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.33,  // width in ratio of visualiation
     0.0,   // rotation in radians
     0.50,  // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "

  // Inner right curtain
  anim2->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.33,  // width in ratio of visualiation
     0.0,   // rotation in radians
     0.17,  // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "

  // Middle curtain
  anim3->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.33,  // width in ratio of visualiation
     0.0,   // rotation in radians
    -0.19, // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "

  // Inner left curtain
  anim4->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.33,  // width in ratio of visualiation
     0.0,   // rotation in radians
    -0.50,  // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "

  // Far left curtain
  anim5->init(
     25,    // height in pixels
     6,     // width in pixels
     1.0,   // height in ratio of visualiation
     0.33,  // width in ratio of visualiation
     0.0,   // rotation in radians
    -0.88,  // x distance from visualization start in ratio of visualization
    -0.5,   // y "
     0.0);  // z "
     
  looper = Looper::instance();
  
  looper->setUpdatesPerSecond(30);
    
  setupAnim(viz);

  Log.Info("Finished setup()\n");
  delay(100);
}

void loop() {
  runSerial(input, audioShield);

  AudioNoInterrupts();
  Looper::instance()->loop();
  AudioInterrupts();
}

void setupAnim(Visualization* viz) {
  anim1->setVisualization(viz);
  anim2->setVisualization(viz);
  anim3->setVisualization(viz);
  anim4->setVisualization(viz);
  anim5->setVisualization(viz);
  
  looper->clearAll();
  looper->addInput(input);
  looper->addVisualization(viz);
  looper->addAnimation(anim1);
  looper->addAnimation(anim2);
  looper->addAnimation(anim3);
  looper->addAnimation(anim4);
  looper->addAnimation(anim5);
}



================================================
FILE: examples/curtains-x4-switchable/switchableController.ino
================================================
char buffer[16];
int len = 0;
int size = 25;
int smooth = 1;
bool rippleFreq = true;

void runSerial(Input* input, AudioControlSGTL5000 audioShield) {
  if (Serial.available() > 0) {
    // read the incoming byte:
    int incomingByte = Serial.read();
    buffer[len++] = incomingByte;
    if (len >= 16) {
      len = 0; // handle overflows
    }
    if (incomingByte == '\n') {

      if (buffer[0] == '1') {
        setupAnim(new RippleVisualization(input, size, smooth, rippleFreq));
      } else if (buffer[0] == '2') {
        setupAnim(new FireVisualization(input, size));
      } else if (buffer[0] == '3') {
        setupAnim(new TwinkleVisualization(input, size));
      } else if (buffer[0] == 'a') {
        if (buffer[1] == '0') {
          audioShield.inputSelect(AUDIO_INPUT_LINEIN);
        } else {
          audioShield.inputSelect(AUDIO_INPUT_MIC);
        }
      } else if (buffer[0] == 'b') {
        int brightness = 128;
        sscanf(buffer, "b%d", &brightness);
        FastLED.setBrightness(brightness);
      } else if (buffer[0] == 's') {
        int n = sscanf(buffer, "s%d", &size);
        if (n != 1) {
          size = 25;
        }
      } else if (buffer[0] == 'v') {
        int vol = 0;
        if (sscanf(buffer, "v%d", &vol) == 1) {
          audioShield.micGain(vol);
          audioShield.lineInLevel(vol);
        }
      } else if (buffer[0] == 'm') { // smooth
        if (sscanf(buffer, "m%d", &smooth) != 1) {
          smooth = 1;
        }
      } else if (buffer[0] == 'f') {
        if (sscanf(buffer, "f%b", &rippleFreq) != 1) {
          rippleFreq = true;
        }
      }
      len = 0;
    }
  }
}




================================================
FILE: examples/pyramids-pam/pyramids-pam.ino
================================================
#include <pixl.h>
#include <FastLED.h>
#include <Logging.h>

// Weird thing I had to do to get the Logging library working with teensy
extern "C" {
  int _getpid() { return -1; }
  int _kill(int pid, int sig){ return -1; }
  int _write() {return -1; }
}

#define LOGLEVEL LOG_LEVEL_INFOS

using namespace pixl;

Input* input;

LEDStrip strip = LEDStrip(50);
LEDs leds = LEDs(&strip, 0, 50);
Visualization* viz;
ScaledAnimation* anim;

void setup() {
  Log.Init(LOGLEVEL, 9600);
  delay(1000);
  Log.Debug("Starting setup()\n");
  Serial.flush();
  delay(1000);

  input = new RandomInput();

  FastLED.addLeds<WS2811, 6, RGB>(strip.leds, 50);

  viz = new RippleVisualization(input, 50, 1);
  anim = new ScaledAnimation(viz, leds);

  Looper* looper = Looper::instance();
  looper->addInput(input);
  looper->addVisualization(viz);
  looper->addAnimation(anim);
  looper->setUpdatesPerSecond(10);

  FastLED.setBrightness(64);

  Log.Info("Finished setup()\n");
  delay(100);
}

void loop() {
  Looper::instance()->loop();
}



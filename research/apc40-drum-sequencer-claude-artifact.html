<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APC40 Drum Machine Sequencer with MIDI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .controller {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            max-width: 1200px;
            width: 100%;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #444;
        }
        
        .title {
            font-size: 24px;
            font-weight: 600;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-label {
            font-size: 11px;
            text-transform: uppercase;
            color: #888;
            letter-spacing: 1px;
        }
        
        .control-value {
            font-size: 20px;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .midi-status {
            padding: 8px 15px;
            background: #333;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .midi-status.connected {
            background: #1a4a1a;
            border: 1px solid #4ecdc4;
        }
        
        .midi-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        
        .midi-status.connected .midi-indicator {
            background: #4ecdc4;
            animation: pulse 2s infinite;
        }
        
        .color-mode-selector {
            display: flex;
            gap: 10px;
        }
        
        .color-mode-btn {
            padding: 8px 15px;
            background: #444;
            border: 2px solid #666;
            border-radius: 4px;
            color: #ccc;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        
        .color-mode-btn.active {
            background: #4ecdc4;
            border-color: #4ecdc4;
            color: #000;
        }
        
        .color-mode-btn:hover:not(.active) {
            background: #555;
            border-color: #888;
        }
        
        .sequencer {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .track {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            align-items: center;
        }
        
        .track-label {
            width: 100px;
            font-size: 14px;
            font-weight: 500;
            text-align: right;
            padding-right: 15px;
            color: #aaa;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
        
        .track-icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 8px;
            background: #666;
        }
        
        .steps {
            display: flex;
            gap: 6px;
            flex: 1;
        }
        
        .step {
            flex: 1;
            aspect-ratio: 1;
            background: #333;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            min-width: 40px;
            max-width: 60px;
        }
        
        .step::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(255,255,255,0.2) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .step.active {
            border-color: #888;
        }
        
        .step.active::before {
            opacity: 1;
        }
        
        .step.current {
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.8);
            transform: scale(1.1);
        }
        
        .step:nth-child(4n+1) {
            border-left-width: 3px;
            border-left-color: #666;
        }
        
        .transport {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }
        
        .transport-btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #444 0%, #555 100%);
            border: 2px solid #666;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .transport-btn:hover {
            background: linear-gradient(135deg, #555 0%, #666 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        
        .transport-btn.playing {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a3a0 100%);
            border-color: #4ecdc4;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(78, 205, 196, 0.4); }
            50% { box-shadow: 0 0 30px rgba(78, 205, 196, 0.8); }
        }
        
        .velocity-indicator {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            transition: height 0.2s;
        }
        
        @media (max-width: 768px) {
            .track-label {
                width: 60px;
                font-size: 12px;
            }
            
            .step {
                min-width: 25px;
            }
        }
    </style>
</head>
<body>
    <div class="controller">
        <div class="header">
            <h1 class="title">APC40 Drum Sequencer</h1>
            <div class="controls">
                <div class="midi-status" id="midiStatus">
                    <span class="midi-indicator"></span>
                    <span id="midiStatusText">No MIDI</span>
                </div>
                <button class="transport-btn" id="connectMidiBtn" style="padding: 8px 15px; font-size: 12px;">Connect APC40</button>
                <div class="control-group">
                    <span class="control-label">BPM</span>
                    <span class="control-value" id="bpm">120</span>
                </div>
                <div class="control-group">
                    <span class="control-label">Color Mode</span>
                    <div class="color-mode-selector">
                        <button class="color-mode-btn active" data-mode="spectrum">Spectrum</button>
                        <button class="color-mode-btn" data-mode="chromatic">Chromatic</button>
                        <button class="color-mode-btn" data-mode="harmonic">Harmonic</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="sequencer" id="sequencer">
            <!-- Tracks will be generated by JavaScript -->
        </div>
        
        <div class="transport">
            <button class="transport-btn" id="playBtn">▶ Play</button>
            <button class="transport-btn" id="clearBtn">Clear</button>
            <button class="transport-btn" id="randomBtn">Random</button>
        </div>
    </div>
    
    <script>
        // APC40 MIDI Controller Class
        class APC40Controller {
            constructor() {
                this.input = null;
                this.output = null;
                this.midiAccess = null;
                this.connected = false;
                this.ledStates = new Map();
                this.updateQueue = [];
                this.isProcessingQueue = false;
            }

            async connect() {
                try {
                    // Check browser support
                    if (!navigator.requestMIDIAccess) {
                        throw new Error('Web MIDI API not supported in this browser');
                    }

                    // Request MIDI access with SysEx for mode switching
                    this.midiAccess = await navigator.requestMIDIAccess({ sysex: true });
                    
                    // Find APC40 ports
                    for (const output of this.midiAccess.outputs.values()) {
                        if (output.name.includes('APC40') || output.name.includes('APC mini')) {
                            this.output = output;
                            console.log('Found APC40 output:', output.name);
                            break;
                        }
                    }

                    for (const input of this.midiAccess.inputs.values()) {
                        if (input.name.includes('APC40') || input.name.includes('APC mini')) {
                            this.input = input;
                            input.onmidimessage = this.handleMIDIMessage.bind(this);
                            console.log('Found APC40 input:', input.name);
                            break;
                        }
                    }

                    if (this.output && this.input) {
                        await this.initializeDevice();
                        this.connected = true;
                        return true;
                    } else {
                        throw new Error('APC40 not found. Please connect your APC40 and try again.');
                    }
                } catch (error) {
                    console.error('MIDI connection failed:', error);
                    this.connected = false;
                    throw error;
                }
            }

            async initializeDevice() {
                // Switch to Ableton Live Mode (Mode 1) for full LED control
                // This SysEx message is for APC40 MK2
                const modeSwitch = [0xF0, 0x47, 0x7F, 0x29, 0x60, 0x00, 0x04, 0x41, 0x09, 0x07, 0x01, 0xF7];
                
                try {
                    this.output.send(modeSwitch);
                    console.log('APC40 mode switch sent');
                } catch (e) {
                    console.log('Mode switch may not be supported on this device');
                }
                
                // Small delay for mode switching
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Clear all LEDs
                this.clearAllLEDs();
            }

            handleMIDIMessage(event) {
                const [command, note, velocity] = event.data;
                
                if (command === 0x90 && velocity > 0) {
                    // Button press
                    this.onButtonPress?.(note, velocity);
                } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
                    // Button release
                    this.onButtonRelease?.(note);
                }
            }

            setLED(note, color, animationType = 0) {
                if (!this.output || !this.connected) return;
                
                // Skip if LED already in target state
                const key = `${note}-${animationType}`;
                if (this.ledStates.get(key) === color) return;
                
                this.ledStates.set(key, color);
                
                // Queue the update
                this.queueLEDUpdate(note, color, animationType);
            }

            queueLEDUpdate(note, color, animationType) {
                this.updateQueue.push({ note, color, animationType });
                
                if (!this.isProcessingQueue) {
                    this.processUpdateQueue();
                }
            }

            async processUpdateQueue() {
                this.isProcessingQueue = true;
                
                while (this.updateQueue.length > 0) {
                    // Process updates in batches to prevent MIDI overflow
                    const batch = this.updateQueue.splice(0, 8);
                    
                    batch.forEach(({ note, color, animationType }) => {
                        const channel = animationType;
                        try {
                            this.output.send([0x90 | channel, note, color]);
                        } catch (e) {
                            console.error('Failed to send MIDI:', e);
                        }
                    });
                    
                    // Small delay to prevent buffer overflow
                    await new Promise(resolve => setTimeout(resolve, 5));
                }
                
                this.isProcessingQueue = false;
            }

            clearAllLEDs() {
                if (!this.output || !this.connected) return;
                
                // Clear the 8x5 clip grid
                for (let note = 0; note < 40; note++) {
                    this.setLED(note, 0);
                }
            }

            disconnect() {
                if (this.input) {
                    this.input.onmidimessage = null;
                }
                this.clearAllLEDs();
                this.connected = false;
                this.input = null;
                this.output = null;
            }
        }

        // APC40 MIDI Note mappings
        const APC40_NOTES = {
            CLIP_GRID: {
                ROW_1: [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07],
                ROW_2: [0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F],
                ROW_3: [0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17],
                ROW_4: [0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F],
                ROW_5: [0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27]
            }
        };

        const LED_COLORS = {
            OFF: 0,
            GREEN: 1,
            GREEN_BLINK: 2,
            RED: 3,
            RED_BLINK: 4,
            ORANGE: 5,
            ORANGE_BLINK: 6,
            YELLOW: 7,
            // Extended colors for MK2
            WHITE: 6,
            BLUE: 45,
            CYAN: 14,
            MAGENTA: 53,
            PURPLE: 10
        };

        // Main sequencer application
        const tracks = [
            { name: 'Kick', note: 36, icon: '#ff4444' },
            { name: 'Snare', note: 38, icon: '#44ff44' },
            { name: 'Closed Hat', note: 42, icon: '#ffff44' },
            { name: 'Open Hat', note: 46, icon: '#ff44ff' },
            { name: 'Clap', note: 39, icon: '#44ffff' },
            { name: 'Tom Low', note: 43, icon: '#ff8844' },
            { name: 'Tom High', note: 50, icon: '#8844ff' },
            { name: 'Cymbal', note: 49, icon: '#ffffff' }
        ];
        
        let isPlaying = false;
        let currentStep = 0;
        let intervalId = null;
        let colorMode = 'spectrum';
        let patterns = {};
        let apc40 = null;
        
        // Map 16 steps to APC40 grid (using bottom 2 rows)
        const stepToAPC40Note = (stepIndex) => {
            if (stepIndex < 8) {
                return APC40_NOTES.CLIP_GRID.ROW_1[stepIndex];
            } else {
                return APC40_NOTES.CLIP_GRID.ROW_2[stepIndex - 8];
            }
        };
        
        const apc40NoteToStep = (note) => {
            let index = APC40_NOTES.CLIP_GRID.ROW_1.indexOf(note);
            if (index >= 0) return index;
            
            index = APC40_NOTES.CLIP_GRID.ROW_2.indexOf(note);
            if (index >= 0) return index + 8;
            
            return -1;
        };

        // Color mapping functions
        const colorModes = {
            spectrum: (note, velocity) => {
                const normalized = (note - 36) / (127 - 36);
                const hue = normalized * 300;
                const lightness = 20 + (velocity / 127) * 60;
                return `hsl(${hue}, 100%, ${lightness}%)`;
            },
            
            chromatic: (note, velocity) => {
                const noteClass = note % 12;
                const hue = (noteClass / 12) * 360;
                const lightness = 20 + (velocity / 127) * 60;
                return `hsl(${hue}, 100%, ${lightness}%)`;
            },
            
            harmonic: (note, velocity) => {
                const fifthsOrder = [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5];
                const noteClass = note % 12;
                const fifthIndex = fifthsOrder.indexOf(noteClass);
                const hue = (fifthIndex / 12) * 360;
                const lightness = 20 + (velocity / 127) * 60;
                return `hsl(${hue}, 100%, ${lightness}%)`;
            }
        };
        
        // Get LED color for APC40 based on velocity
        const getAPC40Color = (velocity) => {
            if (velocity > 100) return LED_COLORS.RED;
            else if (velocity > 70) return LED_COLORS.ORANGE;
            else return LED_COLORS.GREEN;
        };

        // Update APC40 LED for a step
        function updateAPC40StepLED(trackIndex, stepIndex) {
            if (!apc40 || !apc40.connected) return;
            
            // For this demo, we'll use the first track's pattern on the APC40
            if (trackIndex !== 0) return;
            
            const apc40Note = stepToAPC40Note(stepIndex);
            const isActive = patterns[trackIndex] && patterns[trackIndex][stepIndex];
            
            let color;
            if (stepIndex === currentStep && isPlaying) {
                color = LED_COLORS.WHITE; // White for current step
            } else if (isActive) {
                const velocity = patterns[trackIndex][stepIndex].velocity;
                color = getAPC40Color(velocity);
            } else {
                color = LED_COLORS.OFF;
            }
            
            apc40.setLED(apc40Note, color);
        }

        // Update all APC40 LEDs
        function updateAllAPC40LEDs() {
            if (!apc40 || !apc40.connected) return;
            
            // Update all 16 steps for track 0 (kick drum)
            for (let i = 0; i < 16; i++) {
                updateAPC40StepLED(0, i);
            }
        }

        // Initialize sequencer
        function initSequencer() {
            const sequencer = document.getElementById('sequencer');
            sequencer.innerHTML = '';
            
            tracks.forEach((track, trackIndex) => {
                const trackDiv = document.createElement('div');
                trackDiv.className = 'track';
                
                const label = document.createElement('div');
                label.className = 'track-label';
                label.innerHTML = `${track.name}<span class="track-icon" style="background: ${track.icon}"></span>`;
                trackDiv.appendChild(label);
                
                const stepsDiv = document.createElement('div');
                stepsDiv.className = 'steps';
                
                patterns[trackIndex] = patterns[trackIndex] || [];
                
                for (let i = 0; i < 16; i++) {
                    const step = document.createElement('div');
                    step.className = 'step';
                    step.dataset.track = trackIndex;
                    step.dataset.step = i;
                    
                    const velocityIndicator = document.createElement('div');
                    velocityIndicator.className = 'velocity-indicator';
                    step.appendChild(velocityIndicator);
                    
                    step.addEventListener('click', () => toggleStep(trackIndex, i, step));
                    
                    if (patterns[trackIndex][i]) {
                        activateStep(step, patterns[trackIndex][i].velocity);
                    }
                    
                    stepsDiv.appendChild(step);
                }
                
                trackDiv.appendChild(stepsDiv);
                sequencer.appendChild(trackDiv);
            });
            
            updateAllAPC40LEDs();
        }
        
        function toggleStep(trackIndex, stepIndex, element) {
            if (!patterns[trackIndex]) patterns[trackIndex] = [];
            
            if (patterns[trackIndex][stepIndex]) {
                // Deactivate
                patterns[trackIndex][stepIndex] = null;
                element.classList.remove('active');
                element.style.background = '#333';
                element.querySelector('.velocity-indicator').style.height = '0';
            } else {
                // Activate with random velocity
                const velocity = 60 + Math.random() * 67;
                patterns[trackIndex][stepIndex] = { velocity };
                activateStep(element, velocity);
            }
            
            // Update APC40 LED
            updateAPC40StepLED(trackIndex, stepIndex);
        }
        
        function activateStep(element, velocity) {
            const trackIndex = parseInt(element.dataset.track);
            const track = tracks[trackIndex];
            const color = colorModes[colorMode](track.note, velocity);
            
            element.classList.add('active');
            element.style.background = color;
            element.style.borderColor = color;
            
            const velocityHeight = (velocity / 127) * 60;
            element.querySelector('.velocity-indicator').style.height = `${velocityHeight}%`;
        }
        
        function updateSequencer() {
            // Clear current step highlight
            document.querySelectorAll('.step.current').forEach(el => {
                el.classList.remove('current');
            });
            
            // Update APC40 LEDs for previous step
            if (apc40 && apc40.connected) {
                const prevStep = (currentStep - 1 + 16) % 16;
                updateAPC40StepLED(0, prevStep);
            }
            
            // Highlight current step
            document.querySelectorAll(`.step[data-step="${currentStep}"]`).forEach(el => {
                el.classList.add('current');
                
                const trackIndex = parseInt(el.dataset.track);
                if (patterns[trackIndex] && patterns[trackIndex][currentStep]) {
                    const velocity = patterns[trackIndex][currentStep].velocity;
                    const track = tracks[trackIndex];
                    const flashColor = colorModes[colorMode](track.note, Math.min(127, velocity * 1.5));
                    el.style.boxShadow = `0 0 30px ${flashColor}`;
                    setTimeout(() => {
                        el.style.boxShadow = '';
                    }, 100);
                }
            });
            
            // Update current step on APC40
            updateAPC40StepLED(0, currentStep);
            
            currentStep = (currentStep + 1) % 16;
        }
        
        function play() {
            if (isPlaying) return;
            isPlaying = true;
            const bpm = parseInt(document.getElementById('bpm').textContent);
            const stepTime = (60 / bpm) * 1000 / 4;
            
            document.getElementById('playBtn').classList.add('playing');
            document.getElementById('playBtn').innerHTML = '⏸ Pause';
            
            updateSequencer();
            intervalId = setInterval(updateSequencer, stepTime);
        }
        
        function stop() {
            isPlaying = false;
            if (intervalId) clearInterval(intervalId);
            document.getElementById('playBtn').classList.remove('playing');
            document.getElementById('playBtn').innerHTML = '▶ Play';
            currentStep = 0;
            
            document.querySelectorAll('.step.current').forEach(el => {
                el.classList.remove('current');
            });
            
            updateAllAPC40LEDs();
        }
        
        function clearPattern() {
            patterns = {};
            initSequencer();
        }
        
        function randomPattern() {
            patterns = {};
            tracks.forEach((track, trackIndex) => {
                patterns[trackIndex] = [];
                for (let i = 0; i < 16; i++) {
                    if (Math.random() > 0.7) {
                        patterns[trackIndex][i] = {
                            velocity: 60 + Math.random() * 67
                        };
                    }
                }
            });
            initSequencer();
        }

        // MIDI Connection Handler
        async function connectMIDI() {
            const statusEl = document.getElementById('midiStatus');
            const statusText = document.getElementById('midiStatusText');
            const connectBtn = document.getElementById('connectMidiBtn');
            
            try {
                connectBtn.disabled = true;
                statusText.textContent = 'Connecting...';
                
                if (!apc40) {
                    apc40 = new APC40Controller();
                }
                
                await apc40.connect();
                
                // Set up APC40 button handlers
                apc40.onButtonPress = (note, velocity) => {
                    const stepIndex = apc40NoteToStep(note);
                    if (stepIndex >= 0) {
                        // Toggle step on track 0 (kick)
                        const stepEl = document.querySelector(`.step[data-track="0"][data-step="${stepIndex}"]`);
                        if (stepEl) {
                            toggleStep(0, stepIndex, stepEl);
                        }
                    }
                };
                
                statusEl.classList.add('connected');
                statusText.textContent = 'APC40 Connected';
                connectBtn.textContent = 'Disconnect';
                connectBtn.disabled = false;
                
                // Initialize LEDs
                updateAllAPC40LEDs();
                
            } catch (error) {
                statusText.textContent = 'Connection Failed';
                connectBtn.textContent = 'Connect APC40';
                connectBtn.disabled = false;
                alert('Failed to connect to APC40: ' + error.message);
            }
        }

        function disconnectMIDI() {
            if (apc40) {
                apc40.disconnect();
                apc40 = null;
            }
            
            const statusEl = document.getElementById('midiStatus');
            const statusText = document.getElementById('midiStatusText');
            const connectBtn = document.getElementById('connectMidiBtn');
            
            statusEl.classList.remove('connected');
            statusText.textContent = 'No MIDI';
            connectBtn.textContent = 'Connect APC40';
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            if (isPlaying) stop();
            else play();
        });
        
        document.getElementById('clearBtn').addEventListener('click', clearPattern);
        document.getElementById('randomBtn').addEventListener('click', randomPattern);
        
        document.getElementById('connectMidiBtn').addEventListener('click', async () => {
            if (apc40 && apc40.connected) {
                disconnectMIDI();
            } else {
                await connectMIDI();
            }
        });
        
        // Color mode switching
        document.querySelectorAll('.color-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.color-mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                colorMode = btn.dataset.mode;
                
                document.querySelectorAll('.step.active').forEach(step => {
                    const trackIndex = parseInt(step.dataset.track);
                    const stepIndex = parseInt(step.dataset.step);
                    if (patterns[trackIndex] && patterns[trackIndex][stepIndex]) {
                        activateStep(step, patterns[trackIndex][stepIndex].velocity);
                    }
                });
            });
        });
        
        // Initialize with a demo pattern
        function initDemoPattern() {
            patterns[0] = [];
            [0, 4, 8, 12].forEach(i => {
                patterns[0][i] = { velocity: 100 };
            });
            
            patterns[1] = [];
            [4, 12].forEach(i => {
                patterns[1][i] = { velocity: 90 };
            });
            
            patterns[2] = [];
            for (let i = 0; i < 16; i += 2) {
                patterns[2][i] = { velocity: 60 + Math.random() * 30 };
            }
            
            initSequencer();
        }
        
        // Initialize
        initDemoPattern();
    </script>
</body>
</html>